{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/baidu_verify_8XSeM7eMve.html","path":"baidu_verify_8XSeM7eMve.html","modified":1,"renderable":0},{"_id":"source/baidu_verify_dwtSoxggNN.html","path":"baidu_verify_dwtSoxggNN.html","modified":1,"renderable":0},{"_id":"source/google4c032a09928621bb.html","path":"google4c032a09928621bb.html","modified":1,"renderable":0},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"5d45c81952b7b85f5efa4ddee681059d5c338a05","modified":1542207814874},{"_id":"source/baidu_verify_8XSeM7eMve.html","hash":"71affe2112f8d9ff535154b9fce55fcf35b9dac0","modified":1542382215016},{"_id":"source/baidu_verify_dwtSoxggNN.html","hash":"da7a36effdd7ddf4e8d944e271ac09f008f2e06c","modified":1542382215016},{"_id":"source/google4c032a09928621bb.html","hash":"028632d0072b2953844fddfbb0874c2bc33765fa","modified":1542382215017},{"_id":"themes/clean-blog/LICENSE","hash":"8726b416df4f067cff579e859f05c4b594b8be09","modified":1542382215017},{"_id":"themes/clean-blog/README.md","hash":"c5c7b0fd01aa229304e7b00697517aaca51de577","modified":1542382215017},{"_id":"themes/clean-blog/_config.yml","hash":"38a50b4f4c1adbc471be14d7854872934aa629b0","modified":1542382215017},{"_id":"themes/clean-blog/.DS_Store","hash":"9886dccca6a03709f63ea164497c7d8743f4f7f7","modified":1543416946559},{"_id":"source/_posts/.DS_Store","hash":"c01e3979087dfab027e645e26e1c9a1d67d97a33","modified":1542293233066},{"_id":"source/_posts/VUE使用小结——组件通信篇.md","hash":"88bddf1c1bc8feebfa316144101c180072bc1f64","modified":1542382215009},{"_id":"source/_posts/JS单线程与异步.md","hash":"c662d3906160f35996d7f462b07dbf80b0f3905e","modified":1542382215008},{"_id":"source/_posts/ES6——一场JavaScript语法的重大变革.md","hash":"a60579bd8c0949a04ff049b4f19f4c6083776e48","modified":1543674126799},{"_id":"source/_posts/VUE使用小结——踩坑篇.md","hash":"e9fbfb1227889714dd51d40597a93cd5861cd0a7","modified":1542382215009},{"_id":"source/_posts/二进制流图片转base64或blob地址.md","hash":"3062c1a698d93b8be670397761dc77b8f86221ab","modified":1542382215010},{"_id":"source/_posts/对原型及原型链的简单理解.md","hash":"3ab66ee845fde81a45ecfdf31e715081d57ad331","modified":1542382215011},{"_id":"source/_posts/善始者实繁，而克终者盖寡.md","hash":"c1c0e36eb4128f2ee2565f254593811d633586c2","modified":1542382215010},{"_id":"source/_posts/时间烙下的是举手投足的习惯.md","hash":"787065202be78a7fe199772dec9b9c412ccf7cc6","modified":1543674394234},{"_id":"source/_posts/微信小程序那些你不知道的事儿.md","hash":"ed1abffef5c695dbb233007566f046106a96b8a3","modified":1542382215012},{"_id":"source/_posts/探访JS作用域.md","hash":"3ce9bd844df52137c6aaadcce58240cd9086f1d3","modified":1542382215012},{"_id":"source/_posts/浅谈正则.md","hash":"de28a3addbd018cd0beafd2e42f88e3e7d386690","modified":1542382215013},{"_id":"source/_posts/生命中那些不期而遇.md","hash":"26f9b12a62b8a8d616534290cd19df2a408c04fc","modified":1542382215014},{"_id":"source/_posts/解决MAC执行.sh文件报错.md","hash":"d00a77007938d17fabe6782891fbe94cce438c43","modified":1542382215014},{"_id":"source/_posts/解惑JavaScript中的this指向问题.md","hash":"d3a0935cb757bddf76671f6e0874c58267ece852","modified":1542382215015},{"_id":"source/_posts/达拉斯弧线.md","hash":"8da134a4610409740b02787ec8db0cfe192e3df0","modified":1542382215016},{"_id":"themes/clean-blog/languages/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1542382215018},{"_id":"themes/clean-blog/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1542382215018},{"_id":"themes/clean-blog/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1542382215018},{"_id":"themes/clean-blog/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1542382215018},{"_id":"themes/clean-blog/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1542382215018},{"_id":"themes/clean-blog/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1542382215019},{"_id":"themes/clean-blog/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1542382215019},{"_id":"themes/clean-blog/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1542382215019},{"_id":"themes/clean-blog/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1542382215019},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1542382215019},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1542382215019},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"0852efccc2d05bc9f2f5b891aa560812bd7bf2d0","modified":1542382215026},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"b35bf9bdd52e57720b3e29af9ce5513705d9d307","modified":1542382215026},{"_id":"themes/clean-blog/layout/index.ejs","hash":"1003b80b2bcff0a0a60feb8916d27ff6d775a240","modified":1542382215026},{"_id":"themes/clean-blog/layout/page.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1542382215027},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1542382215027},{"_id":"themes/clean-blog/source/.DS_Store","hash":"0c76b23f53107b25e48e8137fc14ef57ea0e7cb4","modified":1543416952250},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"3d8d98c6545b8332a6d6ed4f8b00327df03ea945","modified":1542382215020},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"7c195ebc56be7419cf427f665ebdaec13ebb7825","modified":1542382215021},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"f4cb301160245a8f1c6f27c793cb188229596f71","modified":1542382215021},{"_id":"themes/clean-blog/layout/_partial/article-toc.ejs","hash":"1fdc765fcf0747f8b2b2f95382b6f091d60fcc8b","modified":1542382215022},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"7666dcf70d2a42c3d6964195cb32a54423578814","modified":1542382215020},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"e999fad3718b8a503fa4361306726d545ea2d420","modified":1542382215022},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1542382215020},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"bbb6f05dcc9b1684b108f7853326c1e5da4d5ccd","modified":1542382215021},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"b9aac7f45e71f5a63f4ac420e301fedc4d4ca68b","modified":1542382215022},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"21e4f28909f4a79ff7d9f10bdfef6a8cb11632bf","modified":1542382215023},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1542382215023},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"b4b7d85eb237eca4551bad3da53e4c74f69bce87","modified":1542382215023},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"ba299316400499e9ede154e9627cafb7ce411888","modified":1542382215024},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"d472979e8d914cf2f7c4ba85b4863ac49885b179","modified":1542382215025},{"_id":"themes/clean-blog/layout/_partial/intro.ejs","hash":"f94c3abeb2631d7d6715a61e4dd36e3e5be4287c","modified":1542382215024},{"_id":"themes/clean-blog/layout/_partial/link.ejs","hash":"6f69ff84645d586e1841a121331aa81034b258cc","modified":1542382215024},{"_id":"themes/clean-blog/layout/_partial/top.ejs","hash":"b85b5e5bb6ee5f09360590390e98bf5ff7bc3256","modified":1542382215025},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"5cd8804082a14cb8f440ece692dffa98dd36e47f","modified":1542382215029},{"_id":"themes/clean-blog/source/css/article.styl","hash":"a789e7776a7d6639b8d23dfcca4480474a32439d","modified":1543674601581},{"_id":"themes/clean-blog/source/css/style.styl","hash":"c40dc495a41007d21c59f342ee42b2d31d7b5ff4","modified":1542382215029},{"_id":"themes/clean-blog/source/css/base.styl","hash":"48b675960ba0916be1cb510a67d4c36bf843bb14","modified":1543585237620},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"cd82df5ca8dfbcfec12d833f01adfac00878e835","modified":1542382215029},{"_id":"themes/clean-blog/source/css/.DS_Store","hash":"e1d7697b31a345c1352e99e07e848eb0b2ab9199","modified":1543417400014},{"_id":"themes/clean-blog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1542382215030},{"_id":"themes/clean-blog/source/img/favicon.ico","hash":"a32b4ff9cd9a83b0ebbdf086679377ba0f35e0e1","modified":1542382215032},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1542382215033},{"_id":"themes/clean-blog/source/img/avatar.jpg","hash":"91613573410e6e419a5d25b7ad4ee122fdb82cf5","modified":1542382215031},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1542382215032}],"Category":[{"name":"技术","_id":"cjp5k06st0002xl69lilorf2r"},{"name":"生活","_id":"cjp5k06tj000ixl69nsu5ydjv"}],"Data":[],"Page":[],"Post":[{"title":"VUE使用小结——组件通信篇","date":"2018-07-14T14:23:26.000Z","urlname":"vue-components-communication","toc":true,"_content":"\nvue作为当下最火的框架之一，上手快社区活跃文档清晰各类插件繁多的特点让其在大量前端团队中备受青睐。\n\n从16年中开始使用vue1.0到逐渐过渡到现在的2.0，两年的时间里vue一直是我团队中主要的前端框架，但在过往的项目中仅仅只是大量的利用了vue单页应用、路由、双向数据绑定以及数据驱动视图的特点，没有最大化的运用vue的功能，想来也是可惜。\n\n时过境迁，公司目前项目的业务特点再加上有前人的技术沉淀，对于vue的开发使用比以往丰富了很多，自身也有意的想更多的去发掘vue的用法，在使用学习的过程中，不断有新的收获，累积总结于此，便开启了vue系列的第一篇。\n## 组件通信\n当项目中的某一部分功能经常会被复用时，每次都写一段一样的代码显然并不妥当，为了方便我们可以把这部分代码封装成一个组件，当有需要用到的时候直接引用这个组件就好了。那么如何在调用组件的时候向其传入数据以及组件中的行为如何影响到调用他的父组件，简而言之，组件之间的通信是我们需要解决的问题。而组件通信分为父子组件通信和非父子组件通信。\n\n### 1、父子组件通信\n#### 父向子传值\n``` html\n<addScale :title=\"title\"></addScale>\n```\n向子组件传值的方式很简单，只要通过`v-bind`绑定特性就可以了，简写就是`:title`，这样就可以向子组件中传递一个名为title的变量。\n\n``` html\n<div>{{title}}</div>\n```\n``` javascript\nexport default {\n  props: {\n    'title': String\n  }\n}\n```\n\n那么在子组件中通过`props`声明可被接受的数据就可以在子组件中使用了，如上就是在子组件中接收一个类型为字符串的变量，如果不需要校验类型那么直接可以以数组的方式接收。\n\n``` javascript\nexport default {\n  props: ['title']\n}\n```\n如果变量还有声明默认值还有第三种写法：\n\n``` javascript\nexport default {\n  props: {\n    title:{\n      type: String,\n      default: 'hello' \n    }\n  }\n}\n```\n#### 子向父发送事件\n既然获取数据已经实现了，那么如何在子组件中向父组件发送事件呢，只需通过`emit`和`on`就可以实现了。\n\n``` javascript\n//子组件\nthis.$emit('getId',this.id) \n```\n``` html\n// 父组件\n<addScale :title=\"title\" v-on:getId=\"getId(id)\"></addScale>\n```\n以上，子组件通过emit发送了一个名为getId的事件，并且传递了一个id作为参数，在父组件中我们使用`v-on`（也可用`@getId`）来监听这个事件以实现我们想要的功能。\n#### 好用的ref\n有些时候我们也会有需要在父组件中调用子组件的方法或数据，这个时候`ref`的优势便体现出来了：\n\n``` html\n//父组件\n<addGoods ref=\"goodItem\"></addGoods>\n```\n``` javascript\nthis.$refs['goodItem'].resetSearch()\n```\n当在组件上使用`ref`特性时，`ref`便指向了这个组件的实例,可以通过这种方法调用子组件上的`resetSearch`方法，当然也可以使用组件实例中的数据。\n而当`ref`用在普通的DOM元素上时便是指向这个DOM，可以利用它完成一些DOM操作。\n\n#### $parent\n`$parent`可以让子组件调用到父组件的方法,`$root`指向根节点。\n### 2、非父子组件通信\n\n非父子组件通信的核心是拉来一个第三方做中间人，事件的发送和监听都绑定在这个第三方实例上，我们称之为eventbus。使用方法有两种，一种是新建一个bus.js里面new一个Vue实例，在需要使用的组件中引用。\n\n``` javascript\n//bus.js\nimport Vue from 'vue'\nexport default new Vue\n```\n``` html\n//组件A\n<template>\n  <div id=\"componentA\">\n    <button @click=\"send\">按钮</button>\n  </div>\n</template> \n\nimport Bus from './bus.js' \nexport default { \n  data() {\n    return {\n      message: 'how are you?'\n    }\n  },\n　methods: {\n    send () {\n      Bus.$emit('msg', this.message)\n    }\n  }\n}\n```\n``` javascript\n//组件B\nimport Bus from './bus.js'\nexport default {\n  data() {\n    return {\n    \tmessage:  ''\n    }\n  },\n  mounted() {\n    Bus.$on('msg', (e) => {\n　　　console.log(`有人向你打招呼：${e}`)\n    })\n  }\n}\n```\n这样两个组件都通过中间人Bus来获取和发送事件，便可以实现两个组件间的通信了。\n\n还有一种方法是将eventbus放在vue的根实例下：\n\n``` javascript\nnew Vue({\n  el: '#app',\n  router,\n  render: h => h(App),\n  data: {\n    // 空的实例放到根组件下，所有的子组件都能调用\n    Bus: new Vue()\n  }\n})\n```\n``` html\n//组件A\n<template>\n  <div id=\"componentA\">\n    <button @click=\"send\">按钮</button>\n  </div>\n</template> \n\nexport default { \n  data() {\n    return {\n      message: 'how are you?'\n    }\n  },\n　methods: {\n    send () {\n      this.$root.Bus.$emit('msg', this.message)\n    }\n  }\n}\n```\n这样通过`this.$root.Bus`去调用eventbus可以不用单独再引入bus.js，所有在根实例下的组件都可以调用。\n\n以上的方法在逻辑简单的组件通信中使用是很方便的，当数据量大逻辑复杂的时候，就可以考虑使用vuex进行状态管理了，关于vuex的相关使用我会找时间单独写一篇博客。","source":"_posts/VUE使用小结——组件通信篇.md","raw":"---\ntitle: VUE使用小结——组件通信篇\ndate: 2018-07-14 22:23:26\nurlname: vue-components-communication\ncategories: [\"技术\"]\ntags: [\"前端\", \"vue\"]\ntoc: true\n---\n\nvue作为当下最火的框架之一，上手快社区活跃文档清晰各类插件繁多的特点让其在大量前端团队中备受青睐。\n\n从16年中开始使用vue1.0到逐渐过渡到现在的2.0，两年的时间里vue一直是我团队中主要的前端框架，但在过往的项目中仅仅只是大量的利用了vue单页应用、路由、双向数据绑定以及数据驱动视图的特点，没有最大化的运用vue的功能，想来也是可惜。\n\n时过境迁，公司目前项目的业务特点再加上有前人的技术沉淀，对于vue的开发使用比以往丰富了很多，自身也有意的想更多的去发掘vue的用法，在使用学习的过程中，不断有新的收获，累积总结于此，便开启了vue系列的第一篇。\n## 组件通信\n当项目中的某一部分功能经常会被复用时，每次都写一段一样的代码显然并不妥当，为了方便我们可以把这部分代码封装成一个组件，当有需要用到的时候直接引用这个组件就好了。那么如何在调用组件的时候向其传入数据以及组件中的行为如何影响到调用他的父组件，简而言之，组件之间的通信是我们需要解决的问题。而组件通信分为父子组件通信和非父子组件通信。\n\n### 1、父子组件通信\n#### 父向子传值\n``` html\n<addScale :title=\"title\"></addScale>\n```\n向子组件传值的方式很简单，只要通过`v-bind`绑定特性就可以了，简写就是`:title`，这样就可以向子组件中传递一个名为title的变量。\n\n``` html\n<div>{{title}}</div>\n```\n``` javascript\nexport default {\n  props: {\n    'title': String\n  }\n}\n```\n\n那么在子组件中通过`props`声明可被接受的数据就可以在子组件中使用了，如上就是在子组件中接收一个类型为字符串的变量，如果不需要校验类型那么直接可以以数组的方式接收。\n\n``` javascript\nexport default {\n  props: ['title']\n}\n```\n如果变量还有声明默认值还有第三种写法：\n\n``` javascript\nexport default {\n  props: {\n    title:{\n      type: String,\n      default: 'hello' \n    }\n  }\n}\n```\n#### 子向父发送事件\n既然获取数据已经实现了，那么如何在子组件中向父组件发送事件呢，只需通过`emit`和`on`就可以实现了。\n\n``` javascript\n//子组件\nthis.$emit('getId',this.id) \n```\n``` html\n// 父组件\n<addScale :title=\"title\" v-on:getId=\"getId(id)\"></addScale>\n```\n以上，子组件通过emit发送了一个名为getId的事件，并且传递了一个id作为参数，在父组件中我们使用`v-on`（也可用`@getId`）来监听这个事件以实现我们想要的功能。\n#### 好用的ref\n有些时候我们也会有需要在父组件中调用子组件的方法或数据，这个时候`ref`的优势便体现出来了：\n\n``` html\n//父组件\n<addGoods ref=\"goodItem\"></addGoods>\n```\n``` javascript\nthis.$refs['goodItem'].resetSearch()\n```\n当在组件上使用`ref`特性时，`ref`便指向了这个组件的实例,可以通过这种方法调用子组件上的`resetSearch`方法，当然也可以使用组件实例中的数据。\n而当`ref`用在普通的DOM元素上时便是指向这个DOM，可以利用它完成一些DOM操作。\n\n#### $parent\n`$parent`可以让子组件调用到父组件的方法,`$root`指向根节点。\n### 2、非父子组件通信\n\n非父子组件通信的核心是拉来一个第三方做中间人，事件的发送和监听都绑定在这个第三方实例上，我们称之为eventbus。使用方法有两种，一种是新建一个bus.js里面new一个Vue实例，在需要使用的组件中引用。\n\n``` javascript\n//bus.js\nimport Vue from 'vue'\nexport default new Vue\n```\n``` html\n//组件A\n<template>\n  <div id=\"componentA\">\n    <button @click=\"send\">按钮</button>\n  </div>\n</template> \n\nimport Bus from './bus.js' \nexport default { \n  data() {\n    return {\n      message: 'how are you?'\n    }\n  },\n　methods: {\n    send () {\n      Bus.$emit('msg', this.message)\n    }\n  }\n}\n```\n``` javascript\n//组件B\nimport Bus from './bus.js'\nexport default {\n  data() {\n    return {\n    \tmessage:  ''\n    }\n  },\n  mounted() {\n    Bus.$on('msg', (e) => {\n　　　console.log(`有人向你打招呼：${e}`)\n    })\n  }\n}\n```\n这样两个组件都通过中间人Bus来获取和发送事件，便可以实现两个组件间的通信了。\n\n还有一种方法是将eventbus放在vue的根实例下：\n\n``` javascript\nnew Vue({\n  el: '#app',\n  router,\n  render: h => h(App),\n  data: {\n    // 空的实例放到根组件下，所有的子组件都能调用\n    Bus: new Vue()\n  }\n})\n```\n``` html\n//组件A\n<template>\n  <div id=\"componentA\">\n    <button @click=\"send\">按钮</button>\n  </div>\n</template> \n\nexport default { \n  data() {\n    return {\n      message: 'how are you?'\n    }\n  },\n　methods: {\n    send () {\n      this.$root.Bus.$emit('msg', this.message)\n    }\n  }\n}\n```\n这样通过`this.$root.Bus`去调用eventbus可以不用单独再引入bus.js，所有在根实例下的组件都可以调用。\n\n以上的方法在逻辑简单的组件通信中使用是很方便的，当数据量大逻辑复杂的时候，就可以考虑使用vuex进行状态管理了，关于vuex的相关使用我会找时间单独写一篇博客。","slug":"VUE使用小结——组件通信篇","published":1,"updated":"2018-11-16T15:30:15.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06sf0000xl69l5xs4ghg","content":"<p>vue作为当下最火的框架之一，上手快社区活跃文档清晰各类插件繁多的特点让其在大量前端团队中备受青睐。</p>\n<p>从16年中开始使用vue1.0到逐渐过渡到现在的2.0，两年的时间里vue一直是我团队中主要的前端框架，但在过往的项目中仅仅只是大量的利用了vue单页应用、路由、双向数据绑定以及数据驱动视图的特点，没有最大化的运用vue的功能，想来也是可惜。</p>\n<p>时过境迁，公司目前项目的业务特点再加上有前人的技术沉淀，对于vue的开发使用比以往丰富了很多，自身也有意的想更多的去发掘vue的用法，在使用学习的过程中，不断有新的收获，累积总结于此，便开启了vue系列的第一篇。</p>\n<h2 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h2><p>当项目中的某一部分功能经常会被复用时，每次都写一段一样的代码显然并不妥当，为了方便我们可以把这部分代码封装成一个组件，当有需要用到的时候直接引用这个组件就好了。那么如何在调用组件的时候向其传入数据以及组件中的行为如何影响到调用他的父组件，简而言之，组件之间的通信是我们需要解决的问题。而组件通信分为父子组件通信和非父子组件通信。</p>\n<h3 id=\"1、父子组件通信\"><a href=\"#1、父子组件通信\" class=\"headerlink\" title=\"1、父子组件通信\"></a>1、父子组件通信</h3><h4 id=\"父向子传值\"><a href=\"#父向子传值\" class=\"headerlink\" title=\"父向子传值\"></a>父向子传值</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">addScale</span> <span class=\"attr\">:title</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">addScale</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>向子组件传值的方式很简单，只要通过<code>v-bind</code>绑定特性就可以了，简写就是<code>:title</code>，这样就可以向子组件中传递一个名为title的变量。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    <span class=\"string\">'title'</span>: <span class=\"built_in\">String</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在子组件中通过<code>props</code>声明可被接受的数据就可以在子组件中使用了，如上就是在子组件中接收一个类型为字符串的变量，如果不需要校验类型那么直接可以以数组的方式接收。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'title'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果变量还有声明默认值还有第三种写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title:&#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'hello'</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子向父发送事件\"><a href=\"#子向父发送事件\" class=\"headerlink\" title=\"子向父发送事件\"></a>子向父发送事件</h4><p>既然获取数据已经实现了，那么如何在子组件中向父组件发送事件呢，只需通过<code>emit</code>和<code>on</code>就可以实现了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getId'</span>,<span class=\"keyword\">this</span>.id)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">addScale</span> <span class=\"attr\">:title</span>=<span class=\"string\">\"title\"</span> <span class=\"attr\">v-on:getId</span>=<span class=\"string\">\"getId(id)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">addScale</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上，子组件通过emit发送了一个名为getId的事件，并且传递了一个id作为参数，在父组件中我们使用<code>v-on</code>（也可用<code>@getId</code>）来监听这个事件以实现我们想要的功能。</p>\n<h4 id=\"好用的ref\"><a href=\"#好用的ref\" class=\"headerlink\" title=\"好用的ref\"></a>好用的ref</h4><p>有些时候我们也会有需要在父组件中调用子组件的方法或数据，这个时候<code>ref</code>的优势便体现出来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">addGoods</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"goodItem\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">addGoods</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.$refs[<span class=\"string\">'goodItem'</span>].resetSearch()</span><br></pre></td></tr></table></figure>\n<p>当在组件上使用<code>ref</code>特性时，<code>ref</code>便指向了这个组件的实例,可以通过这种方法调用子组件上的<code>resetSearch</code>方法，当然也可以使用组件实例中的数据。<br>而当<code>ref</code>用在普通的DOM元素上时便是指向这个DOM，可以利用它完成一些DOM操作。</p>\n<h4 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"$parent\"></a>$parent</h4><p><code>$parent</code>可以让子组件调用到父组件的方法,<code>$root</code>指向根节点。</p>\n<h3 id=\"2、非父子组件通信\"><a href=\"#2、非父子组件通信\" class=\"headerlink\" title=\"2、非父子组件通信\"></a>2、非父子组件通信</h3><p>非父子组件通信的核心是拉来一个第三方做中间人，事件的发送和监听都绑定在这个第三方实例上，我们称之为eventbus。使用方法有两种，一种是新建一个bus.js里面new一个Vue实例，在需要使用的组件中引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//bus.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//组件A</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"componentA\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"send\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">import Bus from './bus.js' </span><br><span class=\"line\">export default &#123; </span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message: 'how are you?'</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">　methods: &#123;</span><br><span class=\"line\">    send () &#123;</span><br><span class=\"line\">      Bus.$emit('msg', this.message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//组件B</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Bus <span class=\"keyword\">from</span> <span class=\"string\">'./bus.js'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    \tmessage:  <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    Bus.$on(<span class=\"string\">'msg'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">　　　<span class=\"built_in\">console</span>.log(<span class=\"string\">`有人向你打招呼：<span class=\"subst\">$&#123;e&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样两个组件都通过中间人Bus来获取和发送事件，便可以实现两个组件间的通信了。</p>\n<p>还有一种方法是将eventbus放在vue的根实例下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App),</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空的实例放到根组件下，所有的子组件都能调用</span></span><br><span class=\"line\">    Bus: <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//组件A</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"componentA\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"send\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123; </span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message: 'how are you?'</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">　methods: &#123;</span><br><span class=\"line\">    send () &#123;</span><br><span class=\"line\">      this.$root.Bus.$emit('msg', this.message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样通过<code>this.$root.Bus</code>去调用eventbus可以不用单独再引入bus.js，所有在根实例下的组件都可以调用。</p>\n<p>以上的方法在逻辑简单的组件通信中使用是很方便的，当数据量大逻辑复杂的时候，就可以考虑使用vuex进行状态管理了，关于vuex的相关使用我会找时间单独写一篇博客。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>vue作为当下最火的框架之一，上手快社区活跃文档清晰各类插件繁多的特点让其在大量前端团队中备受青睐。</p>\n<p>从16年中开始使用vue1.0到逐渐过渡到现在的2.0，两年的时间里vue一直是我团队中主要的前端框架，但在过往的项目中仅仅只是大量的利用了vue单页应用、路由、双向数据绑定以及数据驱动视图的特点，没有最大化的运用vue的功能，想来也是可惜。</p>\n<p>时过境迁，公司目前项目的业务特点再加上有前人的技术沉淀，对于vue的开发使用比以往丰富了很多，自身也有意的想更多的去发掘vue的用法，在使用学习的过程中，不断有新的收获，累积总结于此，便开启了vue系列的第一篇。</p>\n<h2 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h2><p>当项目中的某一部分功能经常会被复用时，每次都写一段一样的代码显然并不妥当，为了方便我们可以把这部分代码封装成一个组件，当有需要用到的时候直接引用这个组件就好了。那么如何在调用组件的时候向其传入数据以及组件中的行为如何影响到调用他的父组件，简而言之，组件之间的通信是我们需要解决的问题。而组件通信分为父子组件通信和非父子组件通信。</p>\n<h3 id=\"1、父子组件通信\"><a href=\"#1、父子组件通信\" class=\"headerlink\" title=\"1、父子组件通信\"></a>1、父子组件通信</h3><h4 id=\"父向子传值\"><a href=\"#父向子传值\" class=\"headerlink\" title=\"父向子传值\"></a>父向子传值</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">addScale</span> <span class=\"attr\">:title</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">addScale</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>向子组件传值的方式很简单，只要通过<code>v-bind</code>绑定特性就可以了，简写就是<code>:title</code>，这样就可以向子组件中传递一个名为title的变量。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    <span class=\"string\">'title'</span>: <span class=\"built_in\">String</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在子组件中通过<code>props</code>声明可被接受的数据就可以在子组件中使用了，如上就是在子组件中接收一个类型为字符串的变量，如果不需要校验类型那么直接可以以数组的方式接收。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'title'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果变量还有声明默认值还有第三种写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title:&#123;</span><br><span class=\"line\">      type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">      <span class=\"keyword\">default</span>: <span class=\"string\">'hello'</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子向父发送事件\"><a href=\"#子向父发送事件\" class=\"headerlink\" title=\"子向父发送事件\"></a>子向父发送事件</h4><p>既然获取数据已经实现了，那么如何在子组件中向父组件发送事件呢，只需通过<code>emit</code>和<code>on</code>就可以实现了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getId'</span>,<span class=\"keyword\">this</span>.id)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">addScale</span> <span class=\"attr\">:title</span>=<span class=\"string\">\"title\"</span> <span class=\"attr\">v-on:getId</span>=<span class=\"string\">\"getId(id)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">addScale</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上，子组件通过emit发送了一个名为getId的事件，并且传递了一个id作为参数，在父组件中我们使用<code>v-on</code>（也可用<code>@getId</code>）来监听这个事件以实现我们想要的功能。</p>\n<h4 id=\"好用的ref\"><a href=\"#好用的ref\" class=\"headerlink\" title=\"好用的ref\"></a>好用的ref</h4><p>有些时候我们也会有需要在父组件中调用子组件的方法或数据，这个时候<code>ref</code>的优势便体现出来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">addGoods</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"goodItem\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">addGoods</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.$refs[<span class=\"string\">'goodItem'</span>].resetSearch()</span><br></pre></td></tr></table></figure>\n<p>当在组件上使用<code>ref</code>特性时，<code>ref</code>便指向了这个组件的实例,可以通过这种方法调用子组件上的<code>resetSearch</code>方法，当然也可以使用组件实例中的数据。<br>而当<code>ref</code>用在普通的DOM元素上时便是指向这个DOM，可以利用它完成一些DOM操作。</p>\n<h4 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"$parent\"></a>$parent</h4><p><code>$parent</code>可以让子组件调用到父组件的方法,<code>$root</code>指向根节点。</p>\n<h3 id=\"2、非父子组件通信\"><a href=\"#2、非父子组件通信\" class=\"headerlink\" title=\"2、非父子组件通信\"></a>2、非父子组件通信</h3><p>非父子组件通信的核心是拉来一个第三方做中间人，事件的发送和监听都绑定在这个第三方实例上，我们称之为eventbus。使用方法有两种，一种是新建一个bus.js里面new一个Vue实例，在需要使用的组件中引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//bus.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vue</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//组件A</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"componentA\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"send\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">import Bus from './bus.js' </span><br><span class=\"line\">export default &#123; </span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message: 'how are you?'</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">　methods: &#123;</span><br><span class=\"line\">    send () &#123;</span><br><span class=\"line\">      Bus.$emit('msg', this.message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//组件B</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Bus <span class=\"keyword\">from</span> <span class=\"string\">'./bus.js'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    \tmessage:  <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    Bus.$on(<span class=\"string\">'msg'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">　　　<span class=\"built_in\">console</span>.log(<span class=\"string\">`有人向你打招呼：<span class=\"subst\">$&#123;e&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样两个组件都通过中间人Bus来获取和发送事件，便可以实现两个组件间的通信了。</p>\n<p>还有一种方法是将eventbus放在vue的根实例下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App),</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空的实例放到根组件下，所有的子组件都能调用</span></span><br><span class=\"line\">    Bus: <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//组件A</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"componentA\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"send\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123; </span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message: 'how are you?'</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">　methods: &#123;</span><br><span class=\"line\">    send () &#123;</span><br><span class=\"line\">      this.$root.Bus.$emit('msg', this.message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样通过<code>this.$root.Bus</code>去调用eventbus可以不用单独再引入bus.js，所有在根实例下的组件都可以调用。</p>\n<p>以上的方法在逻辑简单的组件通信中使用是很方便的，当数据量大逻辑复杂的时候，就可以考虑使用vuex进行状态管理了，关于vuex的相关使用我会找时间单独写一篇博客。</p>\n"},{"title":"JS单线程与异步","date":"2018-09-05T13:09:09.000Z","urlname":"javascript-singlethread-asynchronous","toc":true,"_content":"\n### 单线程的JS\n\n作为JavaScript的核心特性，单线程决定了其同一时间只能做一件事，所有任务排队等候执行，前一个结束后一个才可以执行。但是当遇到http请求这类比较耗时的任务时，如果持续等待结果将会阻塞整个队列的快速执行，甚至造成浏览器停止响应。举个例子：傍晚时候，我给老王发了条微信，老铁周末去打球吗，老王不一定秒回，如果我一直抱着手机等待老王的回复，那不知道我什么时候可以去吃晚饭，也许刚巧老王前一天通宵到下午才回到家此时正在呼呼大睡，于是在饥肠辘辘的等待中，博主卒。但是如果我发好了微信就去吃饭，什么时候老王回我了再去订球馆就会避免这种情况的出现。好在作为JS宿主环境的浏览器并不是单线程的。\n\n### 多线程的浏览器\n\n浏览器只会给JS分配一个主线程来执行任务，但是浏览器却为那些耗时的任务单独开辟了其他线程，比如：浏览器事件触发线程 、http请求线程 、定时器触发线程 ······当主线程执行到这类耗时任务时便会暂时将它们挂起，继续向下执行后面的任务，等到挂起的任务执行完成后再回过头来进入到主线程继续执行。\n\n### “现在”与“将来”\n\n如此一来，任务被分成了两种，一种是`同步任务`，一种是`异步任务`，同步任务在主线程上执行，主线程之外存在一个`任务队列`，当异步任务有了执行结果就在任务队列当中放置一个事件，等待主线程上的同步任务全部执行完成后便会进入主线程中执行。异步任务都有一个或多个回调函数，当任务队列中的事件被主线程读取时便会执行这个回调函数。在**《你不知道的JavaScript（中卷）》**一书中，作者将其称为“现在”与“将来”。\n\n### 回调函数  \n\n> 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n可见，回调函数的执行时机要依情况而定。前面说了，异步任务都有一个或多个回调函数，但回调不代表一定是异步操作。比如：\n\n```javascript\nfunction f1(callback){\n    console.log(1)\n    callback()\n}\nfunction f2(){\n    console.log(2)\n}\nf1(f2)\n```\n\n这其实是一个同步的回调，因为没有任务发生在“将来”。\n\n而假如f1是一个ajax请求，f2的执行需要依赖于f1返回的数据：\n\n```javascript\nfunction f1(callback){\n    // 这里使用setTimeout来模拟ajax请求的耗时过程\n    setTimeout(function () {\n        // f1的任务代码\n        callback()\n    }, 1000)\n}\nfunction f2(){\n    console.log(2)\n}\nf1(f2)\n```\n\n这就变成了一个异步的回调，因为回调的执行发生在“将来”。\n\n回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱。当回调不断嵌套，便会形成人们熟知的`回调地狱`。\n\n例如：\n\n```javascript\nlisten(\"click\",function handler(evt) {\n    setTimeout(function request() {\n        ajax(\"http://some.url.1\",\n            function response(text) {\n                if (text == \"hello\") {\n                    handler();\n                } else if (text == \"world\") {\n                    request();\n                }\n            });\n        },\n    500);\n});\n```\n\n\n\n### 事件循环（Event Loop）\n\n介绍完回调函数我们再回过头来看看主线程提取任务队列事件执行的机制。\n\n这里引用一张经典的图示来说明这个过程。\n\n![eventloop](https://s1.ax1x.com/2018/10/15/iaMWCR.png)\n\n`stack`代表主线程中执行的同步任务，`WebAPIs`代表浏览器执行异步任务的线程，当异步任务有结果时便会在`callback queue`（也就是上面提到的`任务队列`）中放置一个事件，这个事件并不能立即执行，而是要等主线程上的任务全部结束，`stack`中的任务每执行完一个便会出栈直至栈空。`stack`在忙活了一阵终于把自己手头的工作做完了，然而它并不能马上休息，要先去看任务队列中是否有事件等待，如果有便要去任务队列中提取事件进入自己内部执行，任务队列中的事件遵循先进先出原则。每一次事件循环称为tick，整个过程不断循环，我们将这种运行机制称为`Event Loop（事件循环）`。\n\n有了对于事件循环的理解，我们来看两个出镜率很高的面试题：\n\n1、\n\n```javascript\nsetTimeout(function(){\n    console.log(1)\n},0)\nconsole.log(2)\n```\n\n`setTimeout`是浏览器window对象的方法，表示延迟执行一个事件，可以接受两个参数，第一个是一个回调方法，第二个是执行代码前需等待的毫秒数。这是一个非常常用的异步方法。\n\n这个例子我们一看，哎呦，第二个参数是0，太好了不用等马上可以执行。于是快速的得出结果：`1 2`。\n\n可`setTimeout`是一个异步任务，当主线程执行到它时会把它交到浏览器单独为其提供的线程中去然后继续向下运行。虽然等待时间为0也只是意味着回调函数可以马上进入到任务队列中等待，直到主线程任务全部结束再通过事件循环机制读取任务队列执行事件。所以正确结果应该是`2 1`。\n\n2、\n\n```javascript\nfor(var i=0;i<5;i++){\n    setTimeout(function(){\n        console.log(i)\n    },1000)\n}\n```\n\n这段代码初学者通常会给出`0 1 2 3 4`的回答，但其实`for`循环中`i`的累加过程是同步的，循环体中的打印是异步的，并且`i`是全局变量，当同步任务执行完的时候运行环境中变量`i`的值已经变成了`5`，这个时候再执行定时器回调函数将会连续打印出`5 5 5 5 5 `。\n\n值得注意的是，**HTML5标准规定了setTimeout()的第二个参数的最小值不得低于4毫秒**，因此即使设置了0，也要至少等待4毫秒，而且还要看同步任务是否全部结束以及当前事件是否排在任务队列的第一个，因此这个等待时间并不一定准确。\n\n### Promise\n\n前面说了使用回调来表达程序异步会造成流程混乱，也不利于代码的阅读和维护，如果能让这一过程更加简洁清晰一些就好了。值得开发者们欣喜的是，ES6为我们提供了一个名为`Promise`的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。话不多说，我们先来看`Promise`是怎么使用的：\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n    // ... some code\n    if(/* 异步操作成功 */){\n        resolve(value)\n    }else{\n        reject(error)\n    }\n})\npromise.then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n`Promise`是一个对象，有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n`Promise`对象是一个构造函数，用来生成`Promise`实例，接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。当异步操作成功或者失败时，`resolve`和`reject`会作为参数传递出去。\n\n`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数，`rejected`非必传。\n\n回到上面那段代码，当我们在`Promise`对象中执行一个异步操作时并不需要在内部处理成功或失败的结果，而是把这个状态抛出来在外面链式地进行处理。也就是`Promise`内部不关心如何处理结果，只在完成的将来处理。这样就把执行代码和处理结果的代码清晰地分离了。\n\n而当我们再一次面对多个存在依赖关系执行的异步任务时，也不需要像以往一样横向编程，层层嵌套形成一个`回调地狱`。`Promise`允许我们进行链式编程：\n\n```javascript\nfunction ajax(url, data) {\n    let request = new XMLHttpRequest();\n    return new Promise(function (resolve, reject) {\n        request.onreadystatechange = function () {\n            if (request.readyState === 4) {\n                if (request.status === 200) {\n                    resolve(request.responseText);\n                } else {\n                    reject(request.status);\n                }\n            }\n        };\n        request.open(\"GET\", url);\n        request.send(data);\n    });\n}\najax(\"http://...\").then(function(req) {\n    return ajax(res.url)\n}).then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n使用链式的`then` 指定一组按照次序调用的回调函数。前一个回调函数，返回的还是一个`Promise`对象，这时后一个回调函数就会等待该`Promise`对象的状态发生变化，才会被调用。这样既保证了任务的有序性，逻辑也更清晰了呢。\n\n`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。因此\n\n```javascript\najax(\"http://...\").then(function(req) {\n    return ajax(res.url)\n}).then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n// 也可写成\najax(\"http://...\").then(function(req) {\n    return ajax(res.url)\n}).then(function(value) {\n    // success\n}).catch(function(error) {\n    // failure\n})\n```\n\n### 新的事件循环\n\n`Promise` 不仅使得异步任务实现方式的定义更加良好，对顺序的保证性更强，也尽可能早的将任务队列中事件的执行提前了。\n\n由此我们需要对前面讲过的任务进行更进一步细化的分类：\n\n> macro-task(宏任务)：包括整体代码script，setTimeout，setInterval\n>\n> micro-task(微任务)：Promise，process.nextTick\n\n微任务可以理解为是挂在事件循环的每个 tick 之后的一个队列。在事件循环的每个 tick 中，微任务产生的回调不会被添加到任务队列中等待下一轮tick读取，而会进入当前 tick 的主线程末尾，相当于插队。\n\n```javascript\nsetTimeout(function() {\n    console.log('setTimeout');\n},0)\n\nnew Promise(function(resolve) {\n    console.log('promise')\n    resolve()\n}).then(function() {\n    console.log('then') // 插到console.log('console')后面\n})\n\nconsole.log('console')\n```\n\n因此上面这段代码的结果是\n\n```javascript\n// promise\n// console\n// then\n// setTimeout\n```\n\n### 结语\n\n在开始动笔写这篇博客前，我参阅了几篇有关这部分内容的博客，更是反复阅读了阮一峰老师的*[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)*以及*[Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)*，但在这过程中其实对文章中的一些解读和概念并不能很好的理解，甚至于感觉有些内容存在矛盾，比如对于异步编程方法中回调函数的举例描述以及事件循环主线程和任务队列关系的语义相反的关系描述，这也引起了我极大的求知欲，不停查找资料以求找到更加准确的定义。也在找寻答案的路途中发现很多有关异步的博客都是几乎照搬阮一峰的博客，并没有引入自己的见解和解读，想说写博客的目的既是一个学习过程的记录，同时也是一个发现并解决问题的契机，与其照搬不如直接加个（转）。希望可以和大家共勉，如果发现我的文章内容描述有偏颇也欢迎一起讨论学习。\n\n*部分内容参考自以下：*\n[https://www.cnblogs.com/woodyblog/p/6061671.html](https://www.cnblogs.com/woodyblog/p/6061671.html)\n[https://blog.csdn.net/jssy_csu/article/details/78627628](https://blog.csdn.net/jssy_csu/article/details/78627628)\n[http://www.ruanyifeng.com/blog/2014/10/event-loop.html](http://www.ruanyifeng.com/blog/2014/10/event-loop.html) \n[http://es6.ruanyifeng.com/#docs/promise](http://es6.ruanyifeng.com/#docs/promise)\n《你不知道的JavaScript（中卷）》\n\n\n\n\n\n","source":"_posts/JS单线程与异步.md","raw":"---\ntitle: JS单线程与异步\ndate: 2018-09-05 21:09:09\nurlname: javascript-singlethread-asynchronous\ncategories: [\"技术\"]\ntags: [\"JS\"]\ntoc: true\n---\n\n### 单线程的JS\n\n作为JavaScript的核心特性，单线程决定了其同一时间只能做一件事，所有任务排队等候执行，前一个结束后一个才可以执行。但是当遇到http请求这类比较耗时的任务时，如果持续等待结果将会阻塞整个队列的快速执行，甚至造成浏览器停止响应。举个例子：傍晚时候，我给老王发了条微信，老铁周末去打球吗，老王不一定秒回，如果我一直抱着手机等待老王的回复，那不知道我什么时候可以去吃晚饭，也许刚巧老王前一天通宵到下午才回到家此时正在呼呼大睡，于是在饥肠辘辘的等待中，博主卒。但是如果我发好了微信就去吃饭，什么时候老王回我了再去订球馆就会避免这种情况的出现。好在作为JS宿主环境的浏览器并不是单线程的。\n\n### 多线程的浏览器\n\n浏览器只会给JS分配一个主线程来执行任务，但是浏览器却为那些耗时的任务单独开辟了其他线程，比如：浏览器事件触发线程 、http请求线程 、定时器触发线程 ······当主线程执行到这类耗时任务时便会暂时将它们挂起，继续向下执行后面的任务，等到挂起的任务执行完成后再回过头来进入到主线程继续执行。\n\n### “现在”与“将来”\n\n如此一来，任务被分成了两种，一种是`同步任务`，一种是`异步任务`，同步任务在主线程上执行，主线程之外存在一个`任务队列`，当异步任务有了执行结果就在任务队列当中放置一个事件，等待主线程上的同步任务全部执行完成后便会进入主线程中执行。异步任务都有一个或多个回调函数，当任务队列中的事件被主线程读取时便会执行这个回调函数。在**《你不知道的JavaScript（中卷）》**一书中，作者将其称为“现在”与“将来”。\n\n### 回调函数  \n\n> 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n可见，回调函数的执行时机要依情况而定。前面说了，异步任务都有一个或多个回调函数，但回调不代表一定是异步操作。比如：\n\n```javascript\nfunction f1(callback){\n    console.log(1)\n    callback()\n}\nfunction f2(){\n    console.log(2)\n}\nf1(f2)\n```\n\n这其实是一个同步的回调，因为没有任务发生在“将来”。\n\n而假如f1是一个ajax请求，f2的执行需要依赖于f1返回的数据：\n\n```javascript\nfunction f1(callback){\n    // 这里使用setTimeout来模拟ajax请求的耗时过程\n    setTimeout(function () {\n        // f1的任务代码\n        callback()\n    }, 1000)\n}\nfunction f2(){\n    console.log(2)\n}\nf1(f2)\n```\n\n这就变成了一个异步的回调，因为回调的执行发生在“将来”。\n\n回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱。当回调不断嵌套，便会形成人们熟知的`回调地狱`。\n\n例如：\n\n```javascript\nlisten(\"click\",function handler(evt) {\n    setTimeout(function request() {\n        ajax(\"http://some.url.1\",\n            function response(text) {\n                if (text == \"hello\") {\n                    handler();\n                } else if (text == \"world\") {\n                    request();\n                }\n            });\n        },\n    500);\n});\n```\n\n\n\n### 事件循环（Event Loop）\n\n介绍完回调函数我们再回过头来看看主线程提取任务队列事件执行的机制。\n\n这里引用一张经典的图示来说明这个过程。\n\n![eventloop](https://s1.ax1x.com/2018/10/15/iaMWCR.png)\n\n`stack`代表主线程中执行的同步任务，`WebAPIs`代表浏览器执行异步任务的线程，当异步任务有结果时便会在`callback queue`（也就是上面提到的`任务队列`）中放置一个事件，这个事件并不能立即执行，而是要等主线程上的任务全部结束，`stack`中的任务每执行完一个便会出栈直至栈空。`stack`在忙活了一阵终于把自己手头的工作做完了，然而它并不能马上休息，要先去看任务队列中是否有事件等待，如果有便要去任务队列中提取事件进入自己内部执行，任务队列中的事件遵循先进先出原则。每一次事件循环称为tick，整个过程不断循环，我们将这种运行机制称为`Event Loop（事件循环）`。\n\n有了对于事件循环的理解，我们来看两个出镜率很高的面试题：\n\n1、\n\n```javascript\nsetTimeout(function(){\n    console.log(1)\n},0)\nconsole.log(2)\n```\n\n`setTimeout`是浏览器window对象的方法，表示延迟执行一个事件，可以接受两个参数，第一个是一个回调方法，第二个是执行代码前需等待的毫秒数。这是一个非常常用的异步方法。\n\n这个例子我们一看，哎呦，第二个参数是0，太好了不用等马上可以执行。于是快速的得出结果：`1 2`。\n\n可`setTimeout`是一个异步任务，当主线程执行到它时会把它交到浏览器单独为其提供的线程中去然后继续向下运行。虽然等待时间为0也只是意味着回调函数可以马上进入到任务队列中等待，直到主线程任务全部结束再通过事件循环机制读取任务队列执行事件。所以正确结果应该是`2 1`。\n\n2、\n\n```javascript\nfor(var i=0;i<5;i++){\n    setTimeout(function(){\n        console.log(i)\n    },1000)\n}\n```\n\n这段代码初学者通常会给出`0 1 2 3 4`的回答，但其实`for`循环中`i`的累加过程是同步的，循环体中的打印是异步的，并且`i`是全局变量，当同步任务执行完的时候运行环境中变量`i`的值已经变成了`5`，这个时候再执行定时器回调函数将会连续打印出`5 5 5 5 5 `。\n\n值得注意的是，**HTML5标准规定了setTimeout()的第二个参数的最小值不得低于4毫秒**，因此即使设置了0，也要至少等待4毫秒，而且还要看同步任务是否全部结束以及当前事件是否排在任务队列的第一个，因此这个等待时间并不一定准确。\n\n### Promise\n\n前面说了使用回调来表达程序异步会造成流程混乱，也不利于代码的阅读和维护，如果能让这一过程更加简洁清晰一些就好了。值得开发者们欣喜的是，ES6为我们提供了一个名为`Promise`的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。话不多说，我们先来看`Promise`是怎么使用的：\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n    // ... some code\n    if(/* 异步操作成功 */){\n        resolve(value)\n    }else{\n        reject(error)\n    }\n})\npromise.then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n`Promise`是一个对象，有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n`Promise`对象是一个构造函数，用来生成`Promise`实例，接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。当异步操作成功或者失败时，`resolve`和`reject`会作为参数传递出去。\n\n`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数，`rejected`非必传。\n\n回到上面那段代码，当我们在`Promise`对象中执行一个异步操作时并不需要在内部处理成功或失败的结果，而是把这个状态抛出来在外面链式地进行处理。也就是`Promise`内部不关心如何处理结果，只在完成的将来处理。这样就把执行代码和处理结果的代码清晰地分离了。\n\n而当我们再一次面对多个存在依赖关系执行的异步任务时，也不需要像以往一样横向编程，层层嵌套形成一个`回调地狱`。`Promise`允许我们进行链式编程：\n\n```javascript\nfunction ajax(url, data) {\n    let request = new XMLHttpRequest();\n    return new Promise(function (resolve, reject) {\n        request.onreadystatechange = function () {\n            if (request.readyState === 4) {\n                if (request.status === 200) {\n                    resolve(request.responseText);\n                } else {\n                    reject(request.status);\n                }\n            }\n        };\n        request.open(\"GET\", url);\n        request.send(data);\n    });\n}\najax(\"http://...\").then(function(req) {\n    return ajax(res.url)\n}).then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n使用链式的`then` 指定一组按照次序调用的回调函数。前一个回调函数，返回的还是一个`Promise`对象，这时后一个回调函数就会等待该`Promise`对象的状态发生变化，才会被调用。这样既保证了任务的有序性，逻辑也更清晰了呢。\n\n`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。因此\n\n```javascript\najax(\"http://...\").then(function(req) {\n    return ajax(res.url)\n}).then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n// 也可写成\najax(\"http://...\").then(function(req) {\n    return ajax(res.url)\n}).then(function(value) {\n    // success\n}).catch(function(error) {\n    // failure\n})\n```\n\n### 新的事件循环\n\n`Promise` 不仅使得异步任务实现方式的定义更加良好，对顺序的保证性更强，也尽可能早的将任务队列中事件的执行提前了。\n\n由此我们需要对前面讲过的任务进行更进一步细化的分类：\n\n> macro-task(宏任务)：包括整体代码script，setTimeout，setInterval\n>\n> micro-task(微任务)：Promise，process.nextTick\n\n微任务可以理解为是挂在事件循环的每个 tick 之后的一个队列。在事件循环的每个 tick 中，微任务产生的回调不会被添加到任务队列中等待下一轮tick读取，而会进入当前 tick 的主线程末尾，相当于插队。\n\n```javascript\nsetTimeout(function() {\n    console.log('setTimeout');\n},0)\n\nnew Promise(function(resolve) {\n    console.log('promise')\n    resolve()\n}).then(function() {\n    console.log('then') // 插到console.log('console')后面\n})\n\nconsole.log('console')\n```\n\n因此上面这段代码的结果是\n\n```javascript\n// promise\n// console\n// then\n// setTimeout\n```\n\n### 结语\n\n在开始动笔写这篇博客前，我参阅了几篇有关这部分内容的博客，更是反复阅读了阮一峰老师的*[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)*以及*[Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)*，但在这过程中其实对文章中的一些解读和概念并不能很好的理解，甚至于感觉有些内容存在矛盾，比如对于异步编程方法中回调函数的举例描述以及事件循环主线程和任务队列关系的语义相反的关系描述，这也引起了我极大的求知欲，不停查找资料以求找到更加准确的定义。也在找寻答案的路途中发现很多有关异步的博客都是几乎照搬阮一峰的博客，并没有引入自己的见解和解读，想说写博客的目的既是一个学习过程的记录，同时也是一个发现并解决问题的契机，与其照搬不如直接加个（转）。希望可以和大家共勉，如果发现我的文章内容描述有偏颇也欢迎一起讨论学习。\n\n*部分内容参考自以下：*\n[https://www.cnblogs.com/woodyblog/p/6061671.html](https://www.cnblogs.com/woodyblog/p/6061671.html)\n[https://blog.csdn.net/jssy_csu/article/details/78627628](https://blog.csdn.net/jssy_csu/article/details/78627628)\n[http://www.ruanyifeng.com/blog/2014/10/event-loop.html](http://www.ruanyifeng.com/blog/2014/10/event-loop.html) \n[http://es6.ruanyifeng.com/#docs/promise](http://es6.ruanyifeng.com/#docs/promise)\n《你不知道的JavaScript（中卷）》\n\n\n\n\n\n","slug":"JS单线程与异步","published":1,"updated":"2018-11-16T15:30:15.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06sn0001xl69yb03cbyy","content":"<h3 id=\"单线程的JS\"><a href=\"#单线程的JS\" class=\"headerlink\" title=\"单线程的JS\"></a>单线程的JS</h3><p>作为JavaScript的核心特性，单线程决定了其同一时间只能做一件事，所有任务排队等候执行，前一个结束后一个才可以执行。但是当遇到http请求这类比较耗时的任务时，如果持续等待结果将会阻塞整个队列的快速执行，甚至造成浏览器停止响应。举个例子：傍晚时候，我给老王发了条微信，老铁周末去打球吗，老王不一定秒回，如果我一直抱着手机等待老王的回复，那不知道我什么时候可以去吃晚饭，也许刚巧老王前一天通宵到下午才回到家此时正在呼呼大睡，于是在饥肠辘辘的等待中，博主卒。但是如果我发好了微信就去吃饭，什么时候老王回我了再去订球馆就会避免这种情况的出现。好在作为JS宿主环境的浏览器并不是单线程的。</p>\n<h3 id=\"多线程的浏览器\"><a href=\"#多线程的浏览器\" class=\"headerlink\" title=\"多线程的浏览器\"></a>多线程的浏览器</h3><p>浏览器只会给JS分配一个主线程来执行任务，但是浏览器却为那些耗时的任务单独开辟了其他线程，比如：浏览器事件触发线程 、http请求线程 、定时器触发线程 ······当主线程执行到这类耗时任务时便会暂时将它们挂起，继续向下执行后面的任务，等到挂起的任务执行完成后再回过头来进入到主线程继续执行。</p>\n<h3 id=\"“现在”与“将来”\"><a href=\"#“现在”与“将来”\" class=\"headerlink\" title=\"“现在”与“将来”\"></a>“现在”与“将来”</h3><p>如此一来，任务被分成了两种，一种是<code>同步任务</code>，一种是<code>异步任务</code>，同步任务在主线程上执行，主线程之外存在一个<code>任务队列</code>，当异步任务有了执行结果就在任务队列当中放置一个事件，等待主线程上的同步任务全部执行完成后便会进入主线程中执行。异步任务都有一个或多个回调函数，当任务队列中的事件被主线程读取时便会执行这个回调函数。在<strong>《你不知道的JavaScript（中卷）》</strong>一书中，作者将其称为“现在”与“将来”。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><blockquote>\n<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>\n</blockquote>\n<p>可见，回调函数的执行时机要依情况而定。前面说了，异步任务都有一个或多个回调函数，但回调不代表一定是异步操作。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(f2)</span><br></pre></td></tr></table></figure>\n<p>这其实是一个同步的回调，因为没有任务发生在“将来”。</p>\n<p>而假如f1是一个ajax请求，f2的执行需要依赖于f1返回的数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里使用setTimeout来模拟ajax请求的耗时过程</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// f1的任务代码</span></span><br><span class=\"line\">        callback()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(f2)</span><br></pre></td></tr></table></figure>\n<p>这就变成了一个异步的回调，因为回调的执行发生在“将来”。</p>\n<p>回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱。当回调不断嵌套，便会形成人们熟知的<code>回调地狱</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ajax(<span class=\"string\">\"http://some.url.1\"</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text == <span class=\"string\">\"hello\"</span>) &#123;</span><br><span class=\"line\">                    handler();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (text == <span class=\"string\">\"world\"</span>) &#123;</span><br><span class=\"line\">                    request();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h3><p>介绍完回调函数我们再回过头来看看主线程提取任务队列事件执行的机制。</p>\n<p>这里引用一张经典的图示来说明这个过程。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMWCR.png\" alt=\"eventloop\"></p>\n<p><code>stack</code>代表主线程中执行的同步任务，<code>WebAPIs</code>代表浏览器执行异步任务的线程，当异步任务有结果时便会在<code>callback queue</code>（也就是上面提到的<code>任务队列</code>）中放置一个事件，这个事件并不能立即执行，而是要等主线程上的任务全部结束，<code>stack</code>中的任务每执行完一个便会出栈直至栈空。<code>stack</code>在忙活了一阵终于把自己手头的工作做完了，然而它并不能马上休息，要先去看任务队列中是否有事件等待，如果有便要去任务队列中提取事件进入自己内部执行，任务队列中的事件遵循先进先出原则。每一次事件循环称为tick，整个过程不断循环，我们将这种运行机制称为<code>Event Loop（事件循环）</code>。</p>\n<p>有了对于事件循环的理解，我们来看两个出镜率很高的面试题：</p>\n<p>1、</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p><code>setTimeout</code>是浏览器window对象的方法，表示延迟执行一个事件，可以接受两个参数，第一个是一个回调方法，第二个是执行代码前需等待的毫秒数。这是一个非常常用的异步方法。</p>\n<p>这个例子我们一看，哎呦，第二个参数是0，太好了不用等马上可以执行。于是快速的得出结果：<code>1 2</code>。</p>\n<p>可<code>setTimeout</code>是一个异步任务，当主线程执行到它时会把它交到浏览器单独为其提供的线程中去然后继续向下运行。虽然等待时间为0也只是意味着回调函数可以马上进入到任务队列中等待，直到主线程任务全部结束再通过事件循环机制读取任务队列执行事件。所以正确结果应该是<code>2 1</code>。</p>\n<p>2、</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码初学者通常会给出<code>0 1 2 3 4</code>的回答，但其实<code>for</code>循环中<code>i</code>的累加过程是同步的，循环体中的打印是异步的，并且<code>i</code>是全局变量，当同步任务执行完的时候运行环境中变量<code>i</code>的值已经变成了<code>5</code>，这个时候再执行定时器回调函数将会连续打印出<code>5 5 5 5 5</code>。</p>\n<p>值得注意的是，<strong>HTML5标准规定了setTimeout()的第二个参数的最小值不得低于4毫秒</strong>，因此即使设置了0，也要至少等待4毫秒，而且还要看同步任务是否全部结束以及当前事件是否排在任务队列的第一个，因此这个等待时间并不一定准确。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>前面说了使用回调来表达程序异步会造成流程混乱，也不利于代码的阅读和维护，如果能让这一过程更加简洁清晰一些就好了。值得开发者们欣喜的是，ES6为我们提供了一个名为<code>Promise</code>的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。话不多说，我们先来看<code>Promise</code>是怎么使用的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... some code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>Promise</code>是一个对象，有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例，接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。当异步操作成功或者失败时，<code>resolve</code>和<code>reject</code>会作为参数传递出去。</p>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数，<code>rejected</code>非必传。</p>\n<p>回到上面那段代码，当我们在<code>Promise</code>对象中执行一个异步操作时并不需要在内部处理成功或失败的结果，而是把这个状态抛出来在外面链式地进行处理。也就是<code>Promise</code>内部不关心如何处理结果，只在完成的将来处理。这样就把执行代码和处理结果的代码清晰地分离了。</p>\n<p>而当我们再一次面对多个存在依赖关系执行的异步任务时，也不需要像以往一样横向编程，层层嵌套形成一个<code>回调地狱</code>。<code>Promise</code>允许我们进行链式编程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request.readyState === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (request.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                    resolve(request.responseText);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    reject(request.status);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        request.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">        request.send(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">\"http://...\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(res.url)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>使用链式的<code>then</code> 指定一组按照次序调用的回调函数。前一个回调函数，返回的还是一个<code>Promise</code>对象，这时后一个回调函数就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。这样既保证了任务的有序性，逻辑也更清晰了呢。</p>\n<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。因此</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">\"http://...\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(res.url)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 也可写成</span></span><br><span class=\"line\">ajax(<span class=\"string\">\"http://...\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(res.url)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"新的事件循环\"><a href=\"#新的事件循环\" class=\"headerlink\" title=\"新的事件循环\"></a>新的事件循环</h3><p><code>Promise</code> 不仅使得异步任务实现方式的定义更加良好，对顺序的保证性更强，也尽可能早的将任务队列中事件的执行提前了。</p>\n<p>由此我们需要对前面讲过的任务进行更进一步细化的分类：</p>\n<blockquote>\n<p>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p>\n<p>micro-task(微任务)：Promise，process.nextTick</p>\n</blockquote>\n<p>微任务可以理解为是挂在事件循环的每个 tick 之后的一个队列。在事件循环的每个 tick 中，微任务产生的回调不会被添加到任务队列中等待下一轮tick读取，而会进入当前 tick 的主线程末尾，相当于插队。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise'</span>)</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'then'</span>) <span class=\"comment\">// 插到console.log('console')后面</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'console'</span>)</span><br></pre></td></tr></table></figure>\n<p>因此上面这段代码的结果是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// console</span></span><br><span class=\"line\"><span class=\"comment\">// then</span></span><br><span class=\"line\"><span class=\"comment\">// setTimeout</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在开始动笔写这篇博客前，我参阅了几篇有关这部分内容的博客，更是反复阅读了阮一峰老师的<em><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解：再谈Event Loop</a></em>以及<em><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\" target=\"_blank\" rel=\"noopener\">Javascript异步编程的4种方法</a></em>，但在这过程中其实对文章中的一些解读和概念并不能很好的理解，甚至于感觉有些内容存在矛盾，比如对于异步编程方法中回调函数的举例描述以及事件循环主线程和任务队列关系的语义相反的关系描述，这也引起了我极大的求知欲，不停查找资料以求找到更加准确的定义。也在找寻答案的路途中发现很多有关异步的博客都是几乎照搬阮一峰的博客，并没有引入自己的见解和解读，想说写博客的目的既是一个学习过程的记录，同时也是一个发现并解决问题的契机，与其照搬不如直接加个（转）。希望可以和大家共勉，如果发现我的文章内容描述有偏颇也欢迎一起讨论学习。</p>\n<p><em>部分内容参考自以下：</em><br><a href=\"https://www.cnblogs.com/woodyblog/p/6061671.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/woodyblog/p/6061671.html</a><br><a href=\"https://blog.csdn.net/jssy_csu/article/details/78627628\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jssy_csu/article/details/78627628</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/promise</a><br>《你不知道的JavaScript（中卷）》</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"单线程的JS\"><a href=\"#单线程的JS\" class=\"headerlink\" title=\"单线程的JS\"></a>单线程的JS</h3><p>作为JavaScript的核心特性，单线程决定了其同一时间只能做一件事，所有任务排队等候执行，前一个结束后一个才可以执行。但是当遇到http请求这类比较耗时的任务时，如果持续等待结果将会阻塞整个队列的快速执行，甚至造成浏览器停止响应。举个例子：傍晚时候，我给老王发了条微信，老铁周末去打球吗，老王不一定秒回，如果我一直抱着手机等待老王的回复，那不知道我什么时候可以去吃晚饭，也许刚巧老王前一天通宵到下午才回到家此时正在呼呼大睡，于是在饥肠辘辘的等待中，博主卒。但是如果我发好了微信就去吃饭，什么时候老王回我了再去订球馆就会避免这种情况的出现。好在作为JS宿主环境的浏览器并不是单线程的。</p>\n<h3 id=\"多线程的浏览器\"><a href=\"#多线程的浏览器\" class=\"headerlink\" title=\"多线程的浏览器\"></a>多线程的浏览器</h3><p>浏览器只会给JS分配一个主线程来执行任务，但是浏览器却为那些耗时的任务单独开辟了其他线程，比如：浏览器事件触发线程 、http请求线程 、定时器触发线程 ······当主线程执行到这类耗时任务时便会暂时将它们挂起，继续向下执行后面的任务，等到挂起的任务执行完成后再回过头来进入到主线程继续执行。</p>\n<h3 id=\"“现在”与“将来”\"><a href=\"#“现在”与“将来”\" class=\"headerlink\" title=\"“现在”与“将来”\"></a>“现在”与“将来”</h3><p>如此一来，任务被分成了两种，一种是<code>同步任务</code>，一种是<code>异步任务</code>，同步任务在主线程上执行，主线程之外存在一个<code>任务队列</code>，当异步任务有了执行结果就在任务队列当中放置一个事件，等待主线程上的同步任务全部执行完成后便会进入主线程中执行。异步任务都有一个或多个回调函数，当任务队列中的事件被主线程读取时便会执行这个回调函数。在<strong>《你不知道的JavaScript（中卷）》</strong>一书中，作者将其称为“现在”与“将来”。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><blockquote>\n<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>\n</blockquote>\n<p>可见，回调函数的执行时机要依情况而定。前面说了，异步任务都有一个或多个回调函数，但回调不代表一定是异步操作。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(f2)</span><br></pre></td></tr></table></figure>\n<p>这其实是一个同步的回调，因为没有任务发生在“将来”。</p>\n<p>而假如f1是一个ajax请求，f2的执行需要依赖于f1返回的数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里使用setTimeout来模拟ajax请求的耗时过程</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// f1的任务代码</span></span><br><span class=\"line\">        callback()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(f2)</span><br></pre></td></tr></table></figure>\n<p>这就变成了一个异步的回调，因为回调的执行发生在“将来”。</p>\n<p>回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱。当回调不断嵌套，便会形成人们熟知的<code>回调地狱</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(<span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ajax(<span class=\"string\">\"http://some.url.1\"</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text == <span class=\"string\">\"hello\"</span>) &#123;</span><br><span class=\"line\">                    handler();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (text == <span class=\"string\">\"world\"</span>) &#123;</span><br><span class=\"line\">                    request();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h3><p>介绍完回调函数我们再回过头来看看主线程提取任务队列事件执行的机制。</p>\n<p>这里引用一张经典的图示来说明这个过程。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMWCR.png\" alt=\"eventloop\"></p>\n<p><code>stack</code>代表主线程中执行的同步任务，<code>WebAPIs</code>代表浏览器执行异步任务的线程，当异步任务有结果时便会在<code>callback queue</code>（也就是上面提到的<code>任务队列</code>）中放置一个事件，这个事件并不能立即执行，而是要等主线程上的任务全部结束，<code>stack</code>中的任务每执行完一个便会出栈直至栈空。<code>stack</code>在忙活了一阵终于把自己手头的工作做完了，然而它并不能马上休息，要先去看任务队列中是否有事件等待，如果有便要去任务队列中提取事件进入自己内部执行，任务队列中的事件遵循先进先出原则。每一次事件循环称为tick，整个过程不断循环，我们将这种运行机制称为<code>Event Loop（事件循环）</code>。</p>\n<p>有了对于事件循环的理解，我们来看两个出镜率很高的面试题：</p>\n<p>1、</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p><code>setTimeout</code>是浏览器window对象的方法，表示延迟执行一个事件，可以接受两个参数，第一个是一个回调方法，第二个是执行代码前需等待的毫秒数。这是一个非常常用的异步方法。</p>\n<p>这个例子我们一看，哎呦，第二个参数是0，太好了不用等马上可以执行。于是快速的得出结果：<code>1 2</code>。</p>\n<p>可<code>setTimeout</code>是一个异步任务，当主线程执行到它时会把它交到浏览器单独为其提供的线程中去然后继续向下运行。虽然等待时间为0也只是意味着回调函数可以马上进入到任务队列中等待，直到主线程任务全部结束再通过事件循环机制读取任务队列执行事件。所以正确结果应该是<code>2 1</code>。</p>\n<p>2、</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码初学者通常会给出<code>0 1 2 3 4</code>的回答，但其实<code>for</code>循环中<code>i</code>的累加过程是同步的，循环体中的打印是异步的，并且<code>i</code>是全局变量，当同步任务执行完的时候运行环境中变量<code>i</code>的值已经变成了<code>5</code>，这个时候再执行定时器回调函数将会连续打印出<code>5 5 5 5 5</code>。</p>\n<p>值得注意的是，<strong>HTML5标准规定了setTimeout()的第二个参数的最小值不得低于4毫秒</strong>，因此即使设置了0，也要至少等待4毫秒，而且还要看同步任务是否全部结束以及当前事件是否排在任务队列的第一个，因此这个等待时间并不一定准确。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>前面说了使用回调来表达程序异步会造成流程混乱，也不利于代码的阅读和维护，如果能让这一过程更加简洁清晰一些就好了。值得开发者们欣喜的是，ES6为我们提供了一个名为<code>Promise</code>的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。话不多说，我们先来看<code>Promise</code>是怎么使用的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... some code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>Promise</code>是一个对象，有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例，接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。当异步操作成功或者失败时，<code>resolve</code>和<code>reject</code>会作为参数传递出去。</p>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数，<code>rejected</code>非必传。</p>\n<p>回到上面那段代码，当我们在<code>Promise</code>对象中执行一个异步操作时并不需要在内部处理成功或失败的结果，而是把这个状态抛出来在外面链式地进行处理。也就是<code>Promise</code>内部不关心如何处理结果，只在完成的将来处理。这样就把执行代码和处理结果的代码清晰地分离了。</p>\n<p>而当我们再一次面对多个存在依赖关系执行的异步任务时，也不需要像以往一样横向编程，层层嵌套形成一个<code>回调地狱</code>。<code>Promise</code>允许我们进行链式编程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request.readyState === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (request.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                    resolve(request.responseText);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    reject(request.status);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        request.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">        request.send(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">\"http://...\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(res.url)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>使用链式的<code>then</code> 指定一组按照次序调用的回调函数。前一个回调函数，返回的还是一个<code>Promise</code>对象，这时后一个回调函数就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。这样既保证了任务的有序性，逻辑也更清晰了呢。</p>\n<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。因此</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">\"http://...\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(res.url)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 也可写成</span></span><br><span class=\"line\">ajax(<span class=\"string\">\"http://...\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(res.url)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"新的事件循环\"><a href=\"#新的事件循环\" class=\"headerlink\" title=\"新的事件循环\"></a>新的事件循环</h3><p><code>Promise</code> 不仅使得异步任务实现方式的定义更加良好，对顺序的保证性更强，也尽可能早的将任务队列中事件的执行提前了。</p>\n<p>由此我们需要对前面讲过的任务进行更进一步细化的分类：</p>\n<blockquote>\n<p>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p>\n<p>micro-task(微任务)：Promise，process.nextTick</p>\n</blockquote>\n<p>微任务可以理解为是挂在事件循环的每个 tick 之后的一个队列。在事件循环的每个 tick 中，微任务产生的回调不会被添加到任务队列中等待下一轮tick读取，而会进入当前 tick 的主线程末尾，相当于插队。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise'</span>)</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'then'</span>) <span class=\"comment\">// 插到console.log('console')后面</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'console'</span>)</span><br></pre></td></tr></table></figure>\n<p>因此上面这段代码的结果是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// console</span></span><br><span class=\"line\"><span class=\"comment\">// then</span></span><br><span class=\"line\"><span class=\"comment\">// setTimeout</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在开始动笔写这篇博客前，我参阅了几篇有关这部分内容的博客，更是反复阅读了阮一峰老师的<em><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解：再谈Event Loop</a></em>以及<em><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\" target=\"_blank\" rel=\"noopener\">Javascript异步编程的4种方法</a></em>，但在这过程中其实对文章中的一些解读和概念并不能很好的理解，甚至于感觉有些内容存在矛盾，比如对于异步编程方法中回调函数的举例描述以及事件循环主线程和任务队列关系的语义相反的关系描述，这也引起了我极大的求知欲，不停查找资料以求找到更加准确的定义。也在找寻答案的路途中发现很多有关异步的博客都是几乎照搬阮一峰的博客，并没有引入自己的见解和解读，想说写博客的目的既是一个学习过程的记录，同时也是一个发现并解决问题的契机，与其照搬不如直接加个（转）。希望可以和大家共勉，如果发现我的文章内容描述有偏颇也欢迎一起讨论学习。</p>\n<p><em>部分内容参考自以下：</em><br><a href=\"https://www.cnblogs.com/woodyblog/p/6061671.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/woodyblog/p/6061671.html</a><br><a href=\"https://blog.csdn.net/jssy_csu/article/details/78627628\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jssy_csu/article/details/78627628</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/promise</a><br>《你不知道的JavaScript（中卷）》</p>\n"},{"title":"ES6——一场JavaScript语法的重大变革","subtitle":"less is more","date":"2018-11-28T15:21:08.000Z","urlname":"es6-change","cover":"https://s1.ax1x.com/2018/11/28/FZneED.jpg","toc":true,"_content":"\n### 前言\n\nES5标准发布后，JavaScript的发展步伐越来越快，新的特性和语法形式亟待标准化。而在经历了各种波折后，千呼万唤的ECMAScript 6（简称ES6）作为JavaScript语言的下一代标准终于在2015年发布。\n\n对于JavaScript这门语言来说，ES6 是一次激进的飞跃。简洁高效的语法解放了开发者，同时也弥补了一些最初的设计缺陷。可以说这是一场JavaScript语法的重大变革。\n\n那么ES6究竟为我们带来了哪些新的特性？它又颠覆哪些我们之前固有的语法习惯？\n\n下面这张思维导图概括了ES6的一些核心特性，虽不完全但足够日常使用。\n\n![es6_mind](https://s1.ax1x.com/2018/11/29/FZsRBV.png)\n\n*<font color=\"#bbb\" size=\"3\">思维导图来自@[浪里行舟](https://github.com/ljianshu/Blog)，已获得使用许可</font>*\n\n### 箭头函数\n\n箭头函数是ES6使用率最高的特性之一。从字面上看，箭头函数简化了定义函数的写法，使用`=>`替代`function`。\n\n```javascript\n// ES5\nfunction foo(x,y) { \n    return x + y\n} \n// ES6\nvar foo = (x,y) => x + y\n```\n\n箭头函数定义包括一个参数列表（零个或多个参数，如果参数个数不是一个的话要用`( .. )`包围起来），然后是标识` =>`，函数体放在最后。 \n\n所以，在前面的代码中，箭头函数就是`(x,y) => x + y`这一部分，然后这个函数引用被赋给变量 foo。 \n\n只有在函数体的表达式个数多于1个，或者函数体包含非表达式语句的时候才需要用`{ .. } `包围。如果只有一个表达式，并且省略了包围的`{ .. }`的话，则意味着表达式前面有一个隐含的`return`，就像前面代码中展示的那样。\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 这里列出了几种不同形式的箭头函数： \n\n``` javascript\nvar f1 = () => 12\nvar f2 = x => x * 2\nvar f3 = (x,y) => { \n    var z = x * 2 + y\n    y++\n    x *= 3\n    return (x + y + z) / 2\n}\nvar f4 = (x,y) => ({ x:x, y:y })\n```\n\n箭头函数**总是**函数表达式；并不存在箭头函数声明。\n\n除了简化写法，箭头函数的主要设计目的是以特定的方式改变`this`的行为特性。在前面的[解惑JavaScript中的this指向问题](/2018-11-01-javascript-this-disabuse.html)中我们有介绍，ES5中`this`指向取决于函数调用方式，而箭头函数中的`this`不一样，它指向定义时的对象，这也正是多数情况下我们所希望的。\n\n``` javascript\n// ES5中使用var self = this这一hack方法绑定this\nvar obj = {\n    a:1,\n    foo:function(){\n        var self = this\n        setTimeout(function(){\n            // 希望获取obj中的a\n            console.log(self.a)\n        },1000)\n    }\n}\n// 箭头函数\nvar obj = {\n    a:1,\n    foo:function(){\n        setTimeout(()=>{\n            // 没问题this指向obj\n            console.log(this.a)\n        },1000)\n    }\n}\n```\n\n### let和const\n\n我们知道ES5中只有全局作用域和函数作用域，并没有块级作用域的概念（有关作用域看[这里](/2018-10-18-javascript-scope.html)），这会导致几个问题：\n\n1、变量可能会发生冲突并覆盖变量值\n\n2、用来计数的循环变量泄露为全局变量，比如在for循环中。\n\n如果在ES5中需要创建一个块级作用域可以使用立即调用函数表达式（IIFE），IIFE中的变量和函数会在在执行后销毁，防止污染到外部作用域。\n\nES6为我们带来了`let`和`const`两个命令，我们可以利用它们创建绑定到任意块的声明，我们只需要一对`{ .. }`就可以创建一个作用域。不像使用var那样声明的变量总是归属于包含函数（即全局，如果在最顶层的话）作用域，`let`声明的变量只在其所在的代码块内有效，且不存在变量提升。\n\n``` javascript\nvar a = 2\n{\n    console.log( a ) // Uncaught ReferenceError: a is not defined\n    let a = 3\n    console.log( a ) // 3\n}\nconsole.log( a ) // 2\n```\n\n和`let`差不多，只不过`const`声明一个只读的常量。一旦声明，常量的值就不能改变。实际应用中，使用`const`定义变量也能够明白地告诉后来的开发者该变量不可修改赋值。\n\n### 模板字符串\n\nES6以前，我们定义字符串模板时，需要使用`+`拼接字符串、变量以及进行换行：\n\n``` javascript\nvar name = 'blackstar'\nvar str = 'hello ' + name + ','\n\t'nice to meet you!'\n```\n\n在ES6中我们使用反引号** `** 作为标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量甚至是函数调用。\n\n``` javascript\nfunction upper(s) {\n    return s.toUpperCase()\n}\nvar name = 'blackstar'\n// 模板字符串会保留所有的空格和缩进\nvar str = `hello ${upper(name)},\n\tnice to meet you!`\n```\n\n### 解构赋值\n\nES6允许按照一定模式，从数组和对象中提取值对变量进行赋值，这被称为解构。\n\n#### 数组解构赋值\n\n``` javascript\nvar a = 1\nvar b = 2\nvar c = 3\n// 无须再像上面那样一个一个赋值\nvar [a,b,c] = [1,2,3]\n```\n\n解构赋值支持嵌套，数组的解构赋值按照位置对应取值：\n\n``` javascript\nlet [foo, [[bar], baz]] = [1, [[2], 3]]\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"]\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3]\nx // 1\ny // 3\n\nlet [x, y] = ['a']\nx // \"a\"\ny // undefined\n```\n\n解构赋值允许指定默认值。\n\n``` javascript\nlet [x, y = 'b'] = ['a'] // x='a', y='b'\n```\n\n#### 对象解构赋值\n\n不同于数组按照位置解构赋值，对象的解构赋值是按照属性名来的。变量名须与属性名相同才可以取到值。\n\n``` javascript\nlet { foo, baz } = { foo: \"aaa\", bar: \"bbb\" }\nfoo // \"aaa\"\nbaz // undefined\n```\n\n如果变量名与属性不一致，需要使用如下写法：\n\n``` javascript\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' }\nbaz // \"aaa\"\n```\n\n对象解构赋值同样支持嵌套和指定默认值。\n\n有一点很重要需要牢记，如果是给已经声明的变量赋值，需要使用`()`包裹，不然`{}`会被当做代码块。\n\n``` javascript\nlet x\n({x} = {x: 1})\n```\n\n#### 字符串解构赋值\n\n``` javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n#### 函数参数解构赋值\n\n``` javascript\nfunction add([x, y]){\n    return x + y\n}\n\nadd([1, 2]) // 3\n```\n\n### 默认参数值\n\nJavaScript最常见的一个技巧就是关于设定函数参数默认值的。多年以来我们实现这一点的方式是这样的：\n\n``` javascript\nfunction foo(x,y) {\n    x = x || 11\n    y = y || 31\n    console.log( x + y )\n}\nfoo() // 42\nfoo( 5, 6 ) // 11\nfoo( 5 ) // 36\nfoo( null, 6 ) // 17\n```\n\n当然，如果你之前使用过这个模式，就会知道它很有用，但同时又有点危险，比如，如果对于一个参数你需要能够传入被认为是false（假）的值。考虑：\n\n``` javascript\nfoo( 0, 42 ) // 53 <--哎呀，并非42\n```\n\n为什么？因为这里0为假，所以`x || 11`结果为11，而不是直接传入的0。要修正这个问题，有些人会选择增加更多的检查，就像下面这样：\n\n``` javascript\nfunction foo(x,y) {\n    x = (x !== undefined) ? x : 11\n    y = (y !== undefined) ? y : 31\n    console.log( x + y )\n}\nfoo( 0, 42 ) // 42\nfoo( undefined, 6 ) // 17\n```\n\n那么ES6新增的一个有用的语法可以改进为缺失参数赋默认值的流程。\n\n``` javascript\nfunction foo(x = 11, y = 31) {\n    console.log( x + y )\n}\nfoo() // 42\nfoo( 5, 6 ) // 11\nfoo( 0, 42 ) // 42\nfoo( 5 ) // 36\nfoo( 5, undefined ) // 36 <-- 丢了undefined\nfoo( 5, null ) // 5 <-- null被强制转换为0\nfoo( undefined, 6 ) // 17 <-- 丢了undefined\nfoo( null, 6 ) // 6 <-- null被强制转换为0\n```\n\n函数默认值可以不只是简单值，它们可以是任意合法表达式，甚至是函数调用。但是需要注意由于参数变量是默认声明的，所以不能用`let`或`const`再次声明。\n\n``` javascript\nfunction foo(x = 5) {\n    let x = 1 // error\n    const x = 2 // error\n}\n```\n\n参数默认值也可以与解构赋值的默认值结合起来使用。\n\n``` javascript\nfunction foo({x, y = 5}) {\n    console.log(x, y)\n}\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n```\n\n### `...`运算符\n\nES6 引入了一个新的运算符`...`，通常称为spread或rest（展开或收集）运算符，取决于它在哪 / 如何使用。\n\n#### 扩展运算符\n\n当`...`用在数组或字符串之前时，它会把这个变量“展开”为各个独立的值。\n\n``` javascript\nconsole.log(...[1, 2, 3])\n// 1 2 3\n```\n\n这一特性也方便我们替代`concat()`方法来合并数组.\n\n``` javascript\nvar a = [2,3,4]\nvar b = [ 1, ...a, 5 ]\nconsole.log( b ) // [1,2,3,4,5]\n```\n\n### rest参数\n\n作为扩展运算符的反向行为，`...`可以用于获取函数的多余参数并且收集到一起成为一个数组，这样就不需要使用arguments对象了。\n\n``` javascript\nfunction foo(x, y, ...z) {\n    console.log( x, y, z )\n}\nfoo( 1, 2, 3, 4, 5 ) // 1 2 [3,4,5]\n```\n\n对于上面的参数`z`，我们称其为rest参数。`注意：rest参数只能作为最后一个参数`。\n\n### 数组扩展\n\n#### find()和findIndex()\n\n`find()`方法用于找出第一个符合条件的数组成员。它的参数是一个回调函数，回调函数可接受三个参数，依次为当前的值、当前的位置和原数组。所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。\n\n``` javascript\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n```\n\n`findIndex()`则是返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。\n\n#### entries()，keys()和values()\n\nES6 提供三个新的方法`entries()`，`keys()`和`values()`用于遍历数组。`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。\n\n### Set\n\nES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n``` javascript\nconst set = new Set([1, 2, 3, 4, 4])\nconsole.log(set) // Set(4) {1, 2, 3, 4}\n```\n\n### Object.assign()\n\n`Object.assign()`方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象上。但如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\n``` javascript\nconst target = { a: 1, b: 1 }\nconst source1 = { b: 2, c: 2 }\nconst source2 = { c: 3 }\nObject.assign(target, source1, source2)\nconsole.log(target) // {a:1, b:2, c:3}\n```\n\n### for..of 循环\n\nES6在把JavaScript中我们熟悉的`for`和`for..in`循环组合起来的基础上，又新增了一个`for..of`循环，`for...of`循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator对象，以及字符串。\n\n`for..in`在数组的键/索引上循环，而`for..of`在值上循环。\n\n``` javascript\nvar a = [\"a\",\"b\",\"c\",\"d\",\"e\"];\nfor (var idx in a) {\n    console.log( idx )\n}\n// 0 1 2 3 4\nfor (var val of a) {\n    console.log( val )\n}\n// \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n\n### Promise\n\n我们在处理异步的时候通常会使用回调来处理流程，可这样会比较混乱，也不利于代码的阅读和维护(可能形成回调地狱)，而ES6为我们提供了一个名为`Promise`的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n    // ... some code\n    if(/* 异步操作成功 */){\n        resolve(value)\n    }else{\n        reject(error)\n    }\n})\npromise.then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n有关`Promise`更详细的内容前面的文章[JS单线程与异步](/2018-09-05-javascript-singlethread-asynchronous.html)中有介绍。\n\n### 模块化\n\n在ES6中我们可以通过`import`和`export`命令来帮助我们实现模块化。`export`用来导出变量或函数，`import`则是加载。\n\n``` javascript\n// 几种导出方式\nexport function foo() {\n // ..\n} \n\nfunction foo() {\n // ..\n}\nvar awesome = 42\nvar bar = [1,2,3]\nexport { foo, awesome, bar }\n\nfunction foo() { .. }\nexport { foo as bar } // 导出时重命名\n\n// 加载方式\nimport foo from \"foo\"\n// 或者：\nimport { foo as bar } from \"foo\"\n```\n\n好了，有关ES6的总结就先写到这里，其实它还有很多特性值得我们去发掘使用，但是把最常使用的用精用熟才是硬道理。\n\n*<font color=\"#bbb\" size=\"3\">文章部分内容参考自《你不知道的JavaScript（下卷）》及阮一峰《[ECMAScript 6 入门](http://es6.ruanyifeng.com/)》</font>*","source":"_posts/ES6——一场JavaScript语法的重大变革.md","raw":"---\ntitle: ES6——一场JavaScript语法的重大变革\nsubtitle: less is more\ndate: 2018-11-28 23:21:08\nurlname: es6-change\ncover: \"https://s1.ax1x.com/2018/11/28/FZneED.jpg\"\ncategories: [\"技术\"]\ntags: [\"JS\",\"ES6\"]\ntoc: true\n---\n\n### 前言\n\nES5标准发布后，JavaScript的发展步伐越来越快，新的特性和语法形式亟待标准化。而在经历了各种波折后，千呼万唤的ECMAScript 6（简称ES6）作为JavaScript语言的下一代标准终于在2015年发布。\n\n对于JavaScript这门语言来说，ES6 是一次激进的飞跃。简洁高效的语法解放了开发者，同时也弥补了一些最初的设计缺陷。可以说这是一场JavaScript语法的重大变革。\n\n那么ES6究竟为我们带来了哪些新的特性？它又颠覆哪些我们之前固有的语法习惯？\n\n下面这张思维导图概括了ES6的一些核心特性，虽不完全但足够日常使用。\n\n![es6_mind](https://s1.ax1x.com/2018/11/29/FZsRBV.png)\n\n*<font color=\"#bbb\" size=\"3\">思维导图来自@[浪里行舟](https://github.com/ljianshu/Blog)，已获得使用许可</font>*\n\n### 箭头函数\n\n箭头函数是ES6使用率最高的特性之一。从字面上看，箭头函数简化了定义函数的写法，使用`=>`替代`function`。\n\n```javascript\n// ES5\nfunction foo(x,y) { \n    return x + y\n} \n// ES6\nvar foo = (x,y) => x + y\n```\n\n箭头函数定义包括一个参数列表（零个或多个参数，如果参数个数不是一个的话要用`( .. )`包围起来），然后是标识` =>`，函数体放在最后。 \n\n所以，在前面的代码中，箭头函数就是`(x,y) => x + y`这一部分，然后这个函数引用被赋给变量 foo。 \n\n只有在函数体的表达式个数多于1个，或者函数体包含非表达式语句的时候才需要用`{ .. } `包围。如果只有一个表达式，并且省略了包围的`{ .. }`的话，则意味着表达式前面有一个隐含的`return`，就像前面代码中展示的那样。\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 这里列出了几种不同形式的箭头函数： \n\n``` javascript\nvar f1 = () => 12\nvar f2 = x => x * 2\nvar f3 = (x,y) => { \n    var z = x * 2 + y\n    y++\n    x *= 3\n    return (x + y + z) / 2\n}\nvar f4 = (x,y) => ({ x:x, y:y })\n```\n\n箭头函数**总是**函数表达式；并不存在箭头函数声明。\n\n除了简化写法，箭头函数的主要设计目的是以特定的方式改变`this`的行为特性。在前面的[解惑JavaScript中的this指向问题](/2018-11-01-javascript-this-disabuse.html)中我们有介绍，ES5中`this`指向取决于函数调用方式，而箭头函数中的`this`不一样，它指向定义时的对象，这也正是多数情况下我们所希望的。\n\n``` javascript\n// ES5中使用var self = this这一hack方法绑定this\nvar obj = {\n    a:1,\n    foo:function(){\n        var self = this\n        setTimeout(function(){\n            // 希望获取obj中的a\n            console.log(self.a)\n        },1000)\n    }\n}\n// 箭头函数\nvar obj = {\n    a:1,\n    foo:function(){\n        setTimeout(()=>{\n            // 没问题this指向obj\n            console.log(this.a)\n        },1000)\n    }\n}\n```\n\n### let和const\n\n我们知道ES5中只有全局作用域和函数作用域，并没有块级作用域的概念（有关作用域看[这里](/2018-10-18-javascript-scope.html)），这会导致几个问题：\n\n1、变量可能会发生冲突并覆盖变量值\n\n2、用来计数的循环变量泄露为全局变量，比如在for循环中。\n\n如果在ES5中需要创建一个块级作用域可以使用立即调用函数表达式（IIFE），IIFE中的变量和函数会在在执行后销毁，防止污染到外部作用域。\n\nES6为我们带来了`let`和`const`两个命令，我们可以利用它们创建绑定到任意块的声明，我们只需要一对`{ .. }`就可以创建一个作用域。不像使用var那样声明的变量总是归属于包含函数（即全局，如果在最顶层的话）作用域，`let`声明的变量只在其所在的代码块内有效，且不存在变量提升。\n\n``` javascript\nvar a = 2\n{\n    console.log( a ) // Uncaught ReferenceError: a is not defined\n    let a = 3\n    console.log( a ) // 3\n}\nconsole.log( a ) // 2\n```\n\n和`let`差不多，只不过`const`声明一个只读的常量。一旦声明，常量的值就不能改变。实际应用中，使用`const`定义变量也能够明白地告诉后来的开发者该变量不可修改赋值。\n\n### 模板字符串\n\nES6以前，我们定义字符串模板时，需要使用`+`拼接字符串、变量以及进行换行：\n\n``` javascript\nvar name = 'blackstar'\nvar str = 'hello ' + name + ','\n\t'nice to meet you!'\n```\n\n在ES6中我们使用反引号** `** 作为标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量甚至是函数调用。\n\n``` javascript\nfunction upper(s) {\n    return s.toUpperCase()\n}\nvar name = 'blackstar'\n// 模板字符串会保留所有的空格和缩进\nvar str = `hello ${upper(name)},\n\tnice to meet you!`\n```\n\n### 解构赋值\n\nES6允许按照一定模式，从数组和对象中提取值对变量进行赋值，这被称为解构。\n\n#### 数组解构赋值\n\n``` javascript\nvar a = 1\nvar b = 2\nvar c = 3\n// 无须再像上面那样一个一个赋值\nvar [a,b,c] = [1,2,3]\n```\n\n解构赋值支持嵌套，数组的解构赋值按照位置对应取值：\n\n``` javascript\nlet [foo, [[bar], baz]] = [1, [[2], 3]]\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"]\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3]\nx // 1\ny // 3\n\nlet [x, y] = ['a']\nx // \"a\"\ny // undefined\n```\n\n解构赋值允许指定默认值。\n\n``` javascript\nlet [x, y = 'b'] = ['a'] // x='a', y='b'\n```\n\n#### 对象解构赋值\n\n不同于数组按照位置解构赋值，对象的解构赋值是按照属性名来的。变量名须与属性名相同才可以取到值。\n\n``` javascript\nlet { foo, baz } = { foo: \"aaa\", bar: \"bbb\" }\nfoo // \"aaa\"\nbaz // undefined\n```\n\n如果变量名与属性不一致，需要使用如下写法：\n\n``` javascript\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' }\nbaz // \"aaa\"\n```\n\n对象解构赋值同样支持嵌套和指定默认值。\n\n有一点很重要需要牢记，如果是给已经声明的变量赋值，需要使用`()`包裹，不然`{}`会被当做代码块。\n\n``` javascript\nlet x\n({x} = {x: 1})\n```\n\n#### 字符串解构赋值\n\n``` javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n#### 函数参数解构赋值\n\n``` javascript\nfunction add([x, y]){\n    return x + y\n}\n\nadd([1, 2]) // 3\n```\n\n### 默认参数值\n\nJavaScript最常见的一个技巧就是关于设定函数参数默认值的。多年以来我们实现这一点的方式是这样的：\n\n``` javascript\nfunction foo(x,y) {\n    x = x || 11\n    y = y || 31\n    console.log( x + y )\n}\nfoo() // 42\nfoo( 5, 6 ) // 11\nfoo( 5 ) // 36\nfoo( null, 6 ) // 17\n```\n\n当然，如果你之前使用过这个模式，就会知道它很有用，但同时又有点危险，比如，如果对于一个参数你需要能够传入被认为是false（假）的值。考虑：\n\n``` javascript\nfoo( 0, 42 ) // 53 <--哎呀，并非42\n```\n\n为什么？因为这里0为假，所以`x || 11`结果为11，而不是直接传入的0。要修正这个问题，有些人会选择增加更多的检查，就像下面这样：\n\n``` javascript\nfunction foo(x,y) {\n    x = (x !== undefined) ? x : 11\n    y = (y !== undefined) ? y : 31\n    console.log( x + y )\n}\nfoo( 0, 42 ) // 42\nfoo( undefined, 6 ) // 17\n```\n\n那么ES6新增的一个有用的语法可以改进为缺失参数赋默认值的流程。\n\n``` javascript\nfunction foo(x = 11, y = 31) {\n    console.log( x + y )\n}\nfoo() // 42\nfoo( 5, 6 ) // 11\nfoo( 0, 42 ) // 42\nfoo( 5 ) // 36\nfoo( 5, undefined ) // 36 <-- 丢了undefined\nfoo( 5, null ) // 5 <-- null被强制转换为0\nfoo( undefined, 6 ) // 17 <-- 丢了undefined\nfoo( null, 6 ) // 6 <-- null被强制转换为0\n```\n\n函数默认值可以不只是简单值，它们可以是任意合法表达式，甚至是函数调用。但是需要注意由于参数变量是默认声明的，所以不能用`let`或`const`再次声明。\n\n``` javascript\nfunction foo(x = 5) {\n    let x = 1 // error\n    const x = 2 // error\n}\n```\n\n参数默认值也可以与解构赋值的默认值结合起来使用。\n\n``` javascript\nfunction foo({x, y = 5}) {\n    console.log(x, y)\n}\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n```\n\n### `...`运算符\n\nES6 引入了一个新的运算符`...`，通常称为spread或rest（展开或收集）运算符，取决于它在哪 / 如何使用。\n\n#### 扩展运算符\n\n当`...`用在数组或字符串之前时，它会把这个变量“展开”为各个独立的值。\n\n``` javascript\nconsole.log(...[1, 2, 3])\n// 1 2 3\n```\n\n这一特性也方便我们替代`concat()`方法来合并数组.\n\n``` javascript\nvar a = [2,3,4]\nvar b = [ 1, ...a, 5 ]\nconsole.log( b ) // [1,2,3,4,5]\n```\n\n### rest参数\n\n作为扩展运算符的反向行为，`...`可以用于获取函数的多余参数并且收集到一起成为一个数组，这样就不需要使用arguments对象了。\n\n``` javascript\nfunction foo(x, y, ...z) {\n    console.log( x, y, z )\n}\nfoo( 1, 2, 3, 4, 5 ) // 1 2 [3,4,5]\n```\n\n对于上面的参数`z`，我们称其为rest参数。`注意：rest参数只能作为最后一个参数`。\n\n### 数组扩展\n\n#### find()和findIndex()\n\n`find()`方法用于找出第一个符合条件的数组成员。它的参数是一个回调函数，回调函数可接受三个参数，依次为当前的值、当前的位置和原数组。所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。\n\n``` javascript\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n```\n\n`findIndex()`则是返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。\n\n#### entries()，keys()和values()\n\nES6 提供三个新的方法`entries()`，`keys()`和`values()`用于遍历数组。`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。\n\n### Set\n\nES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n``` javascript\nconst set = new Set([1, 2, 3, 4, 4])\nconsole.log(set) // Set(4) {1, 2, 3, 4}\n```\n\n### Object.assign()\n\n`Object.assign()`方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象上。但如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\n``` javascript\nconst target = { a: 1, b: 1 }\nconst source1 = { b: 2, c: 2 }\nconst source2 = { c: 3 }\nObject.assign(target, source1, source2)\nconsole.log(target) // {a:1, b:2, c:3}\n```\n\n### for..of 循环\n\nES6在把JavaScript中我们熟悉的`for`和`for..in`循环组合起来的基础上，又新增了一个`for..of`循环，`for...of`循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator对象，以及字符串。\n\n`for..in`在数组的键/索引上循环，而`for..of`在值上循环。\n\n``` javascript\nvar a = [\"a\",\"b\",\"c\",\"d\",\"e\"];\nfor (var idx in a) {\n    console.log( idx )\n}\n// 0 1 2 3 4\nfor (var val of a) {\n    console.log( val )\n}\n// \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n\n### Promise\n\n我们在处理异步的时候通常会使用回调来处理流程，可这样会比较混乱，也不利于代码的阅读和维护(可能形成回调地狱)，而ES6为我们提供了一个名为`Promise`的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n    // ... some code\n    if(/* 异步操作成功 */){\n        resolve(value)\n    }else{\n        reject(error)\n    }\n})\npromise.then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n有关`Promise`更详细的内容前面的文章[JS单线程与异步](/2018-09-05-javascript-singlethread-asynchronous.html)中有介绍。\n\n### 模块化\n\n在ES6中我们可以通过`import`和`export`命令来帮助我们实现模块化。`export`用来导出变量或函数，`import`则是加载。\n\n``` javascript\n// 几种导出方式\nexport function foo() {\n // ..\n} \n\nfunction foo() {\n // ..\n}\nvar awesome = 42\nvar bar = [1,2,3]\nexport { foo, awesome, bar }\n\nfunction foo() { .. }\nexport { foo as bar } // 导出时重命名\n\n// 加载方式\nimport foo from \"foo\"\n// 或者：\nimport { foo as bar } from \"foo\"\n```\n\n好了，有关ES6的总结就先写到这里，其实它还有很多特性值得我们去发掘使用，但是把最常使用的用精用熟才是硬道理。\n\n*<font color=\"#bbb\" size=\"3\">文章部分内容参考自《你不知道的JavaScript（下卷）》及阮一峰《[ECMAScript 6 入门](http://es6.ruanyifeng.com/)》</font>*","slug":"ES6——一场JavaScript语法的重大变革","published":1,"updated":"2018-12-01T14:22:06.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06sx0004xl69a49mz4vf","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>ES5标准发布后，JavaScript的发展步伐越来越快，新的特性和语法形式亟待标准化。而在经历了各种波折后，千呼万唤的ECMAScript 6（简称ES6）作为JavaScript语言的下一代标准终于在2015年发布。</p>\n<p>对于JavaScript这门语言来说，ES6 是一次激进的飞跃。简洁高效的语法解放了开发者，同时也弥补了一些最初的设计缺陷。可以说这是一场JavaScript语法的重大变革。</p>\n<p>那么ES6究竟为我们带来了哪些新的特性？它又颠覆哪些我们之前固有的语法习惯？</p>\n<p>下面这张思维导图概括了ES6的一些核心特性，虽不完全但足够日常使用。</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/29/FZsRBV.png\" alt=\"es6_mind\"></p>\n<p><em><font color=\"#bbb\" size=\"3\">思维导图来自@<a href=\"https://github.com/ljianshu/Blog\" target=\"_blank\" rel=\"noopener\">浪里行舟</a>，已获得使用许可</font></em></p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数是ES6使用率最高的特性之一。从字面上看，箭头函数简化了定义函数的写法，使用<code>=&gt;</code>替代<code>function</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>\n<p>箭头函数定义包括一个参数列表（零个或多个参数，如果参数个数不是一个的话要用<code>( .. )</code>包围起来），然后是标识<code>=&gt;</code>，函数体放在最后。 </p>\n<p>所以，在前面的代码中，箭头函数就是<code>(x,y) =&gt; x + y</code>这一部分，然后这个函数引用被赋给变量 foo。 </p>\n<p>只有在函数体的表达式个数多于1个，或者函数体包含非表达式语句的时候才需要用<code>{ .. }</code>包围。如果只有一个表达式，并且省略了包围的<code>{ .. }</code>的话，则意味着表达式前面有一个隐含的<code>return</code>，就像前面代码中展示的那样。</p>\n<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 这里列出了几种不同形式的箭头函数： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> z = x * <span class=\"number\">2</span> + y</span><br><span class=\"line\">    y++</span><br><span class=\"line\">    x *= <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x + y + z) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f4 = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> (&#123; <span class=\"attr\">x</span>:x, <span class=\"attr\">y</span>:y &#125;)</span><br></pre></td></tr></table></figure>\n<p>箭头函数<strong>总是</strong>函数表达式；并不存在箭头函数声明。</p>\n<p>除了简化写法，箭头函数的主要设计目的是以特定的方式改变<code>this</code>的行为特性。在前面的<a href=\"/2018-11-01-javascript-this-disabuse.html\">解惑JavaScript中的this指向问题</a>中我们有介绍，ES5中<code>this</code>指向取决于函数调用方式，而箭头函数中的<code>this</code>不一样，它指向定义时的对象，这也正是多数情况下我们所希望的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5中使用var self = this这一hack方法绑定this</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 希望获取obj中的a</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(self.a)</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没问题this指向obj</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h3><p>我们知道ES5中只有全局作用域和函数作用域，并没有块级作用域的概念（有关作用域看<a href=\"/2018-10-18-javascript-scope.html\">这里</a>），这会导致几个问题：</p>\n<p>1、变量可能会发生冲突并覆盖变量值</p>\n<p>2、用来计数的循环变量泄露为全局变量，比如在for循环中。</p>\n<p>如果在ES5中需要创建一个块级作用域可以使用立即调用函数表达式（IIFE），IIFE中的变量和函数会在在执行后销毁，防止污染到外部作用域。</p>\n<p>ES6为我们带来了<code>let</code>和<code>const</code>两个命令，我们可以利用它们创建绑定到任意块的声明，我们只需要一对<code>{ .. }</code>就可以创建一个作用域。不像使用var那样声明的变量总是归属于包含函数（即全局，如果在最顶层的话）作用域，<code>let</code>声明的变量只在其所在的代码块内有效，且不存在变量提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ) <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>和<code>let</code>差不多，只不过<code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。实际应用中，使用<code>const</code>定义变量也能够明白地告诉后来的开发者该变量不可修改赋值。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><p>ES6以前，我们定义字符串模板时，需要使用<code>+</code>拼接字符串、变量以及进行换行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'hello '</span> + name + <span class=\"string\">','</span></span><br><span class=\"line\">\t<span class=\"string\">'nice to meet you!'</span></span><br></pre></td></tr></table></figure>\n<p>在ES6中我们使用反引号<strong> `</strong> 作为标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量甚至是函数调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upper</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\"><span class=\"comment\">// 模板字符串会保留所有的空格和缩进</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`hello <span class=\"subst\">$&#123;upper(name)&#125;</span>,</span></span><br><span class=\"line\"><span class=\"string\">\tnice to meet you!`</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><p>ES6允许按照一定模式，从数组和对象中提取值对变量进行赋值，这被称为解构。</p>\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">// 无须再像上面那样一个一个赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [a,b,c] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>解构赋值支持嵌套，数组的解构赋值按照位置对应取值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]]</span><br><span class=\"line\">foo <span class=\"comment\">// 1</span></span><br><span class=\"line\">bar <span class=\"comment\">// 2</span></span><br><span class=\"line\">baz <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>]</span><br><span class=\"line\">third <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, , y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y] = [<span class=\"string\">'a'</span>]</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">y <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>] <span class=\"comment\">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对象解构赋值\"><a href=\"#对象解构赋值\" class=\"headerlink\" title=\"对象解构赋值\"></a>对象解构赋值</h4><p>不同于数组按照位置解构赋值，对象的解构赋值是按照属性名来的。变量名须与属性名相同才可以取到值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">baz <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果变量名与属性不一致，需要使用如下写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br></pre></td></tr></table></figure>\n<p>对象解构赋值同样支持嵌套和指定默认值。</p>\n<p>有一点很重要需要牢记，如果是给已经声明的变量赋值，需要使用<code>()</code>包裹，不然<code>{}</code>会被当做代码块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x</span><br><span class=\"line\">(&#123;x&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串解构赋值\"><a href=\"#字符串解构赋值\" class=\"headerlink\" title=\"字符串解构赋值\"></a>字符串解构赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span></span><br><span class=\"line\">a <span class=\"comment\">// \"h\"</span></span><br><span class=\"line\">b <span class=\"comment\">// \"e\"</span></span><br><span class=\"line\">c <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">d <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">e <span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数参数解构赋值\"><a href=\"#函数参数解构赋值\" class=\"headerlink\" title=\"函数参数解构赋值\"></a>函数参数解构赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"默认参数值\"><a href=\"#默认参数值\" class=\"headerlink\" title=\"默认参数值\"></a>默认参数值</h3><p>JavaScript最常见的一个技巧就是关于设定函数参数默认值的。多年以来我们实现这一点的方式是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    x = x || <span class=\"number\">11</span></span><br><span class=\"line\">    y = y || <span class=\"number\">31</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x + y )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 11</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span> ) <span class=\"comment\">// 36</span></span><br><span class=\"line\">foo( <span class=\"literal\">null</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 17</span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你之前使用过这个模式，就会知道它很有用，但同时又有点危险，比如，如果对于一个参数你需要能够传入被认为是false（假）的值。考虑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo( <span class=\"number\">0</span>, <span class=\"number\">42</span> ) <span class=\"comment\">// 53 &lt;--哎呀，并非42</span></span><br></pre></td></tr></table></figure>\n<p>为什么？因为这里0为假，所以<code>x || 11</code>结果为11，而不是直接传入的0。要修正这个问题，有些人会选择增加更多的检查，就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    x = (x !== <span class=\"literal\">undefined</span>) ? x : <span class=\"number\">11</span></span><br><span class=\"line\">    y = (y !== <span class=\"literal\">undefined</span>) ? y : <span class=\"number\">31</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x + y )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">0</span>, <span class=\"number\">42</span> ) <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"literal\">undefined</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 17</span></span><br></pre></td></tr></table></figure>\n<p>那么ES6新增的一个有用的语法可以改进为缺失参数赋默认值的流程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">11</span>, y = <span class=\"number\">31</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x + y )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 11</span></span><br><span class=\"line\">foo( <span class=\"number\">0</span>, <span class=\"number\">42</span> ) <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span> ) <span class=\"comment\">// 36</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"literal\">undefined</span> ) <span class=\"comment\">// 36 &lt;-- 丢了undefined</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"literal\">null</span> ) <span class=\"comment\">// 5 &lt;-- null被强制转换为0</span></span><br><span class=\"line\">foo( <span class=\"literal\">undefined</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 17 &lt;-- 丢了undefined</span></span><br><span class=\"line\">foo( <span class=\"literal\">null</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 6 &lt;-- null被强制转换为0</span></span><br></pre></td></tr></table></figure>\n<p>函数默认值可以不只是简单值，它们可以是任意合法表达式，甚至是函数调用。但是需要注意由于参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">5</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">1</span> <span class=\"comment\">// error</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> x = <span class=\"number\">2</span> <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数默认值也可以与解构赋值的默认值结合起来使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(&#123;&#125;) <span class=\"comment\">// undefined 5</span></span><br><span class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1 5</span></span><br><span class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;) <span class=\"comment\">// 1 2</span></span><br><span class=\"line\">foo() <span class=\"comment\">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"...运算符\"></a><code>...</code>运算符</h3><p>ES6 引入了一个新的运算符<code>...</code>，通常称为spread或rest（展开或收集）运算符，取决于它在哪 / 如何使用。</p>\n<h4 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h4><p>当<code>...</code>用在数组或字符串之前时，它会把这个变量“展开”为各个独立的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n<p>这一特性也方便我们替代<code>concat()</code>方法来合并数组.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [ <span class=\"number\">1</span>, ...a, <span class=\"number\">5</span> ]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ) <span class=\"comment\">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>作为扩展运算符的反向行为，<code>...</code>可以用于获取函数的多余参数并且收集到一起成为一个数组，这样就不需要使用arguments对象了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y, ...z</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x, y, z )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ) <span class=\"comment\">// 1 2 [3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>对于上面的参数<code>z</code>，我们称其为rest参数。<code>注意：rest参数只能作为最后一个参数</code>。</p>\n<h3 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h3><h4 id=\"find-和findIndex\"><a href=\"#find-和findIndex\" class=\"headerlink\" title=\"find()和findIndex()\"></a>find()和findIndex()</h4><p><code>find()</code>方法用于找出第一个符合条件的数组成员。它的参数是一个回调函数，回调函数可接受三个参数，依次为当前的值、当前的位置和原数组。所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure>\n<p><code>findIndex()</code>则是返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>\n<h4 id=\"entries-，keys-和values\"><a href=\"#entries-，keys-和values\" class=\"headerlink\" title=\"entries()，keys()和values()\"></a>entries()，keys()和values()</h4><p>ES6 提供三个新的方法<code>entries()</code>，<code>keys()</code>和<code>values()</code>用于遍历数组。<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set) <span class=\"comment\">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><p><code>Object.assign()</code>方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象上。但如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target) <span class=\"comment\">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"for-of-循环\"><a href=\"#for-of-循环\" class=\"headerlink\" title=\"for..of 循环\"></a>for..of 循环</h3><p>ES6在把JavaScript中我们熟悉的<code>for</code>和<code>for..in</code>循环组合起来的基础上，又新增了一个<code>for..of</code>循环，<code>for...of</code>循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator对象，以及字符串。</p>\n<p><code>for..in</code>在数组的键/索引上循环，而<code>for..of</code>在值上循环。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>,<span class=\"string\">\"d\"</span>,<span class=\"string\">\"e\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> idx <span class=\"keyword\">in</span> a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( idx )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 1 2 3 4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> val <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( val )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"a\" \"b\" \"c\" \"d\" \"e\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>我们在处理异步的时候通常会使用回调来处理流程，可这样会比较混乱，也不利于代码的阅读和维护(可能形成回调地狱)，而ES6为我们提供了一个名为<code>Promise</code>的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... some code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>有关<code>Promise</code>更详细的内容前面的文章<a href=\"/2018-09-05-javascript-singlethread-asynchronous.html\">JS单线程与异步</a>中有介绍。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>在ES6中我们可以通过<code>import</code>和<code>export</code>命令来帮助我们实现模块化。<code>export</code>用来导出变量或函数，<code>import</code>则是加载。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 几种导出方式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> awesome = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; foo, awesome, bar &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; .. &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; foo <span class=\"keyword\">as</span> bar &#125; <span class=\"comment\">// 导出时重命名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载方式</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">\"foo\"</span></span><br><span class=\"line\"><span class=\"comment\">// 或者：</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; foo <span class=\"keyword\">as</span> bar &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"foo\"</span></span><br></pre></td></tr></table></figure>\n<p>好了，有关ES6的总结就先写到这里，其实它还有很多特性值得我们去发掘使用，但是把最常使用的用精用熟才是硬道理。</p>\n<p><em><font color=\"#bbb\" size=\"3\">文章部分内容参考自《你不知道的JavaScript（下卷）》及阮一峰《<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a>》</font></em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>ES5标准发布后，JavaScript的发展步伐越来越快，新的特性和语法形式亟待标准化。而在经历了各种波折后，千呼万唤的ECMAScript 6（简称ES6）作为JavaScript语言的下一代标准终于在2015年发布。</p>\n<p>对于JavaScript这门语言来说，ES6 是一次激进的飞跃。简洁高效的语法解放了开发者，同时也弥补了一些最初的设计缺陷。可以说这是一场JavaScript语法的重大变革。</p>\n<p>那么ES6究竟为我们带来了哪些新的特性？它又颠覆哪些我们之前固有的语法习惯？</p>\n<p>下面这张思维导图概括了ES6的一些核心特性，虽不完全但足够日常使用。</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/29/FZsRBV.png\" alt=\"es6_mind\"></p>\n<p><em><font color=\"#bbb\" size=\"3\">思维导图来自@<a href=\"https://github.com/ljianshu/Blog\" target=\"_blank\" rel=\"noopener\">浪里行舟</a>，已获得使用许可</font></em></p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数是ES6使用率最高的特性之一。从字面上看，箭头函数简化了定义函数的写法，使用<code>=&gt;</code>替代<code>function</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>\n<p>箭头函数定义包括一个参数列表（零个或多个参数，如果参数个数不是一个的话要用<code>( .. )</code>包围起来），然后是标识<code>=&gt;</code>，函数体放在最后。 </p>\n<p>所以，在前面的代码中，箭头函数就是<code>(x,y) =&gt; x + y</code>这一部分，然后这个函数引用被赋给变量 foo。 </p>\n<p>只有在函数体的表达式个数多于1个，或者函数体包含非表达式语句的时候才需要用<code>{ .. }</code>包围。如果只有一个表达式，并且省略了包围的<code>{ .. }</code>的话，则意味着表达式前面有一个隐含的<code>return</code>，就像前面代码中展示的那样。</p>\n<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 这里列出了几种不同形式的箭头函数： </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> z = x * <span class=\"number\">2</span> + y</span><br><span class=\"line\">    y++</span><br><span class=\"line\">    x *= <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x + y + z) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f4 = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> (&#123; <span class=\"attr\">x</span>:x, <span class=\"attr\">y</span>:y &#125;)</span><br></pre></td></tr></table></figure>\n<p>箭头函数<strong>总是</strong>函数表达式；并不存在箭头函数声明。</p>\n<p>除了简化写法，箭头函数的主要设计目的是以特定的方式改变<code>this</code>的行为特性。在前面的<a href=\"/2018-11-01-javascript-this-disabuse.html\">解惑JavaScript中的this指向问题</a>中我们有介绍，ES5中<code>this</code>指向取决于函数调用方式，而箭头函数中的<code>this</code>不一样，它指向定义时的对象，这也正是多数情况下我们所希望的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5中使用var self = this这一hack方法绑定this</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 希望获取obj中的a</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(self.a)</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没问题this指向obj</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h3><p>我们知道ES5中只有全局作用域和函数作用域，并没有块级作用域的概念（有关作用域看<a href=\"/2018-10-18-javascript-scope.html\">这里</a>），这会导致几个问题：</p>\n<p>1、变量可能会发生冲突并覆盖变量值</p>\n<p>2、用来计数的循环变量泄露为全局变量，比如在for循环中。</p>\n<p>如果在ES5中需要创建一个块级作用域可以使用立即调用函数表达式（IIFE），IIFE中的变量和函数会在在执行后销毁，防止污染到外部作用域。</p>\n<p>ES6为我们带来了<code>let</code>和<code>const</code>两个命令，我们可以利用它们创建绑定到任意块的声明，我们只需要一对<code>{ .. }</code>就可以创建一个作用域。不像使用var那样声明的变量总是归属于包含函数（即全局，如果在最顶层的话）作用域，<code>let</code>声明的变量只在其所在的代码块内有效，且不存在变量提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ) <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>和<code>let</code>差不多，只不过<code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。实际应用中，使用<code>const</code>定义变量也能够明白地告诉后来的开发者该变量不可修改赋值。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><p>ES6以前，我们定义字符串模板时，需要使用<code>+</code>拼接字符串、变量以及进行换行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'hello '</span> + name + <span class=\"string\">','</span></span><br><span class=\"line\">\t<span class=\"string\">'nice to meet you!'</span></span><br></pre></td></tr></table></figure>\n<p>在ES6中我们使用反引号<strong> `</strong> 作为标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量甚至是函数调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upper</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\"><span class=\"comment\">// 模板字符串会保留所有的空格和缩进</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`hello <span class=\"subst\">$&#123;upper(name)&#125;</span>,</span></span><br><span class=\"line\"><span class=\"string\">\tnice to meet you!`</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><p>ES6允许按照一定模式，从数组和对象中提取值对变量进行赋值，这被称为解构。</p>\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">// 无须再像上面那样一个一个赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [a,b,c] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>解构赋值支持嵌套，数组的解构赋值按照位置对应取值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]]</span><br><span class=\"line\">foo <span class=\"comment\">// 1</span></span><br><span class=\"line\">bar <span class=\"comment\">// 2</span></span><br><span class=\"line\">baz <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>]</span><br><span class=\"line\">third <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, , y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y] = [<span class=\"string\">'a'</span>]</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">y <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>] <span class=\"comment\">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对象解构赋值\"><a href=\"#对象解构赋值\" class=\"headerlink\" title=\"对象解构赋值\"></a>对象解构赋值</h4><p>不同于数组按照位置解构赋值，对象的解构赋值是按照属性名来的。变量名须与属性名相同才可以取到值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">baz <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果变量名与属性不一致，需要使用如下写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br></pre></td></tr></table></figure>\n<p>对象解构赋值同样支持嵌套和指定默认值。</p>\n<p>有一点很重要需要牢记，如果是给已经声明的变量赋值，需要使用<code>()</code>包裹，不然<code>{}</code>会被当做代码块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x</span><br><span class=\"line\">(&#123;x&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串解构赋值\"><a href=\"#字符串解构赋值\" class=\"headerlink\" title=\"字符串解构赋值\"></a>字符串解构赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span></span><br><span class=\"line\">a <span class=\"comment\">// \"h\"</span></span><br><span class=\"line\">b <span class=\"comment\">// \"e\"</span></span><br><span class=\"line\">c <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">d <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">e <span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数参数解构赋值\"><a href=\"#函数参数解构赋值\" class=\"headerlink\" title=\"函数参数解构赋值\"></a>函数参数解构赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"默认参数值\"><a href=\"#默认参数值\" class=\"headerlink\" title=\"默认参数值\"></a>默认参数值</h3><p>JavaScript最常见的一个技巧就是关于设定函数参数默认值的。多年以来我们实现这一点的方式是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    x = x || <span class=\"number\">11</span></span><br><span class=\"line\">    y = y || <span class=\"number\">31</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x + y )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 11</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span> ) <span class=\"comment\">// 36</span></span><br><span class=\"line\">foo( <span class=\"literal\">null</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 17</span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你之前使用过这个模式，就会知道它很有用，但同时又有点危险，比如，如果对于一个参数你需要能够传入被认为是false（假）的值。考虑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo( <span class=\"number\">0</span>, <span class=\"number\">42</span> ) <span class=\"comment\">// 53 &lt;--哎呀，并非42</span></span><br></pre></td></tr></table></figure>\n<p>为什么？因为这里0为假，所以<code>x || 11</code>结果为11，而不是直接传入的0。要修正这个问题，有些人会选择增加更多的检查，就像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    x = (x !== <span class=\"literal\">undefined</span>) ? x : <span class=\"number\">11</span></span><br><span class=\"line\">    y = (y !== <span class=\"literal\">undefined</span>) ? y : <span class=\"number\">31</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x + y )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">0</span>, <span class=\"number\">42</span> ) <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"literal\">undefined</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 17</span></span><br></pre></td></tr></table></figure>\n<p>那么ES6新增的一个有用的语法可以改进为缺失参数赋默认值的流程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">11</span>, y = <span class=\"number\">31</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x + y )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 11</span></span><br><span class=\"line\">foo( <span class=\"number\">0</span>, <span class=\"number\">42</span> ) <span class=\"comment\">// 42</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span> ) <span class=\"comment\">// 36</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"literal\">undefined</span> ) <span class=\"comment\">// 36 &lt;-- 丢了undefined</span></span><br><span class=\"line\">foo( <span class=\"number\">5</span>, <span class=\"literal\">null</span> ) <span class=\"comment\">// 5 &lt;-- null被强制转换为0</span></span><br><span class=\"line\">foo( <span class=\"literal\">undefined</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 17 &lt;-- 丢了undefined</span></span><br><span class=\"line\">foo( <span class=\"literal\">null</span>, <span class=\"number\">6</span> ) <span class=\"comment\">// 6 &lt;-- null被强制转换为0</span></span><br></pre></td></tr></table></figure>\n<p>函数默认值可以不只是简单值，它们可以是任意合法表达式，甚至是函数调用。但是需要注意由于参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">5</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">1</span> <span class=\"comment\">// error</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> x = <span class=\"number\">2</span> <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数默认值也可以与解构赋值的默认值结合起来使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(&#123;&#125;) <span class=\"comment\">// undefined 5</span></span><br><span class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1 5</span></span><br><span class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;) <span class=\"comment\">// 1 2</span></span><br><span class=\"line\">foo() <span class=\"comment\">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"...运算符\"></a><code>...</code>运算符</h3><p>ES6 引入了一个新的运算符<code>...</code>，通常称为spread或rest（展开或收集）运算符，取决于它在哪 / 如何使用。</p>\n<h4 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h4><p>当<code>...</code>用在数组或字符串之前时，它会把这个变量“展开”为各个独立的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n<p>这一特性也方便我们替代<code>concat()</code>方法来合并数组.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [ <span class=\"number\">1</span>, ...a, <span class=\"number\">5</span> ]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ) <span class=\"comment\">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>作为扩展运算符的反向行为，<code>...</code>可以用于获取函数的多余参数并且收集到一起成为一个数组，这样就不需要使用arguments对象了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y, ...z</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( x, y, z )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ) <span class=\"comment\">// 1 2 [3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>对于上面的参数<code>z</code>，我们称其为rest参数。<code>注意：rest参数只能作为最后一个参数</code>。</p>\n<h3 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h3><h4 id=\"find-和findIndex\"><a href=\"#find-和findIndex\" class=\"headerlink\" title=\"find()和findIndex()\"></a>find()和findIndex()</h4><p><code>find()</code>方法用于找出第一个符合条件的数组成员。它的参数是一个回调函数，回调函数可接受三个参数，依次为当前的值、当前的位置和原数组。所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure>\n<p><code>findIndex()</code>则是返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>\n<h4 id=\"entries-，keys-和values\"><a href=\"#entries-，keys-和values\" class=\"headerlink\" title=\"entries()，keys()和values()\"></a>entries()，keys()和values()</h4><p>ES6 提供三个新的方法<code>entries()</code>，<code>keys()</code>和<code>values()</code>用于遍历数组。<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set) <span class=\"comment\">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><p><code>Object.assign()</code>方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象上。但如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target) <span class=\"comment\">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"for-of-循环\"><a href=\"#for-of-循环\" class=\"headerlink\" title=\"for..of 循环\"></a>for..of 循环</h3><p>ES6在把JavaScript中我们熟悉的<code>for</code>和<code>for..in</code>循环组合起来的基础上，又新增了一个<code>for..of</code>循环，<code>for...of</code>循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator对象，以及字符串。</p>\n<p><code>for..in</code>在数组的键/索引上循环，而<code>for..of</code>在值上循环。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>,<span class=\"string\">\"d\"</span>,<span class=\"string\">\"e\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> idx <span class=\"keyword\">in</span> a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( idx )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 1 2 3 4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> val <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( val )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"a\" \"b\" \"c\" \"d\" \"e\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>我们在处理异步的时候通常会使用回调来处理流程，可这样会比较混乱，也不利于代码的阅读和维护(可能形成回调地狱)，而ES6为我们提供了一个名为<code>Promise</code>的范式，可以不把回调事先传给异步任务，而是给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... some code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>有关<code>Promise</code>更详细的内容前面的文章<a href=\"/2018-09-05-javascript-singlethread-asynchronous.html\">JS单线程与异步</a>中有介绍。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>在ES6中我们可以通过<code>import</code>和<code>export</code>命令来帮助我们实现模块化。<code>export</code>用来导出变量或函数，<code>import</code>则是加载。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 几种导出方式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> awesome = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; foo, awesome, bar &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; .. &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; foo <span class=\"keyword\">as</span> bar &#125; <span class=\"comment\">// 导出时重命名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载方式</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">\"foo\"</span></span><br><span class=\"line\"><span class=\"comment\">// 或者：</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; foo <span class=\"keyword\">as</span> bar &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"foo\"</span></span><br></pre></td></tr></table></figure>\n<p>好了，有关ES6的总结就先写到这里，其实它还有很多特性值得我们去发掘使用，但是把最常使用的用精用熟才是硬道理。</p>\n<p><em><font color=\"#bbb\" size=\"3\">文章部分内容参考自《你不知道的JavaScript（下卷）》及阮一峰《<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a>》</font></em></p>\n"},{"title":"对原型及原型链的简单理解","date":"2018-11-14T14:10:51.000Z","urlname":"javascript-prototype","toc":true,"_content":"\n### JavaScript的语言特点\n\n不同于Java和C++这些基于类的面向对象语言，JavaScript是一种基于原型的面向对象语言，因为JavaScript没有类的概念。\n\n### 万物皆对象？\n\nJavaScript中一共有6种主要类型：`string`、`number`、`boolean`、`null`、`undefined`、`object`，常见到的关于**“JavaScript中万物皆对象”**的说法其实是错误的，`string`、`boolean`、`number`、`null`和`undefined`本身并不是对象，即使`typeof null`会返回`object`也是因为不同的对象在底层都表示为二进制，在JavaScript中如果二进制前三位都为0的话会被判断为`object`类型，`null`的二进制表示是全0，自然前三位也是0，所以执行`typeof`时会返回“`object`”。\n\n造成万物皆对象的错觉实际上是因为JavaScript中有许多特殊的对象子类型，也被称为内置对象，包括`String`、`Number`、`Boolean`、`Object`、`Function`、`Array`、`Date `、`RegExp`、`Error`。这些内置函数可以通过`new`调用来当作构造函数，引擎可以根据实际情况将`string`、`number`等字面量转换成对象。\n\n### &#95;&#95;proto&#95;&#95;和prototype\n\n在JavaScript中，对象是拥有属性和方法的数据。每一个对象都有一个叫做`__proto__`的内置属性，它包含对指定对象的内部原型的引用。\n\n对象的创建基本有3种方法：\n\n1、字面量创建\n\n``` javascript\nvar foo = {\n    name:blackstar\n}\n```\n\n2、构造函数\n\n``` javascript\nfunction Foo(){\n    this.name = blackstar\n}\nvar foo  = new Foo()\n```\n\n3、Object.create()\n\n``` javascript\nvar foo1 = {\n    name:blackstar\n}\nvar foo2 = Object.create(foo1)\n```\n\n补充一个小Tips:`var foo = {}`其实是`var foo = new Object()`的语法糖。相似的，`function Foo(){}`是`var Foo = new Function()`的语法糖、`var arr = []`是`var arr = new Array()`的语法糖。\n\n所以前两种方法都是借助了构造函数创建对象，这种方式创建的对象`__proto__`属性指向其构造函数的`prototype`方法。每一个函数都有一个`prototype`（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。**要注意：只有函数对象才有prototype，普通对象并没有**。\n\n说得再多可能都没有一个例子来得更直观易懂，来吧！\n\n``` javascript\nfunction Foo(){\n    this.name = 'blackstar'\n}\nvar foo = new Foo()\nconsole.log(foo.__proto__)\nconsole.log(Foo.prototype)\nconsole.log(foo.__proto__===Foo.prototype) \n```\n\n通过构造函数Foo我们创建了一个对象foo，让我们到控制台里去看一看它的`__proto__`指向什么？\n\n![shot1](https://s1.ax1x.com/2018/11/15/iv5cZ9.png)\n\n确实对象foo的`__proto__`指向了其构造函数Foo的`prototype`，Foo.prototype就是foo的原型对象。\n\n构造函数的prototype中有一个constructor属性指回到该构造函数，实例对象也有一个constructor属性指向创建它的构造函数。\n\n``` javascript\nFoo.prototype.constructor === Foo\n\nfoo.constructor === Foo\n```\n\n大部分情况`foo.__proto__ === foo.constructor.prototype`(不包括`Object.create()`创建的) ，因为`Object.create()`的作用是创建一个具有指定原型且可选择性地包含指定属性的对象，它所创建的对象的`__proto__`指向的是这个指定原型。\n\n这其中指向来指向去的关系结合图示去理解会更容易一些：\n\n![prototype](https://s1.ax1x.com/2018/11/16/ixokZQ.png)\n\n有一个很有趣的事情，`Object.__proto__===Function.prototype`，这是因为Object的构造函数是Function。\n\n### 原型链\n\n使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法，也就是说可以不必在构造函数中定义对象实例的信息，而是直接将它们添加到原型对象中。js引擎查找对象属性时先查找对象本身是否存在，如果没有就去它的原型对象上查找，由于所有的对象都有`__proto__`属性，这就形成了一个链条，也就是原型链。\n\n改造一下上面的例子：\n\n``` javascript\nfunction Foo(){\n    this.name = 'blackstar'\n}\nFoo.prototype.age = 25\nvar foo = new Foo()\nconsole.log(foo.age)\n```\n\n![shot2](https://s1.ax1x.com/2018/11/16/ixqHMt.png)\n\n我们为foo的原型对象添加age这个属性，寻找age属性时由于foo自身并没有，于是向上查找它的原型对象，诶，真好`Foo.prototype`上有，完毕。\n\n这个原型链如下图所示，原型链的顶端是`Object.prototype`，而`__proto__`最终指向`null`。\n\n![prototype chain](https://s1.ax1x.com/2018/11/16/ixoiqg.png)\n\n### 原型链继承\n\n原型对象可以让所有的对象实例共享它所包含的属性和方法，利用这一特点我们可以实现继承。\n\n``` javascript\nfunction Cat(name){\n    this.name = name\n}\nfunction Animal(){\n    this.eat = function(){\n        console.log('eat food')\n    }\n}\nCat.prototype = new Animal()\nvar miao = new Cat('miao')\nconsole.log(miao.eat())\n```\n\n![shot3](https://s1.ax1x.com/2018/11/16/izpHQe.png)\n\n通过将miao的原型对象指向Animal便继承了原本自身没有的eat方法。\n\n关于继承，这里只是引申一个简单的例子，更详细的值得另开篇章讨论，这里暂且不细说。","source":"_posts/对原型及原型链的简单理解.md","raw":"---\ntitle: 对原型及原型链的简单理解\ndate: 2018-11-14 22:10:51\nurlname: javascript-prototype\ncategories: [\"技术\"]\ntags: [\"JS\"]\ntoc: true\n---\n\n### JavaScript的语言特点\n\n不同于Java和C++这些基于类的面向对象语言，JavaScript是一种基于原型的面向对象语言，因为JavaScript没有类的概念。\n\n### 万物皆对象？\n\nJavaScript中一共有6种主要类型：`string`、`number`、`boolean`、`null`、`undefined`、`object`，常见到的关于**“JavaScript中万物皆对象”**的说法其实是错误的，`string`、`boolean`、`number`、`null`和`undefined`本身并不是对象，即使`typeof null`会返回`object`也是因为不同的对象在底层都表示为二进制，在JavaScript中如果二进制前三位都为0的话会被判断为`object`类型，`null`的二进制表示是全0，自然前三位也是0，所以执行`typeof`时会返回“`object`”。\n\n造成万物皆对象的错觉实际上是因为JavaScript中有许多特殊的对象子类型，也被称为内置对象，包括`String`、`Number`、`Boolean`、`Object`、`Function`、`Array`、`Date `、`RegExp`、`Error`。这些内置函数可以通过`new`调用来当作构造函数，引擎可以根据实际情况将`string`、`number`等字面量转换成对象。\n\n### &#95;&#95;proto&#95;&#95;和prototype\n\n在JavaScript中，对象是拥有属性和方法的数据。每一个对象都有一个叫做`__proto__`的内置属性，它包含对指定对象的内部原型的引用。\n\n对象的创建基本有3种方法：\n\n1、字面量创建\n\n``` javascript\nvar foo = {\n    name:blackstar\n}\n```\n\n2、构造函数\n\n``` javascript\nfunction Foo(){\n    this.name = blackstar\n}\nvar foo  = new Foo()\n```\n\n3、Object.create()\n\n``` javascript\nvar foo1 = {\n    name:blackstar\n}\nvar foo2 = Object.create(foo1)\n```\n\n补充一个小Tips:`var foo = {}`其实是`var foo = new Object()`的语法糖。相似的，`function Foo(){}`是`var Foo = new Function()`的语法糖、`var arr = []`是`var arr = new Array()`的语法糖。\n\n所以前两种方法都是借助了构造函数创建对象，这种方式创建的对象`__proto__`属性指向其构造函数的`prototype`方法。每一个函数都有一个`prototype`（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。**要注意：只有函数对象才有prototype，普通对象并没有**。\n\n说得再多可能都没有一个例子来得更直观易懂，来吧！\n\n``` javascript\nfunction Foo(){\n    this.name = 'blackstar'\n}\nvar foo = new Foo()\nconsole.log(foo.__proto__)\nconsole.log(Foo.prototype)\nconsole.log(foo.__proto__===Foo.prototype) \n```\n\n通过构造函数Foo我们创建了一个对象foo，让我们到控制台里去看一看它的`__proto__`指向什么？\n\n![shot1](https://s1.ax1x.com/2018/11/15/iv5cZ9.png)\n\n确实对象foo的`__proto__`指向了其构造函数Foo的`prototype`，Foo.prototype就是foo的原型对象。\n\n构造函数的prototype中有一个constructor属性指回到该构造函数，实例对象也有一个constructor属性指向创建它的构造函数。\n\n``` javascript\nFoo.prototype.constructor === Foo\n\nfoo.constructor === Foo\n```\n\n大部分情况`foo.__proto__ === foo.constructor.prototype`(不包括`Object.create()`创建的) ，因为`Object.create()`的作用是创建一个具有指定原型且可选择性地包含指定属性的对象，它所创建的对象的`__proto__`指向的是这个指定原型。\n\n这其中指向来指向去的关系结合图示去理解会更容易一些：\n\n![prototype](https://s1.ax1x.com/2018/11/16/ixokZQ.png)\n\n有一个很有趣的事情，`Object.__proto__===Function.prototype`，这是因为Object的构造函数是Function。\n\n### 原型链\n\n使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法，也就是说可以不必在构造函数中定义对象实例的信息，而是直接将它们添加到原型对象中。js引擎查找对象属性时先查找对象本身是否存在，如果没有就去它的原型对象上查找，由于所有的对象都有`__proto__`属性，这就形成了一个链条，也就是原型链。\n\n改造一下上面的例子：\n\n``` javascript\nfunction Foo(){\n    this.name = 'blackstar'\n}\nFoo.prototype.age = 25\nvar foo = new Foo()\nconsole.log(foo.age)\n```\n\n![shot2](https://s1.ax1x.com/2018/11/16/ixqHMt.png)\n\n我们为foo的原型对象添加age这个属性，寻找age属性时由于foo自身并没有，于是向上查找它的原型对象，诶，真好`Foo.prototype`上有，完毕。\n\n这个原型链如下图所示，原型链的顶端是`Object.prototype`，而`__proto__`最终指向`null`。\n\n![prototype chain](https://s1.ax1x.com/2018/11/16/ixoiqg.png)\n\n### 原型链继承\n\n原型对象可以让所有的对象实例共享它所包含的属性和方法，利用这一特点我们可以实现继承。\n\n``` javascript\nfunction Cat(name){\n    this.name = name\n}\nfunction Animal(){\n    this.eat = function(){\n        console.log('eat food')\n    }\n}\nCat.prototype = new Animal()\nvar miao = new Cat('miao')\nconsole.log(miao.eat())\n```\n\n![shot3](https://s1.ax1x.com/2018/11/16/izpHQe.png)\n\n通过将miao的原型对象指向Animal便继承了原本自身没有的eat方法。\n\n关于继承，这里只是引申一个简单的例子，更详细的值得另开篇章讨论，这里暂且不细说。","slug":"对原型及原型链的简单理解","published":1,"updated":"2018-11-16T15:30:15.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06sz0005xl69os6vr4nq","content":"<h3 id=\"JavaScript的语言特点\"><a href=\"#JavaScript的语言特点\" class=\"headerlink\" title=\"JavaScript的语言特点\"></a>JavaScript的语言特点</h3><p>不同于Java和C++这些基于类的面向对象语言，JavaScript是一种基于原型的面向对象语言，因为JavaScript没有类的概念。</p>\n<h3 id=\"万物皆对象？\"><a href=\"#万物皆对象？\" class=\"headerlink\" title=\"万物皆对象？\"></a>万物皆对象？</h3><p>JavaScript中一共有6种主要类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>object</code>，常见到的关于<strong>“JavaScript中万物皆对象”</strong>的说法其实是错误的，<code>string</code>、<code>boolean</code>、<code>number</code>、<code>null</code>和<code>undefined</code>本身并不是对象，即使<code>typeof null</code>会返回<code>object</code>也是因为不同的对象在底层都表示为二进制，在JavaScript中如果二进制前三位都为0的话会被判断为<code>object</code>类型，<code>null</code>的二进制表示是全0，自然前三位也是0，所以执行<code>typeof</code>时会返回“<code>object</code>”。</p>\n<p>造成万物皆对象的错觉实际上是因为JavaScript中有许多特殊的对象子类型，也被称为内置对象，包括<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>。这些内置函数可以通过<code>new</code>调用来当作构造函数，引擎可以根据实际情况将<code>string</code>、<code>number</code>等字面量转换成对象。</p>\n<h3 id=\"95-95-proto-95-95-和prototype\"><a href=\"#95-95-proto-95-95-和prototype\" class=\"headerlink\" title=\"&#95;&#95;proto&#95;&#95;和prototype\"></a>&#95;&#95;proto&#95;&#95;和prototype</h3><p>在JavaScript中，对象是拥有属性和方法的数据。每一个对象都有一个叫做<code>__proto__</code>的内置属性，它包含对指定对象的内部原型的引用。</p>\n<p>对象的创建基本有3种方法：</p>\n<p>1、字面量创建</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    name:blackstar</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = blackstar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo  = <span class=\"keyword\">new</span> Foo()</span><br></pre></td></tr></table></figure>\n<p>3、Object.create()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo1 = &#123;</span><br><span class=\"line\">    name:blackstar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"built_in\">Object</span>.create(foo1)</span><br></pre></td></tr></table></figure>\n<p>补充一个小Tips:<code>var foo = {}</code>其实是<code>var foo = new Object()</code>的语法糖。相似的，<code>function Foo(){}</code>是<code>var Foo = new Function()</code>的语法糖、<code>var arr = []</code>是<code>var arr = new Array()</code>的语法糖。</p>\n<p>所以前两种方法都是借助了构造函数创建对象，这种方式创建的对象<code>__proto__</code>属性指向其构造函数的<code>prototype</code>方法。每一个函数都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<strong>要注意：只有函数对象才有prototype，普通对象并没有</strong>。</p>\n<p>说得再多可能都没有一个例子来得更直观易懂，来吧！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Foo.prototype)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__===Foo.prototype)</span><br></pre></td></tr></table></figure>\n<p>通过构造函数Foo我们创建了一个对象foo，让我们到控制台里去看一看它的<code>__proto__</code>指向什么？</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/15/iv5cZ9.png\" alt=\"shot1\"></p>\n<p>确实对象foo的<code>__proto__</code>指向了其构造函数Foo的<code>prototype</code>，Foo.prototype就是foo的原型对象。</p>\n<p>构造函数的prototype中有一个constructor属性指回到该构造函数，实例对象也有一个constructor属性指向创建它的构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.constructor === Foo</span><br><span class=\"line\"></span><br><span class=\"line\">foo.constructor === Foo</span><br></pre></td></tr></table></figure>\n<p>大部分情况<code>foo.__proto__ === foo.constructor.prototype</code>(不包括<code>Object.create()</code>创建的) ，因为<code>Object.create()</code>的作用是创建一个具有指定原型且可选择性地包含指定属性的对象，它所创建的对象的<code>__proto__</code>指向的是这个指定原型。</p>\n<p>这其中指向来指向去的关系结合图示去理解会更容易一些：</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/ixokZQ.png\" alt=\"prototype\"></p>\n<p>有一个很有趣的事情，<code>Object.__proto__===Function.prototype</code>，这是因为Object的构造函数是Function。</p>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法，也就是说可以不必在构造函数中定义对象实例的信息，而是直接将它们添加到原型对象中。js引擎查找对象属性时先查找对象本身是否存在，如果没有就去它的原型对象上查找，由于所有的对象都有<code>__proto__</code>属性，这就形成了一个链条，也就是原型链。</p>\n<p>改造一下上面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype.age = <span class=\"number\">25</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.age)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/ixqHMt.png\" alt=\"shot2\"></p>\n<p>我们为foo的原型对象添加age这个属性，寻找age属性时由于foo自身并没有，于是向上查找它的原型对象，诶，真好<code>Foo.prototype</code>上有，完毕。</p>\n<p>这个原型链如下图所示，原型链的顶端是<code>Object.prototype</code>，而<code>__proto__</code>最终指向<code>null</code>。</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/ixoiqg.png\" alt=\"prototype chain\"></p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><p>原型对象可以让所有的对象实例共享它所包含的属性和方法，利用这一特点我们可以实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat food'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\"><span class=\"keyword\">var</span> miao = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'miao'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(miao.eat())</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/izpHQe.png\" alt=\"shot3\"></p>\n<p>通过将miao的原型对象指向Animal便继承了原本自身没有的eat方法。</p>\n<p>关于继承，这里只是引申一个简单的例子，更详细的值得另开篇章讨论，这里暂且不细说。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JavaScript的语言特点\"><a href=\"#JavaScript的语言特点\" class=\"headerlink\" title=\"JavaScript的语言特点\"></a>JavaScript的语言特点</h3><p>不同于Java和C++这些基于类的面向对象语言，JavaScript是一种基于原型的面向对象语言，因为JavaScript没有类的概念。</p>\n<h3 id=\"万物皆对象？\"><a href=\"#万物皆对象？\" class=\"headerlink\" title=\"万物皆对象？\"></a>万物皆对象？</h3><p>JavaScript中一共有6种主要类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>object</code>，常见到的关于<strong>“JavaScript中万物皆对象”</strong>的说法其实是错误的，<code>string</code>、<code>boolean</code>、<code>number</code>、<code>null</code>和<code>undefined</code>本身并不是对象，即使<code>typeof null</code>会返回<code>object</code>也是因为不同的对象在底层都表示为二进制，在JavaScript中如果二进制前三位都为0的话会被判断为<code>object</code>类型，<code>null</code>的二进制表示是全0，自然前三位也是0，所以执行<code>typeof</code>时会返回“<code>object</code>”。</p>\n<p>造成万物皆对象的错觉实际上是因为JavaScript中有许多特殊的对象子类型，也被称为内置对象，包括<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>。这些内置函数可以通过<code>new</code>调用来当作构造函数，引擎可以根据实际情况将<code>string</code>、<code>number</code>等字面量转换成对象。</p>\n<h3 id=\"95-95-proto-95-95-和prototype\"><a href=\"#95-95-proto-95-95-和prototype\" class=\"headerlink\" title=\"&#95;&#95;proto&#95;&#95;和prototype\"></a>&#95;&#95;proto&#95;&#95;和prototype</h3><p>在JavaScript中，对象是拥有属性和方法的数据。每一个对象都有一个叫做<code>__proto__</code>的内置属性，它包含对指定对象的内部原型的引用。</p>\n<p>对象的创建基本有3种方法：</p>\n<p>1、字面量创建</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    name:blackstar</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、构造函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = blackstar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo  = <span class=\"keyword\">new</span> Foo()</span><br></pre></td></tr></table></figure>\n<p>3、Object.create()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo1 = &#123;</span><br><span class=\"line\">    name:blackstar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"built_in\">Object</span>.create(foo1)</span><br></pre></td></tr></table></figure>\n<p>补充一个小Tips:<code>var foo = {}</code>其实是<code>var foo = new Object()</code>的语法糖。相似的，<code>function Foo(){}</code>是<code>var Foo = new Function()</code>的语法糖、<code>var arr = []</code>是<code>var arr = new Array()</code>的语法糖。</p>\n<p>所以前两种方法都是借助了构造函数创建对象，这种方式创建的对象<code>__proto__</code>属性指向其构造函数的<code>prototype</code>方法。每一个函数都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<strong>要注意：只有函数对象才有prototype，普通对象并没有</strong>。</p>\n<p>说得再多可能都没有一个例子来得更直观易懂，来吧！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Foo.prototype)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__===Foo.prototype)</span><br></pre></td></tr></table></figure>\n<p>通过构造函数Foo我们创建了一个对象foo，让我们到控制台里去看一看它的<code>__proto__</code>指向什么？</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/15/iv5cZ9.png\" alt=\"shot1\"></p>\n<p>确实对象foo的<code>__proto__</code>指向了其构造函数Foo的<code>prototype</code>，Foo.prototype就是foo的原型对象。</p>\n<p>构造函数的prototype中有一个constructor属性指回到该构造函数，实例对象也有一个constructor属性指向创建它的构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.constructor === Foo</span><br><span class=\"line\"></span><br><span class=\"line\">foo.constructor === Foo</span><br></pre></td></tr></table></figure>\n<p>大部分情况<code>foo.__proto__ === foo.constructor.prototype</code>(不包括<code>Object.create()</code>创建的) ，因为<code>Object.create()</code>的作用是创建一个具有指定原型且可选择性地包含指定属性的对象，它所创建的对象的<code>__proto__</code>指向的是这个指定原型。</p>\n<p>这其中指向来指向去的关系结合图示去理解会更容易一些：</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/ixokZQ.png\" alt=\"prototype\"></p>\n<p>有一个很有趣的事情，<code>Object.__proto__===Function.prototype</code>，这是因为Object的构造函数是Function。</p>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法，也就是说可以不必在构造函数中定义对象实例的信息，而是直接将它们添加到原型对象中。js引擎查找对象属性时先查找对象本身是否存在，如果没有就去它的原型对象上查找，由于所有的对象都有<code>__proto__</code>属性，这就形成了一个链条，也就是原型链。</p>\n<p>改造一下上面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'blackstar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype.age = <span class=\"number\">25</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.age)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/ixqHMt.png\" alt=\"shot2\"></p>\n<p>我们为foo的原型对象添加age这个属性，寻找age属性时由于foo自身并没有，于是向上查找它的原型对象，诶，真好<code>Foo.prototype</code>上有，完毕。</p>\n<p>这个原型链如下图所示，原型链的顶端是<code>Object.prototype</code>，而<code>__proto__</code>最终指向<code>null</code>。</p>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/ixoiqg.png\" alt=\"prototype chain\"></p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><p>原型对象可以让所有的对象实例共享它所包含的属性和方法，利用这一特点我们可以实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat food'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\"><span class=\"keyword\">var</span> miao = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'miao'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(miao.eat())</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s1.ax1x.com/2018/11/16/izpHQe.png\" alt=\"shot3\"></p>\n<p>通过将miao的原型对象指向Animal便继承了原本自身没有的eat方法。</p>\n<p>关于继承，这里只是引申一个简单的例子，更详细的值得另开篇章讨论，这里暂且不细说。</p>\n"},{"title":"善始者实繁，而克终者盖寡","date":"2018-06-24T00:24:00.000Z","urlname":"keep-going-on","_content":"\n在经历换工作与女儿出生的忙碌之后，2018已经悄然来到了六月底，距离建立个人博客也过去了近两年的时间。从当初希望用博客记录生活与工作的愿景来看，自己并没有去认真执行，而随着工作的累积愈发的意识到技术博客对于一名开发的重要性。\n\n技术的提高一方面需要在工作中熟能生巧，却也少不了空闲后的整理回顾以及对问题更深层次的探索研究。在博客上提出问题、记录整理问题甚至是讨论问题，一段时间后回过头来看时间线会更加清晰明了。\n\n过去在工作中对于前端技术的使用一直处于比较浅薄的阶段，如今在新的公司接触了较为复杂的项目，涉及了很多项目配置、硬件支持、混合应用开发、本地SQL语句查询数据和Node.js相关的技术运用，对于vuex这样的状态管理机制也在项目中有较为成熟的使用，而逐渐熟练的ES6语法的使用也有效地提高了工作效率。\n\n种一颗树最好的时间是十年前，其次是现在，这是把握当下。而“善始者实繁 克终者盖寡”，这句话是当年魏征写给唐太宗李世民的，意思是：许多人做一件事，开始做的好的有很多，但能够坚持把整一件事做好的就寥寥无几了，这是坚持。我相信，把握机会加上持之以恒就一定能把事情做好。\n\n下面立flag:\n\n> * 定期将工作中遇到的问题以及使用的新技术整理至博客\n> * 制定工作规范\n> * 深入vue、vuex的学习使用\n> * 尝试封装组件库或开发插件\n> * 练吉他，每天爬爬格子，周末加长弹奏时间\n \n结尾大Ibanez镇楼\n\n![Ibanez](https://s1.ax1x.com/2018/10/15/iaMTbD.jpg)","source":"_posts/善始者实繁，而克终者盖寡.md","raw":"---\ntitle: 善始者实繁，而克终者盖寡\ndate: 2018-06-24 08:24:00\nurlname: keep-going-on\ncategories: [\"生活\"]\ntags: [\"生活\"]\n---\n\n在经历换工作与女儿出生的忙碌之后，2018已经悄然来到了六月底，距离建立个人博客也过去了近两年的时间。从当初希望用博客记录生活与工作的愿景来看，自己并没有去认真执行，而随着工作的累积愈发的意识到技术博客对于一名开发的重要性。\n\n技术的提高一方面需要在工作中熟能生巧，却也少不了空闲后的整理回顾以及对问题更深层次的探索研究。在博客上提出问题、记录整理问题甚至是讨论问题，一段时间后回过头来看时间线会更加清晰明了。\n\n过去在工作中对于前端技术的使用一直处于比较浅薄的阶段，如今在新的公司接触了较为复杂的项目，涉及了很多项目配置、硬件支持、混合应用开发、本地SQL语句查询数据和Node.js相关的技术运用，对于vuex这样的状态管理机制也在项目中有较为成熟的使用，而逐渐熟练的ES6语法的使用也有效地提高了工作效率。\n\n种一颗树最好的时间是十年前，其次是现在，这是把握当下。而“善始者实繁 克终者盖寡”，这句话是当年魏征写给唐太宗李世民的，意思是：许多人做一件事，开始做的好的有很多，但能够坚持把整一件事做好的就寥寥无几了，这是坚持。我相信，把握机会加上持之以恒就一定能把事情做好。\n\n下面立flag:\n\n> * 定期将工作中遇到的问题以及使用的新技术整理至博客\n> * 制定工作规范\n> * 深入vue、vuex的学习使用\n> * 尝试封装组件库或开发插件\n> * 练吉他，每天爬爬格子，周末加长弹奏时间\n \n结尾大Ibanez镇楼\n\n![Ibanez](https://s1.ax1x.com/2018/10/15/iaMTbD.jpg)","slug":"善始者实繁，而克终者盖寡","published":1,"updated":"2018-11-16T15:30:15.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06t40006xl690cna9upc","content":"<p>在经历换工作与女儿出生的忙碌之后，2018已经悄然来到了六月底，距离建立个人博客也过去了近两年的时间。从当初希望用博客记录生活与工作的愿景来看，自己并没有去认真执行，而随着工作的累积愈发的意识到技术博客对于一名开发的重要性。</p>\n<p>技术的提高一方面需要在工作中熟能生巧，却也少不了空闲后的整理回顾以及对问题更深层次的探索研究。在博客上提出问题、记录整理问题甚至是讨论问题，一段时间后回过头来看时间线会更加清晰明了。</p>\n<p>过去在工作中对于前端技术的使用一直处于比较浅薄的阶段，如今在新的公司接触了较为复杂的项目，涉及了很多项目配置、硬件支持、混合应用开发、本地SQL语句查询数据和Node.js相关的技术运用，对于vuex这样的状态管理机制也在项目中有较为成熟的使用，而逐渐熟练的ES6语法的使用也有效地提高了工作效率。</p>\n<p>种一颗树最好的时间是十年前，其次是现在，这是把握当下。而“善始者实繁 克终者盖寡”，这句话是当年魏征写给唐太宗李世民的，意思是：许多人做一件事，开始做的好的有很多，但能够坚持把整一件事做好的就寥寥无几了，这是坚持。我相信，把握机会加上持之以恒就一定能把事情做好。</p>\n<p>下面立flag:</p>\n<blockquote>\n<ul>\n<li>定期将工作中遇到的问题以及使用的新技术整理至博客</li>\n<li>制定工作规范</li>\n<li>深入vue、vuex的学习使用</li>\n<li>尝试封装组件库或开发插件</li>\n<li>练吉他，每天爬爬格子，周末加长弹奏时间</li>\n</ul>\n</blockquote>\n<p>结尾大Ibanez镇楼</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMTbD.jpg\" alt=\"Ibanez\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在经历换工作与女儿出生的忙碌之后，2018已经悄然来到了六月底，距离建立个人博客也过去了近两年的时间。从当初希望用博客记录生活与工作的愿景来看，自己并没有去认真执行，而随着工作的累积愈发的意识到技术博客对于一名开发的重要性。</p>\n<p>技术的提高一方面需要在工作中熟能生巧，却也少不了空闲后的整理回顾以及对问题更深层次的探索研究。在博客上提出问题、记录整理问题甚至是讨论问题，一段时间后回过头来看时间线会更加清晰明了。</p>\n<p>过去在工作中对于前端技术的使用一直处于比较浅薄的阶段，如今在新的公司接触了较为复杂的项目，涉及了很多项目配置、硬件支持、混合应用开发、本地SQL语句查询数据和Node.js相关的技术运用，对于vuex这样的状态管理机制也在项目中有较为成熟的使用，而逐渐熟练的ES6语法的使用也有效地提高了工作效率。</p>\n<p>种一颗树最好的时间是十年前，其次是现在，这是把握当下。而“善始者实繁 克终者盖寡”，这句话是当年魏征写给唐太宗李世民的，意思是：许多人做一件事，开始做的好的有很多，但能够坚持把整一件事做好的就寥寥无几了，这是坚持。我相信，把握机会加上持之以恒就一定能把事情做好。</p>\n<p>下面立flag:</p>\n<blockquote>\n<ul>\n<li>定期将工作中遇到的问题以及使用的新技术整理至博客</li>\n<li>制定工作规范</li>\n<li>深入vue、vuex的学习使用</li>\n<li>尝试封装组件库或开发插件</li>\n<li>练吉他，每天爬爬格子，周末加长弹奏时间</li>\n</ul>\n</blockquote>\n<p>结尾大Ibanez镇楼</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMTbD.jpg\" alt=\"Ibanez\"></p>\n"},{"title":"时间烙下的是举手投足的习惯","date":"2018-11-26T14:46:15.000Z","urlname":"colleage-memories","cover":"https://s1.ax1x.com/2018/11/26/FAHKf0.jpg","_content":"\n没想到再回到这里已经是两年后。\n\n时间这东西很奇妙，它既会让你觉得记忆已经渐渐模糊，又能在一瞬间把你拉回到从前。人生有多少个四年的机会可以让你在一个环境中不断重复相同的模式和轨迹，那条条街道，层层楼宇，多少次在夜晚回忆感慨旧时光不在，可再度站在校园的时候竟然不会有一丁点的疏离感，仿佛从未离开过。每一个角落都那么熟悉，每一个场景都好似昨日重现。\n\n终于明白，有些东西它不会被时间带走，举手投足间的习惯早已随着那些点点滴滴深刻地浸透在你的骨头里。\n\n![colleage-memories](https://s1.ax1x.com/2018/12/01/FnLG4S.jpg)","source":"_posts/时间烙下的是举手投足的习惯.md","raw":"---\ntitle: 时间烙下的是举手投足的习惯\ndate: 2018-11-26 22:46:15\nurlname: colleage-memories\ncover: \"https://s1.ax1x.com/2018/11/26/FAHKf0.jpg\"\ncategories: [\"生活\"]\ntags: [\"生活\"]\n---\n\n没想到再回到这里已经是两年后。\n\n时间这东西很奇妙，它既会让你觉得记忆已经渐渐模糊，又能在一瞬间把你拉回到从前。人生有多少个四年的机会可以让你在一个环境中不断重复相同的模式和轨迹，那条条街道，层层楼宇，多少次在夜晚回忆感慨旧时光不在，可再度站在校园的时候竟然不会有一丁点的疏离感，仿佛从未离开过。每一个角落都那么熟悉，每一个场景都好似昨日重现。\n\n终于明白，有些东西它不会被时间带走，举手投足间的习惯早已随着那些点点滴滴深刻地浸透在你的骨头里。\n\n![colleage-memories](https://s1.ax1x.com/2018/12/01/FnLG4S.jpg)","slug":"时间烙下的是举手投足的习惯","published":1,"updated":"2018-12-01T14:26:34.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06t80009xl69zcfiqpti","content":"<p>没想到再回到这里已经是两年后。</p>\n<p>时间这东西很奇妙，它既会让你觉得记忆已经渐渐模糊，又能在一瞬间把你拉回到从前。人生有多少个四年的机会可以让你在一个环境中不断重复相同的模式和轨迹，那条条街道，层层楼宇，多少次在夜晚回忆感慨旧时光不在，可再度站在校园的时候竟然不会有一丁点的疏离感，仿佛从未离开过。每一个角落都那么熟悉，每一个场景都好似昨日重现。</p>\n<p>终于明白，有些东西它不会被时间带走，举手投足间的习惯早已随着那些点点滴滴深刻地浸透在你的骨头里。</p>\n<p><img src=\"https://s1.ax1x.com/2018/12/01/FnLG4S.jpg\" alt=\"colleage-memories\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>没想到再回到这里已经是两年后。</p>\n<p>时间这东西很奇妙，它既会让你觉得记忆已经渐渐模糊，又能在一瞬间把你拉回到从前。人生有多少个四年的机会可以让你在一个环境中不断重复相同的模式和轨迹，那条条街道，层层楼宇，多少次在夜晚回忆感慨旧时光不在，可再度站在校园的时候竟然不会有一丁点的疏离感，仿佛从未离开过。每一个角落都那么熟悉，每一个场景都好似昨日重现。</p>\n<p>终于明白，有些东西它不会被时间带走，举手投足间的习惯早已随着那些点点滴滴深刻地浸透在你的骨头里。</p>\n<p><img src=\"https://s1.ax1x.com/2018/12/01/FnLG4S.jpg\" alt=\"colleage-memories\"></p>\n"},{"title":"微信小程序那些你不知道的事儿","date":"2018-09-20T12:54:19.000Z","urlname":"something-about-miniProgram","_content":"\n最近从零开始开发了一个微信小程序商城，一个月的时间下来也算颇有心得，于是想拿出来分享一下。本来想给文章标题起为“微信小程序奇技淫巧”，但是一查，奇技淫巧的意思是指过于奇巧，让人着迷，却又无益的技艺与制品。但咱们这可不是无意义瞎扯淡，不能这么叫，所以咱们就来聊聊小程序那些你知道或不知道的事儿，没准就能帮到困惑中的你。\n\n#### 1、button边框样式修改\n\n小程序的button组件可能是使用率最高的组件之一了，如果我们想要修改边框样式时直接修改button的css是没有效果的，需要这样：\n\n``` css\nbutton::after{\n     border:none;\n     border-radius:0;\n}\n```\n\n#### 2、事件传参\n\n小程序中我们通常使用`bindtap`来绑定事件，但是绑定的方法并不能直接传参，我们需要借助标签的`data-*`属性，例如：\n\n```html\n<view data-id=\"1\" bindtap=\"openTab\"> Click me! </view>\n```\n\n给`openTab`传递了一个`id=1`的参数，在方法函数内我们要取到这个参数也很简单\n\n``` javascript\nopenTab(event) {\n    // 获取参数id\n    console.log(event.currentTarget.dataset.id)\n}\n```\n\n#### 3、阻止冒泡\n\n事件分为冒泡事件和非冒泡事件，当一个组件上的冒泡事件被触发后，该事件会向父节点传递，如不希望事件冒泡只需用`catch`替换掉`bind`即可，`bindtap`对应`catchtap`。\n\n#### 4、改变数组值\n\n修改静态的数组元素\n\n``` javascript\nthis.setData({\n    'array[0].text':'changed data'\n})\n```\n\n如果索引的值是动态改变的需要使用这种写法：\n\n``` javascript\nlet item = 'array['+index+'].text'\nthis.setData({\n    [item]:'changed data'\n})\n```\n\n#### 5、跳转到tabBar页面\n\n当要跳转到tabBar页面时，使用`wx.navigateTo`控制是无效的，这个时候需要使用`wx.switchTab`方法，并且`url`不可以有参数。\n\n#### 6、用户拒绝授权后重新发起授权\n\n由于小程序不再支持`wx.openSetting`方法，因此再度引导用户打开授权需要借助`button`组件的`open-type`\t属性：\n\n``` html\n<button open-type=\"openSetting\" bindopensetting=\"handlerSetting\">去授权</button>\n```\n\n`openSetting`打开授权页，`bindopensetting`用来绑定打开授权设置页后的回调方法。\n\n#### 7、组件传值\n\n组件接受外部传入数据，但是需在`Component`构造器中定义`properties`才能使用，这点有点类似于`vue`的`props`。\n\n``` html\n<component param-a=\"1\" param-b=\"hello\"></component>\n```\n\n``` javascript\nComponent({\n    properties: {\n        //注意这里需要使用驼峰写法\n        paramA: Number,\n        paramB: String,\n    }\n})\n```\n\n#### 8、调用组件方法\n\n需要借助id选择器选择组件实例节点，调用组件方法\n\n``` html\n<component id=\"nav\" param-a=\"1\" param-b=\"hello\"></component>\n```\n\n``` javascript\nthis.selectComponent(\"#nav\").getList()\n```\n\n#### 9、获取页面路径及参数\n\n``` javascript\n// 获取页面路径\nthis.route\n// 获取参数\nthis.options\n```\n\n#### 10、禁止页面上下拉出空白\n\n在ios手机上上下滑动页面会被拉出一块空白区域，如果不想要这种效果可以在json文件中配置`\"disableScroll\":true`，但如果设置了这个配置会导致下拉刷新方法`onPullDownRefresh`失效。\n\n#### 11、阻止遮罩层滑动穿透\n\n遮罩层也是使用频率比较高的组件，但遮罩层很容易产生滑动穿透的问题，即当我们触摸滑动遮罩层的时候，遮罩层下面的页面也会跟着滑动，如何来解决这个问题，我们来分几种情况讨论：\n\n（1）底层页面不需要下拉刷新，那只要像上一小节所讲设置`\"disableScroll\":true`就好了。\n\n（2）底层页面需要使用下拉刷新，遮罩层上无滚动，那么添加一个`catchtouchmove`事件:\n\n``` html\n<view class=\"mask\" catchtouchmove=\"true\"></view>\n```\n\n这样就阻止了触摸滑动及事件冒泡，达到阻止滑动穿透的效果。\n\n（3）底层页面需要使用下拉刷新，遮罩层上有可滚动的区域，那么可以在遮罩层显示的时候动态的给下面的页面添加一个`class`使其定位固定不可滑动，样式可以是这样：\n\n```css\n.fix{\n    top:0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    position: fixed;\n    z-index: 0;\n}\n```\n\n#### 12、手风琴菜单\n\n想实现一个手风琴下拉菜单动效？其实很简单，只需动态设置子菜单的高度结合`transition`过渡效果就可以实现了。\n\n``` html\n<view class=\"sub-nav\" style=\"{{active?style:'height:0;transition:height 0.5s;'}}\">\n```\n\n``` javascript\nlet style = 'height:'+subNav.length*50+'rpx;transition:height 0.5s;'\n```\n\n#### 13、封装request请求\n\n小程序提供的`request`请求API在项目中使用时如果不二次封装一下总觉得有些繁重，看过了网上几个不同的封装方式总觉得有些不满意，于是反复改动了几次得到了一个自己觉得用起来比较方便的版本，在这里分享出来。\n\n```javascript\n// request.js\n// GET请求\nfunction GET(url,data) {\n    return request('GET',url,data)\n}\n// POST请求\nfunction POST(url,data) {\n    return request('POST',url,data)\n}\n\nfunction request(method,url,data) {\n    let token = wx.getStorageSync('tokenInfo') || ''\n    return new Promise((resolve, reject) => {\n        wx.request({\n            url: url,\n            data: data,\n            method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\n            // 设置请求的 header\n            header: {\n                Authorization: `${token.token_type} ${token.access_token}`\n            },\n            success: res=> {\n                if(res.data){\n                    resolve(res)\n                } else {\n                    reject(res)\n                }\n            },\n            fail: ()=> {\n                wx.showToast({\n                    title: '网络错误，请检查后重试',\n                    icon: 'none',\n                    duration: 2000\n                })\n            }\n        })\n    })\n}\n\nmodule.exports = {\n    GET: GET,\n    POST: POST\n}\n```\n\n``` javascript\n//app.js\nconst request = require(\"/utils/request.js\")\nApp({\n    // 全局声明https请求方法\n    http:request\n})\n```\n\n``` javascript\n//获取应用实例\nconst app = getApp()\nPage({\n    data: {\n        code: ''\n    },\n    onLoad() {\n        app.http.GET('https://...',{name:'',pwd:''}).then((res)=>{\n            // 成功\n        }).catch((res)=>{\n            // 异常\n        })\n    }\n})\n\n```\n\n#### 14、日期转换\n\nIOS系统中`new Date()`方法不支持对'2018-04-12 23:00:00'这样的日期进行转换，需要对字符串进行正则替换`replace(/-/g, '/')`。\n\n#### 15、“分享监听”能力调整\n\n出于倡导用户主动分享小程序的考虑，微信官方不再支持`onShareAppMessage`分享事件函数的回调参数：`success`、`fail`、`complete`，因此开发者以后将无法通过这几个回调来获取用户的分享结果，如果需求有涉及请尽快调整，以免受到影响。\n\n#### 16、getWXACodeUnlimit获取小程序码报错\n\n使用`getWXACodeUnlimit`接口获取小程序码时，要注意`scene`参数最多接收32个字符，超出会报错。\n\n#### 17、自定义顶部导航栏\n\n可在`app.json`的`window`属性下通过`\"navigationStyle\":\"custom\"`自定义导航栏。\n\n```json\n\"window\":{\n    \"backgroundTextStyle\":\"dark\",\n    \"navigationBarBackgroundColor\": \"#3996F2\",\n    \"navigationBarTitleText\": \"物恋便利\",\n    \"navigationBarTextStyle\":\"white\",\n    \"navigationStyle\":\"custom\"\n}\n```\n\n实际上就是去除了默认的导航栏但是会保留右上角胶囊按钮，标题什么的也没有了，需要开发者自己编写顶部导航。\n\n\n\n\n\n\n","source":"_posts/微信小程序那些你不知道的事儿.md","raw":"---\ntitle: 微信小程序那些你不知道的事儿\ndate: 2018-09-20 20:54:19\nurlname: something-about-miniProgram\ncategories: [\"技术\"]\ntags: [\"小程序\"]\n---\n\n最近从零开始开发了一个微信小程序商城，一个月的时间下来也算颇有心得，于是想拿出来分享一下。本来想给文章标题起为“微信小程序奇技淫巧”，但是一查，奇技淫巧的意思是指过于奇巧，让人着迷，却又无益的技艺与制品。但咱们这可不是无意义瞎扯淡，不能这么叫，所以咱们就来聊聊小程序那些你知道或不知道的事儿，没准就能帮到困惑中的你。\n\n#### 1、button边框样式修改\n\n小程序的button组件可能是使用率最高的组件之一了，如果我们想要修改边框样式时直接修改button的css是没有效果的，需要这样：\n\n``` css\nbutton::after{\n     border:none;\n     border-radius:0;\n}\n```\n\n#### 2、事件传参\n\n小程序中我们通常使用`bindtap`来绑定事件，但是绑定的方法并不能直接传参，我们需要借助标签的`data-*`属性，例如：\n\n```html\n<view data-id=\"1\" bindtap=\"openTab\"> Click me! </view>\n```\n\n给`openTab`传递了一个`id=1`的参数，在方法函数内我们要取到这个参数也很简单\n\n``` javascript\nopenTab(event) {\n    // 获取参数id\n    console.log(event.currentTarget.dataset.id)\n}\n```\n\n#### 3、阻止冒泡\n\n事件分为冒泡事件和非冒泡事件，当一个组件上的冒泡事件被触发后，该事件会向父节点传递，如不希望事件冒泡只需用`catch`替换掉`bind`即可，`bindtap`对应`catchtap`。\n\n#### 4、改变数组值\n\n修改静态的数组元素\n\n``` javascript\nthis.setData({\n    'array[0].text':'changed data'\n})\n```\n\n如果索引的值是动态改变的需要使用这种写法：\n\n``` javascript\nlet item = 'array['+index+'].text'\nthis.setData({\n    [item]:'changed data'\n})\n```\n\n#### 5、跳转到tabBar页面\n\n当要跳转到tabBar页面时，使用`wx.navigateTo`控制是无效的，这个时候需要使用`wx.switchTab`方法，并且`url`不可以有参数。\n\n#### 6、用户拒绝授权后重新发起授权\n\n由于小程序不再支持`wx.openSetting`方法，因此再度引导用户打开授权需要借助`button`组件的`open-type`\t属性：\n\n``` html\n<button open-type=\"openSetting\" bindopensetting=\"handlerSetting\">去授权</button>\n```\n\n`openSetting`打开授权页，`bindopensetting`用来绑定打开授权设置页后的回调方法。\n\n#### 7、组件传值\n\n组件接受外部传入数据，但是需在`Component`构造器中定义`properties`才能使用，这点有点类似于`vue`的`props`。\n\n``` html\n<component param-a=\"1\" param-b=\"hello\"></component>\n```\n\n``` javascript\nComponent({\n    properties: {\n        //注意这里需要使用驼峰写法\n        paramA: Number,\n        paramB: String,\n    }\n})\n```\n\n#### 8、调用组件方法\n\n需要借助id选择器选择组件实例节点，调用组件方法\n\n``` html\n<component id=\"nav\" param-a=\"1\" param-b=\"hello\"></component>\n```\n\n``` javascript\nthis.selectComponent(\"#nav\").getList()\n```\n\n#### 9、获取页面路径及参数\n\n``` javascript\n// 获取页面路径\nthis.route\n// 获取参数\nthis.options\n```\n\n#### 10、禁止页面上下拉出空白\n\n在ios手机上上下滑动页面会被拉出一块空白区域，如果不想要这种效果可以在json文件中配置`\"disableScroll\":true`，但如果设置了这个配置会导致下拉刷新方法`onPullDownRefresh`失效。\n\n#### 11、阻止遮罩层滑动穿透\n\n遮罩层也是使用频率比较高的组件，但遮罩层很容易产生滑动穿透的问题，即当我们触摸滑动遮罩层的时候，遮罩层下面的页面也会跟着滑动，如何来解决这个问题，我们来分几种情况讨论：\n\n（1）底层页面不需要下拉刷新，那只要像上一小节所讲设置`\"disableScroll\":true`就好了。\n\n（2）底层页面需要使用下拉刷新，遮罩层上无滚动，那么添加一个`catchtouchmove`事件:\n\n``` html\n<view class=\"mask\" catchtouchmove=\"true\"></view>\n```\n\n这样就阻止了触摸滑动及事件冒泡，达到阻止滑动穿透的效果。\n\n（3）底层页面需要使用下拉刷新，遮罩层上有可滚动的区域，那么可以在遮罩层显示的时候动态的给下面的页面添加一个`class`使其定位固定不可滑动，样式可以是这样：\n\n```css\n.fix{\n    top:0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    position: fixed;\n    z-index: 0;\n}\n```\n\n#### 12、手风琴菜单\n\n想实现一个手风琴下拉菜单动效？其实很简单，只需动态设置子菜单的高度结合`transition`过渡效果就可以实现了。\n\n``` html\n<view class=\"sub-nav\" style=\"{{active?style:'height:0;transition:height 0.5s;'}}\">\n```\n\n``` javascript\nlet style = 'height:'+subNav.length*50+'rpx;transition:height 0.5s;'\n```\n\n#### 13、封装request请求\n\n小程序提供的`request`请求API在项目中使用时如果不二次封装一下总觉得有些繁重，看过了网上几个不同的封装方式总觉得有些不满意，于是反复改动了几次得到了一个自己觉得用起来比较方便的版本，在这里分享出来。\n\n```javascript\n// request.js\n// GET请求\nfunction GET(url,data) {\n    return request('GET',url,data)\n}\n// POST请求\nfunction POST(url,data) {\n    return request('POST',url,data)\n}\n\nfunction request(method,url,data) {\n    let token = wx.getStorageSync('tokenInfo') || ''\n    return new Promise((resolve, reject) => {\n        wx.request({\n            url: url,\n            data: data,\n            method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\n            // 设置请求的 header\n            header: {\n                Authorization: `${token.token_type} ${token.access_token}`\n            },\n            success: res=> {\n                if(res.data){\n                    resolve(res)\n                } else {\n                    reject(res)\n                }\n            },\n            fail: ()=> {\n                wx.showToast({\n                    title: '网络错误，请检查后重试',\n                    icon: 'none',\n                    duration: 2000\n                })\n            }\n        })\n    })\n}\n\nmodule.exports = {\n    GET: GET,\n    POST: POST\n}\n```\n\n``` javascript\n//app.js\nconst request = require(\"/utils/request.js\")\nApp({\n    // 全局声明https请求方法\n    http:request\n})\n```\n\n``` javascript\n//获取应用实例\nconst app = getApp()\nPage({\n    data: {\n        code: ''\n    },\n    onLoad() {\n        app.http.GET('https://...',{name:'',pwd:''}).then((res)=>{\n            // 成功\n        }).catch((res)=>{\n            // 异常\n        })\n    }\n})\n\n```\n\n#### 14、日期转换\n\nIOS系统中`new Date()`方法不支持对'2018-04-12 23:00:00'这样的日期进行转换，需要对字符串进行正则替换`replace(/-/g, '/')`。\n\n#### 15、“分享监听”能力调整\n\n出于倡导用户主动分享小程序的考虑，微信官方不再支持`onShareAppMessage`分享事件函数的回调参数：`success`、`fail`、`complete`，因此开发者以后将无法通过这几个回调来获取用户的分享结果，如果需求有涉及请尽快调整，以免受到影响。\n\n#### 16、getWXACodeUnlimit获取小程序码报错\n\n使用`getWXACodeUnlimit`接口获取小程序码时，要注意`scene`参数最多接收32个字符，超出会报错。\n\n#### 17、自定义顶部导航栏\n\n可在`app.json`的`window`属性下通过`\"navigationStyle\":\"custom\"`自定义导航栏。\n\n```json\n\"window\":{\n    \"backgroundTextStyle\":\"dark\",\n    \"navigationBarBackgroundColor\": \"#3996F2\",\n    \"navigationBarTitleText\": \"物恋便利\",\n    \"navigationBarTextStyle\":\"white\",\n    \"navigationStyle\":\"custom\"\n}\n```\n\n实际上就是去除了默认的导航栏但是会保留右上角胶囊按钮，标题什么的也没有了，需要开发者自己编写顶部导航。\n\n\n\n\n\n\n","slug":"微信小程序那些你不知道的事儿","published":1,"updated":"2018-11-16T15:30:15.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06ta000axl69rzbaomvc","content":"<p>最近从零开始开发了一个微信小程序商城，一个月的时间下来也算颇有心得，于是想拿出来分享一下。本来想给文章标题起为“微信小程序奇技淫巧”，但是一查，奇技淫巧的意思是指过于奇巧，让人着迷，却又无益的技艺与制品。但咱们这可不是无意义瞎扯淡，不能这么叫，所以咱们就来聊聊小程序那些你知道或不知道的事儿，没准就能帮到困惑中的你。</p>\n<h4 id=\"1、button边框样式修改\"><a href=\"#1、button边框样式修改\" class=\"headerlink\" title=\"1、button边框样式修改\"></a>1、button边框样式修改</h4><p>小程序的button组件可能是使用率最高的组件之一了，如果我们想要修改边框样式时直接修改button的css是没有效果的，需要这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">     <span class=\"attribute\">border</span>:none;</span><br><span class=\"line\">     <span class=\"attribute\">border-radius</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、事件传参\"><a href=\"#2、事件传参\" class=\"headerlink\" title=\"2、事件传参\"></a>2、事件传参</h4><p>小程序中我们通常使用<code>bindtap</code>来绑定事件，但是绑定的方法并不能直接传参，我们需要借助标签的<code>data-*</code>属性，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">data-id</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">\"openTab\"</span>&gt;</span> Click me! <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>给<code>openTab</code>传递了一个<code>id=1</code>的参数，在方法函数内我们要取到这个参数也很简单</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openTab(event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取参数id</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event.currentTarget.dataset.id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、阻止冒泡\"><a href=\"#3、阻止冒泡\" class=\"headerlink\" title=\"3、阻止冒泡\"></a>3、阻止冒泡</h4><p>事件分为冒泡事件和非冒泡事件，当一个组件上的冒泡事件被触发后，该事件会向父节点传递，如不希望事件冒泡只需用<code>catch</code>替换掉<code>bind</code>即可，<code>bindtap</code>对应<code>catchtap</code>。</p>\n<h4 id=\"4、改变数组值\"><a href=\"#4、改变数组值\" class=\"headerlink\" title=\"4、改变数组值\"></a>4、改变数组值</h4><p>修改静态的数组元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">    <span class=\"string\">'array[0].text'</span>:<span class=\"string\">'changed data'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果索引的值是动态改变的需要使用这种写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = <span class=\"string\">'array['</span>+index+<span class=\"string\">'].text'</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">    [item]:<span class=\"string\">'changed data'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、跳转到tabBar页面\"><a href=\"#5、跳转到tabBar页面\" class=\"headerlink\" title=\"5、跳转到tabBar页面\"></a>5、跳转到tabBar页面</h4><p>当要跳转到tabBar页面时，使用<code>wx.navigateTo</code>控制是无效的，这个时候需要使用<code>wx.switchTab</code>方法，并且<code>url</code>不可以有参数。</p>\n<h4 id=\"6、用户拒绝授权后重新发起授权\"><a href=\"#6、用户拒绝授权后重新发起授权\" class=\"headerlink\" title=\"6、用户拒绝授权后重新发起授权\"></a>6、用户拒绝授权后重新发起授权</h4><p>由于小程序不再支持<code>wx.openSetting</code>方法，因此再度引导用户打开授权需要借助<code>button</code>组件的<code>open-type</code>    属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">open-type</span>=<span class=\"string\">\"openSetting\"</span> <span class=\"attr\">bindopensetting</span>=<span class=\"string\">\"handlerSetting\"</span>&gt;</span>去授权<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>openSetting</code>打开授权页，<code>bindopensetting</code>用来绑定打开授权设置页后的回调方法。</p>\n<h4 id=\"7、组件传值\"><a href=\"#7、组件传值\" class=\"headerlink\" title=\"7、组件传值\"></a>7、组件传值</h4><p>组件接受外部传入数据，但是需在<code>Component</code>构造器中定义<code>properties</code>才能使用，这点有点类似于<code>vue</code>的<code>props</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">param-a</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">param-b</span>=<span class=\"string\">\"hello\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意这里需要使用驼峰写法</span></span><br><span class=\"line\">        paramA: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">        paramB: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"8、调用组件方法\"><a href=\"#8、调用组件方法\" class=\"headerlink\" title=\"8、调用组件方法\"></a>8、调用组件方法</h4><p>需要借助id选择器选择组件实例节点，调用组件方法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">id</span>=<span class=\"string\">\"nav\"</span> <span class=\"attr\">param-a</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">param-b</span>=<span class=\"string\">\"hello\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.selectComponent(<span class=\"string\">\"#nav\"</span>).getList()</span><br></pre></td></tr></table></figure>\n<h4 id=\"9、获取页面路径及参数\"><a href=\"#9、获取页面路径及参数\" class=\"headerlink\" title=\"9、获取页面路径及参数\"></a>9、获取页面路径及参数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取页面路径</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.route</span><br><span class=\"line\"><span class=\"comment\">// 获取参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.options</span><br></pre></td></tr></table></figure>\n<h4 id=\"10、禁止页面上下拉出空白\"><a href=\"#10、禁止页面上下拉出空白\" class=\"headerlink\" title=\"10、禁止页面上下拉出空白\"></a>10、禁止页面上下拉出空白</h4><p>在ios手机上上下滑动页面会被拉出一块空白区域，如果不想要这种效果可以在json文件中配置<code>&quot;disableScroll&quot;:true</code>，但如果设置了这个配置会导致下拉刷新方法<code>onPullDownRefresh</code>失效。</p>\n<h4 id=\"11、阻止遮罩层滑动穿透\"><a href=\"#11、阻止遮罩层滑动穿透\" class=\"headerlink\" title=\"11、阻止遮罩层滑动穿透\"></a>11、阻止遮罩层滑动穿透</h4><p>遮罩层也是使用频率比较高的组件，但遮罩层很容易产生滑动穿透的问题，即当我们触摸滑动遮罩层的时候，遮罩层下面的页面也会跟着滑动，如何来解决这个问题，我们来分几种情况讨论：</p>\n<p>（1）底层页面不需要下拉刷新，那只要像上一小节所讲设置<code>&quot;disableScroll&quot;:true</code>就好了。</p>\n<p>（2）底层页面需要使用下拉刷新，遮罩层上无滚动，那么添加一个<code>catchtouchmove</code>事件:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mask\"</span> <span class=\"attr\">catchtouchmove</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样就阻止了触摸滑动及事件冒泡，达到阻止滑动穿透的效果。</p>\n<p>（3）底层页面需要使用下拉刷新，遮罩层上有可滚动的区域，那么可以在遮罩层显示的时候动态的给下面的页面添加一个<code>class</code>使其定位固定不可滑动，样式可以是这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.fix</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12、手风琴菜单\"><a href=\"#12、手风琴菜单\" class=\"headerlink\" title=\"12、手风琴菜单\"></a>12、手风琴菜单</h4><p>想实现一个手风琴下拉菜单动效？其实很简单，只需动态设置子菜单的高度结合<code>transition</code>过渡效果就可以实现了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sub-nav\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"&#123;&#123;active?style:'height:0;transition:height 0.5s;'&#125;&#125;\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> style = <span class=\"string\">'height:'</span>+subNav.length*<span class=\"number\">50</span>+<span class=\"string\">'rpx;transition:height 0.5s;'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"13、封装request请求\"><a href=\"#13、封装request请求\" class=\"headerlink\" title=\"13、封装request请求\"></a>13、封装request请求</h4><p>小程序提供的<code>request</code>请求API在项目中使用时如果不二次封装一下总觉得有些繁重，看过了网上几个不同的封装方式总觉得有些不满意，于是反复改动了几次得到了一个自己觉得用起来比较方便的版本，在这里分享出来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// request.js</span></span><br><span class=\"line\"><span class=\"comment\">// GET请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GET</span>(<span class=\"params\">url,data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(<span class=\"string\">'GET'</span>,url,data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// POST请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">POST</span>(<span class=\"params\">url,data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(<span class=\"string\">'POST'</span>,url,data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">method,url,data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> token = wx.getStorageSync(<span class=\"string\">'tokenInfo'</span>) || <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        wx.request(&#123;</span><br><span class=\"line\">            url: url,</span><br><span class=\"line\">            data: data,</span><br><span class=\"line\">            method: method, <span class=\"comment\">// OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置请求的 header</span></span><br><span class=\"line\">            header: &#123;</span><br><span class=\"line\">                Authorization: <span class=\"string\">`<span class=\"subst\">$&#123;token.token_type&#125;</span> <span class=\"subst\">$&#123;token.access_token&#125;</span>`</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"params\">res</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res.data)&#123;</span><br><span class=\"line\">                    resolve(res)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    reject(res)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            fail: <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                wx.showToast(&#123;</span><br><span class=\"line\">                    title: <span class=\"string\">'网络错误，请检查后重试'</span>,</span><br><span class=\"line\">                    icon: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">                    duration: <span class=\"number\">2000</span></span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    GET: GET,</span><br><span class=\"line\">    POST: POST</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">\"/utils/request.js\"</span>)</span><br><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 全局声明https请求方法</span></span><br><span class=\"line\">    http:request</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        code: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoad() &#123;</span><br><span class=\"line\">        app.http.GET(<span class=\"string\">'https://...'</span>,&#123;<span class=\"attr\">name</span>:<span class=\"string\">''</span>,<span class=\"attr\">pwd</span>:<span class=\"string\">''</span>&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 成功</span></span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 异常</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"14、日期转换\"><a href=\"#14、日期转换\" class=\"headerlink\" title=\"14、日期转换\"></a>14、日期转换</h4><p>IOS系统中<code>new Date()</code>方法不支持对’2018-04-12 23:00:00’这样的日期进行转换，需要对字符串进行正则替换<code>replace(/-/g, &#39;/&#39;)</code>。</p>\n<h4 id=\"15、“分享监听”能力调整\"><a href=\"#15、“分享监听”能力调整\" class=\"headerlink\" title=\"15、“分享监听”能力调整\"></a>15、“分享监听”能力调整</h4><p>出于倡导用户主动分享小程序的考虑，微信官方不再支持<code>onShareAppMessage</code>分享事件函数的回调参数：<code>success</code>、<code>fail</code>、<code>complete</code>，因此开发者以后将无法通过这几个回调来获取用户的分享结果，如果需求有涉及请尽快调整，以免受到影响。</p>\n<h4 id=\"16、getWXACodeUnlimit获取小程序码报错\"><a href=\"#16、getWXACodeUnlimit获取小程序码报错\" class=\"headerlink\" title=\"16、getWXACodeUnlimit获取小程序码报错\"></a>16、getWXACodeUnlimit获取小程序码报错</h4><p>使用<code>getWXACodeUnlimit</code>接口获取小程序码时，要注意<code>scene</code>参数最多接收32个字符，超出会报错。</p>\n<h4 id=\"17、自定义顶部导航栏\"><a href=\"#17、自定义顶部导航栏\" class=\"headerlink\" title=\"17、自定义顶部导航栏\"></a>17、自定义顶部导航栏</h4><p>可在<code>app.json</code>的<code>window</code>属性下通过<code>&quot;navigationStyle&quot;:&quot;custom&quot;</code>自定义导航栏。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"window\":&#123;</span><br><span class=\"line\">    \"backgroundTextStyle\":\"dark\",</span><br><span class=\"line\">    \"navigationBarBackgroundColor\": \"#3996F2\",</span><br><span class=\"line\">    \"navigationBarTitleText\": \"物恋便利\",</span><br><span class=\"line\">    \"navigationBarTextStyle\":\"white\",</span><br><span class=\"line\">    \"navigationStyle\":\"custom\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上就是去除了默认的导航栏但是会保留右上角胶囊按钮，标题什么的也没有了，需要开发者自己编写顶部导航。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近从零开始开发了一个微信小程序商城，一个月的时间下来也算颇有心得，于是想拿出来分享一下。本来想给文章标题起为“微信小程序奇技淫巧”，但是一查，奇技淫巧的意思是指过于奇巧，让人着迷，却又无益的技艺与制品。但咱们这可不是无意义瞎扯淡，不能这么叫，所以咱们就来聊聊小程序那些你知道或不知道的事儿，没准就能帮到困惑中的你。</p>\n<h4 id=\"1、button边框样式修改\"><a href=\"#1、button边框样式修改\" class=\"headerlink\" title=\"1、button边框样式修改\"></a>1、button边框样式修改</h4><p>小程序的button组件可能是使用率最高的组件之一了，如果我们想要修改边框样式时直接修改button的css是没有效果的，需要这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">     <span class=\"attribute\">border</span>:none;</span><br><span class=\"line\">     <span class=\"attribute\">border-radius</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、事件传参\"><a href=\"#2、事件传参\" class=\"headerlink\" title=\"2、事件传参\"></a>2、事件传参</h4><p>小程序中我们通常使用<code>bindtap</code>来绑定事件，但是绑定的方法并不能直接传参，我们需要借助标签的<code>data-*</code>属性，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">data-id</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">\"openTab\"</span>&gt;</span> Click me! <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>给<code>openTab</code>传递了一个<code>id=1</code>的参数，在方法函数内我们要取到这个参数也很简单</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openTab(event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取参数id</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event.currentTarget.dataset.id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、阻止冒泡\"><a href=\"#3、阻止冒泡\" class=\"headerlink\" title=\"3、阻止冒泡\"></a>3、阻止冒泡</h4><p>事件分为冒泡事件和非冒泡事件，当一个组件上的冒泡事件被触发后，该事件会向父节点传递，如不希望事件冒泡只需用<code>catch</code>替换掉<code>bind</code>即可，<code>bindtap</code>对应<code>catchtap</code>。</p>\n<h4 id=\"4、改变数组值\"><a href=\"#4、改变数组值\" class=\"headerlink\" title=\"4、改变数组值\"></a>4、改变数组值</h4><p>修改静态的数组元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">    <span class=\"string\">'array[0].text'</span>:<span class=\"string\">'changed data'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果索引的值是动态改变的需要使用这种写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = <span class=\"string\">'array['</span>+index+<span class=\"string\">'].text'</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">    [item]:<span class=\"string\">'changed data'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、跳转到tabBar页面\"><a href=\"#5、跳转到tabBar页面\" class=\"headerlink\" title=\"5、跳转到tabBar页面\"></a>5、跳转到tabBar页面</h4><p>当要跳转到tabBar页面时，使用<code>wx.navigateTo</code>控制是无效的，这个时候需要使用<code>wx.switchTab</code>方法，并且<code>url</code>不可以有参数。</p>\n<h4 id=\"6、用户拒绝授权后重新发起授权\"><a href=\"#6、用户拒绝授权后重新发起授权\" class=\"headerlink\" title=\"6、用户拒绝授权后重新发起授权\"></a>6、用户拒绝授权后重新发起授权</h4><p>由于小程序不再支持<code>wx.openSetting</code>方法，因此再度引导用户打开授权需要借助<code>button</code>组件的<code>open-type</code>    属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">open-type</span>=<span class=\"string\">\"openSetting\"</span> <span class=\"attr\">bindopensetting</span>=<span class=\"string\">\"handlerSetting\"</span>&gt;</span>去授权<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>openSetting</code>打开授权页，<code>bindopensetting</code>用来绑定打开授权设置页后的回调方法。</p>\n<h4 id=\"7、组件传值\"><a href=\"#7、组件传值\" class=\"headerlink\" title=\"7、组件传值\"></a>7、组件传值</h4><p>组件接受外部传入数据，但是需在<code>Component</code>构造器中定义<code>properties</code>才能使用，这点有点类似于<code>vue</code>的<code>props</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">param-a</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">param-b</span>=<span class=\"string\">\"hello\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意这里需要使用驼峰写法</span></span><br><span class=\"line\">        paramA: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">        paramB: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"8、调用组件方法\"><a href=\"#8、调用组件方法\" class=\"headerlink\" title=\"8、调用组件方法\"></a>8、调用组件方法</h4><p>需要借助id选择器选择组件实例节点，调用组件方法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">id</span>=<span class=\"string\">\"nav\"</span> <span class=\"attr\">param-a</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">param-b</span>=<span class=\"string\">\"hello\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.selectComponent(<span class=\"string\">\"#nav\"</span>).getList()</span><br></pre></td></tr></table></figure>\n<h4 id=\"9、获取页面路径及参数\"><a href=\"#9、获取页面路径及参数\" class=\"headerlink\" title=\"9、获取页面路径及参数\"></a>9、获取页面路径及参数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取页面路径</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.route</span><br><span class=\"line\"><span class=\"comment\">// 获取参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.options</span><br></pre></td></tr></table></figure>\n<h4 id=\"10、禁止页面上下拉出空白\"><a href=\"#10、禁止页面上下拉出空白\" class=\"headerlink\" title=\"10、禁止页面上下拉出空白\"></a>10、禁止页面上下拉出空白</h4><p>在ios手机上上下滑动页面会被拉出一块空白区域，如果不想要这种效果可以在json文件中配置<code>&quot;disableScroll&quot;:true</code>，但如果设置了这个配置会导致下拉刷新方法<code>onPullDownRefresh</code>失效。</p>\n<h4 id=\"11、阻止遮罩层滑动穿透\"><a href=\"#11、阻止遮罩层滑动穿透\" class=\"headerlink\" title=\"11、阻止遮罩层滑动穿透\"></a>11、阻止遮罩层滑动穿透</h4><p>遮罩层也是使用频率比较高的组件，但遮罩层很容易产生滑动穿透的问题，即当我们触摸滑动遮罩层的时候，遮罩层下面的页面也会跟着滑动，如何来解决这个问题，我们来分几种情况讨论：</p>\n<p>（1）底层页面不需要下拉刷新，那只要像上一小节所讲设置<code>&quot;disableScroll&quot;:true</code>就好了。</p>\n<p>（2）底层页面需要使用下拉刷新，遮罩层上无滚动，那么添加一个<code>catchtouchmove</code>事件:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mask\"</span> <span class=\"attr\">catchtouchmove</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样就阻止了触摸滑动及事件冒泡，达到阻止滑动穿透的效果。</p>\n<p>（3）底层页面需要使用下拉刷新，遮罩层上有可滚动的区域，那么可以在遮罩层显示的时候动态的给下面的页面添加一个<code>class</code>使其定位固定不可滑动，样式可以是这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.fix</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12、手风琴菜单\"><a href=\"#12、手风琴菜单\" class=\"headerlink\" title=\"12、手风琴菜单\"></a>12、手风琴菜单</h4><p>想实现一个手风琴下拉菜单动效？其实很简单，只需动态设置子菜单的高度结合<code>transition</code>过渡效果就可以实现了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sub-nav\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"&#123;&#123;active?style:'height:0;transition:height 0.5s;'&#125;&#125;\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> style = <span class=\"string\">'height:'</span>+subNav.length*<span class=\"number\">50</span>+<span class=\"string\">'rpx;transition:height 0.5s;'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"13、封装request请求\"><a href=\"#13、封装request请求\" class=\"headerlink\" title=\"13、封装request请求\"></a>13、封装request请求</h4><p>小程序提供的<code>request</code>请求API在项目中使用时如果不二次封装一下总觉得有些繁重，看过了网上几个不同的封装方式总觉得有些不满意，于是反复改动了几次得到了一个自己觉得用起来比较方便的版本，在这里分享出来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// request.js</span></span><br><span class=\"line\"><span class=\"comment\">// GET请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GET</span>(<span class=\"params\">url,data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(<span class=\"string\">'GET'</span>,url,data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// POST请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">POST</span>(<span class=\"params\">url,data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(<span class=\"string\">'POST'</span>,url,data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">method,url,data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> token = wx.getStorageSync(<span class=\"string\">'tokenInfo'</span>) || <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        wx.request(&#123;</span><br><span class=\"line\">            url: url,</span><br><span class=\"line\">            data: data,</span><br><span class=\"line\">            method: method, <span class=\"comment\">// OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置请求的 header</span></span><br><span class=\"line\">            header: &#123;</span><br><span class=\"line\">                Authorization: <span class=\"string\">`<span class=\"subst\">$&#123;token.token_type&#125;</span> <span class=\"subst\">$&#123;token.access_token&#125;</span>`</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"params\">res</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res.data)&#123;</span><br><span class=\"line\">                    resolve(res)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    reject(res)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            fail: <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                wx.showToast(&#123;</span><br><span class=\"line\">                    title: <span class=\"string\">'网络错误，请检查后重试'</span>,</span><br><span class=\"line\">                    icon: <span class=\"string\">'none'</span>,</span><br><span class=\"line\">                    duration: <span class=\"number\">2000</span></span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    GET: GET,</span><br><span class=\"line\">    POST: POST</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">\"/utils/request.js\"</span>)</span><br><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 全局声明https请求方法</span></span><br><span class=\"line\">    http:request</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取应用实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = getApp()</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        code: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoad() &#123;</span><br><span class=\"line\">        app.http.GET(<span class=\"string\">'https://...'</span>,&#123;<span class=\"attr\">name</span>:<span class=\"string\">''</span>,<span class=\"attr\">pwd</span>:<span class=\"string\">''</span>&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 成功</span></span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 异常</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"14、日期转换\"><a href=\"#14、日期转换\" class=\"headerlink\" title=\"14、日期转换\"></a>14、日期转换</h4><p>IOS系统中<code>new Date()</code>方法不支持对’2018-04-12 23:00:00’这样的日期进行转换，需要对字符串进行正则替换<code>replace(/-/g, &#39;/&#39;)</code>。</p>\n<h4 id=\"15、“分享监听”能力调整\"><a href=\"#15、“分享监听”能力调整\" class=\"headerlink\" title=\"15、“分享监听”能力调整\"></a>15、“分享监听”能力调整</h4><p>出于倡导用户主动分享小程序的考虑，微信官方不再支持<code>onShareAppMessage</code>分享事件函数的回调参数：<code>success</code>、<code>fail</code>、<code>complete</code>，因此开发者以后将无法通过这几个回调来获取用户的分享结果，如果需求有涉及请尽快调整，以免受到影响。</p>\n<h4 id=\"16、getWXACodeUnlimit获取小程序码报错\"><a href=\"#16、getWXACodeUnlimit获取小程序码报错\" class=\"headerlink\" title=\"16、getWXACodeUnlimit获取小程序码报错\"></a>16、getWXACodeUnlimit获取小程序码报错</h4><p>使用<code>getWXACodeUnlimit</code>接口获取小程序码时，要注意<code>scene</code>参数最多接收32个字符，超出会报错。</p>\n<h4 id=\"17、自定义顶部导航栏\"><a href=\"#17、自定义顶部导航栏\" class=\"headerlink\" title=\"17、自定义顶部导航栏\"></a>17、自定义顶部导航栏</h4><p>可在<code>app.json</code>的<code>window</code>属性下通过<code>&quot;navigationStyle&quot;:&quot;custom&quot;</code>自定义导航栏。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"window\":&#123;</span><br><span class=\"line\">    \"backgroundTextStyle\":\"dark\",</span><br><span class=\"line\">    \"navigationBarBackgroundColor\": \"#3996F2\",</span><br><span class=\"line\">    \"navigationBarTitleText\": \"物恋便利\",</span><br><span class=\"line\">    \"navigationBarTextStyle\":\"white\",</span><br><span class=\"line\">    \"navigationStyle\":\"custom\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上就是去除了默认的导航栏但是会保留右上角胶囊按钮，标题什么的也没有了，需要开发者自己编写顶部导航。</p>\n"},{"title":"探访JS作用域","date":"2018-10-18T13:38:50.000Z","urlname":"javascript-scope","toc":true,"_content":"\n### 引子\n\n文章开始，先用一道我曾经栽过跟头的面试题来引出今天的主题：\n\n``` javascript\nvar a = 1\nfunction scopeA() {\n    var a = 2\n    scopeB()\n}\nfunction scopeB() {\n    console.log(a)\n}\nscopeA()\n```\n\n想想看这段代码的输出结果是1还是2？为什么？\n\n### 什么是作用域？\n\n几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值并且能在之后对这个值进行访问或修改。而作用域就是一套规则，用于确定在何处以及如何查找变量。\n\n### ES5作用域\n\nES5中，作用域分为全局作用域以及函数作用域。函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，在函数外部无法访问，由此变量也就分成了全局变量和局部变量。\n\n``` javascript\nvar a = 1\nfunction foo(){ \n    var b = 2 \n    console.log(a) // 1\n    console.log(b) // 2\n} \nfoo();\nconsole.log(a) // 1\nconsole.log(b) // Uncaught ReferenceError: b is not defined\n```\n\n上面的代码，a就是全局变量，可以被任意访问，而b是只属于函数foo的内部变量，所以在外部访问会报错。\n\n而由于JavaScript没有块级作用域，因此在`for`、`if`等代码块中声明的变量也属于全局变量。\n\n``` javascript\nfor(var i = 0;i < 10;i++){\n    \n}\nconsole.log(i) // 10\n\nif(true){\n    var a = 1\n}\nconsole.log(a) // 1\n```\n\n### 作用域链\n\n当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。作用域链是函数被创建的作用域中对象的集合，它保证了对执行环境中有权访问的所有变量和函数的有序访问。\n\n回到文章开头提到的那段代码，其运行结果是`1`。\n\n虽然函数`scopeB`是在`scopeA`中调用的，但是函数运行在它们被定义的作用域里，而不是它们被执行的作用域里，因此当`scopeB`内部找不到变量a时，再向外查找就是查询全局作用域，此时变量a的值就是1。\n\n### 变量提升\n\n来看一段代码：\n\n``` javascript\nfunction foo(){\n    console.log(a) // undefined\n    var a = 1\n}\nfoo()\n```\n\n为什么a的打印结果是`undefined`？在JavaScript中，函数及变量的声明都将被提升到函数的最顶部。因此上面的代码等同于：\n\n```javascript\nfunction foo(){\n    var a\n    console.log(a) // undefined\n    a = 1\n}\nfoo()\n```\n\na打印时只声明未赋值，因此结果是`undefined`。\n\n### 函数声明和函数表达式\n\n定义函数的方式有两种，一种是函数声明，另一种是函数表达式。函数声明会将函数提升到最前面，成为全局函数，并且一定要声明指定函数名，而函数表达式可以不用声明函数名用作匿名函数，但是要在赋值后才可以调用；函数表达式后面可以直接跟`()`调用，函数声明不可以。\n\n```javascript\n// 函数声明\nfoo() // 1\nfunction foo(){\n    console.log(1)\n}\n// 函数表达式\nbar() // Uncaught TypeError: bar is not a function\nvar bar = function(){\n    console.log(2)\n}\n```\n\n### 立即执行函数（IIFE）\n\n虽然函数作用域可以将内部变量隐藏起来，但是由于必须声明一个具名函数，这个变量名会污染外部作用域，而且必须显式的通过方法名调用才可以执行。\n\n幸好我们只需在函数外面加一对圆括号就可以解决这些问题。\n\n``` javascript\n(function foo(){\n    var a = 3\n    console.log(a) // 3\n})()\n```\n\n加上圆括号就把函数声明变成了函数表达式，后面再接一对圆括号表示立即执行这个函数。这种方式定义的函数就是立即执行函数。\n\n区分函数声明和表达式最简单的方法是看`function`关键字出现在声明中的位置。如果`function`是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n\n`(function foo(){ .. }) `作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。其实立即执行函数模仿了块级作用域的效果。\n\n### 块级作用域\n\n虽然函数作用域可以隐藏内部变量，但函数并不是唯一的作用域单元，变量的声明应该距离使用的地方越近越好，有些变量我们只希望在部分代码块`{..}`中才可以使用，而声明为全局变量也许会带来一些不必要的后果。好在ES6为我们带来了`let`和`const`关键字，这让我们可以创建块级作用域。\n\n``` javascript\n{\n    console.log(a) // Uncaught ReferenceError: a is not defined\n    let a = 1\n    console.log(a) // 1\n}\nconsole.log(a) // Uncaught ReferenceError: a is not defined\n```\n\n这样，通过`let`声明的变量就只在所在代码块内有效，而不会泄漏到全局，也不会提升到块的顶部。","source":"_posts/探访JS作用域.md","raw":"---\ntitle: 探访JS作用域\ndate: 2018-10-18 21:38:50\nurlname: javascript-scope\ncategories: [\"技术\"]\ntags: [\"JS\"]\ntoc: true\n---\n\n### 引子\n\n文章开始，先用一道我曾经栽过跟头的面试题来引出今天的主题：\n\n``` javascript\nvar a = 1\nfunction scopeA() {\n    var a = 2\n    scopeB()\n}\nfunction scopeB() {\n    console.log(a)\n}\nscopeA()\n```\n\n想想看这段代码的输出结果是1还是2？为什么？\n\n### 什么是作用域？\n\n几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值并且能在之后对这个值进行访问或修改。而作用域就是一套规则，用于确定在何处以及如何查找变量。\n\n### ES5作用域\n\nES5中，作用域分为全局作用域以及函数作用域。函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，在函数外部无法访问，由此变量也就分成了全局变量和局部变量。\n\n``` javascript\nvar a = 1\nfunction foo(){ \n    var b = 2 \n    console.log(a) // 1\n    console.log(b) // 2\n} \nfoo();\nconsole.log(a) // 1\nconsole.log(b) // Uncaught ReferenceError: b is not defined\n```\n\n上面的代码，a就是全局变量，可以被任意访问，而b是只属于函数foo的内部变量，所以在外部访问会报错。\n\n而由于JavaScript没有块级作用域，因此在`for`、`if`等代码块中声明的变量也属于全局变量。\n\n``` javascript\nfor(var i = 0;i < 10;i++){\n    \n}\nconsole.log(i) // 10\n\nif(true){\n    var a = 1\n}\nconsole.log(a) // 1\n```\n\n### 作用域链\n\n当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。作用域链是函数被创建的作用域中对象的集合，它保证了对执行环境中有权访问的所有变量和函数的有序访问。\n\n回到文章开头提到的那段代码，其运行结果是`1`。\n\n虽然函数`scopeB`是在`scopeA`中调用的，但是函数运行在它们被定义的作用域里，而不是它们被执行的作用域里，因此当`scopeB`内部找不到变量a时，再向外查找就是查询全局作用域，此时变量a的值就是1。\n\n### 变量提升\n\n来看一段代码：\n\n``` javascript\nfunction foo(){\n    console.log(a) // undefined\n    var a = 1\n}\nfoo()\n```\n\n为什么a的打印结果是`undefined`？在JavaScript中，函数及变量的声明都将被提升到函数的最顶部。因此上面的代码等同于：\n\n```javascript\nfunction foo(){\n    var a\n    console.log(a) // undefined\n    a = 1\n}\nfoo()\n```\n\na打印时只声明未赋值，因此结果是`undefined`。\n\n### 函数声明和函数表达式\n\n定义函数的方式有两种，一种是函数声明，另一种是函数表达式。函数声明会将函数提升到最前面，成为全局函数，并且一定要声明指定函数名，而函数表达式可以不用声明函数名用作匿名函数，但是要在赋值后才可以调用；函数表达式后面可以直接跟`()`调用，函数声明不可以。\n\n```javascript\n// 函数声明\nfoo() // 1\nfunction foo(){\n    console.log(1)\n}\n// 函数表达式\nbar() // Uncaught TypeError: bar is not a function\nvar bar = function(){\n    console.log(2)\n}\n```\n\n### 立即执行函数（IIFE）\n\n虽然函数作用域可以将内部变量隐藏起来，但是由于必须声明一个具名函数，这个变量名会污染外部作用域，而且必须显式的通过方法名调用才可以执行。\n\n幸好我们只需在函数外面加一对圆括号就可以解决这些问题。\n\n``` javascript\n(function foo(){\n    var a = 3\n    console.log(a) // 3\n})()\n```\n\n加上圆括号就把函数声明变成了函数表达式，后面再接一对圆括号表示立即执行这个函数。这种方式定义的函数就是立即执行函数。\n\n区分函数声明和表达式最简单的方法是看`function`关键字出现在声明中的位置。如果`function`是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n\n`(function foo(){ .. }) `作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。其实立即执行函数模仿了块级作用域的效果。\n\n### 块级作用域\n\n虽然函数作用域可以隐藏内部变量，但函数并不是唯一的作用域单元，变量的声明应该距离使用的地方越近越好，有些变量我们只希望在部分代码块`{..}`中才可以使用，而声明为全局变量也许会带来一些不必要的后果。好在ES6为我们带来了`let`和`const`关键字，这让我们可以创建块级作用域。\n\n``` javascript\n{\n    console.log(a) // Uncaught ReferenceError: a is not defined\n    let a = 1\n    console.log(a) // 1\n}\nconsole.log(a) // Uncaught ReferenceError: a is not defined\n```\n\n这样，通过`let`声明的变量就只在所在代码块内有效，而不会泄漏到全局，也不会提升到块的顶部。","slug":"探访JS作用域","published":1,"updated":"2018-11-16T15:30:15.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06td000exl696aqgaihc","content":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>文章开始，先用一道我曾经栽过跟头的面试题来引出今天的主题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scopeA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">    scopeB()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scopeB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">scopeA()</span><br></pre></td></tr></table></figure>\n<p>想想看这段代码的输出结果是1还是2？为什么？</p>\n<h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值并且能在之后对这个值进行访问或修改。而作用域就是一套规则，用于确定在何处以及如何查找变量。</p>\n<h3 id=\"ES5作用域\"><a href=\"#ES5作用域\" class=\"headerlink\" title=\"ES5作用域\"></a>ES5作用域</h3><p>ES5中，作用域分为全局作用域以及函数作用域。函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，在函数外部无法访问，由此变量也就分成了全局变量和局部变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">2</span> </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">foo();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，a就是全局变量，可以被任意访问，而b是只属于函数foo的内部变量，所以在外部访问会报错。</p>\n<p>而由于JavaScript没有块级作用域，因此在<code>for</code>、<code>if</code>等代码块中声明的变量也属于全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。作用域链是函数被创建的作用域中对象的集合，它保证了对执行环境中有权访问的所有变量和函数的有序访问。</p>\n<p>回到文章开头提到的那段代码，其运行结果是<code>1</code>。</p>\n<p>虽然函数<code>scopeB</code>是在<code>scopeA</code>中调用的，但是函数运行在它们被定义的作用域里，而不是它们被执行的作用域里，因此当<code>scopeB</code>内部找不到变量a时，再向外查找就是查询全局作用域，此时变量a的值就是1。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>来看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>为什么a的打印结果是<code>undefined</code>？在JavaScript中，函数及变量的声明都将被提升到函数的最顶部。因此上面的代码等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>a打印时只声明未赋值，因此结果是<code>undefined</code>。</p>\n<h3 id=\"函数声明和函数表达式\"><a href=\"#函数声明和函数表达式\" class=\"headerlink\" title=\"函数声明和函数表达式\"></a>函数声明和函数表达式</h3><p>定义函数的方式有两种，一种是函数声明，另一种是函数表达式。函数声明会将函数提升到最前面，成为全局函数，并且一定要声明指定函数名，而函数表达式可以不用声明函数名用作匿名函数，但是要在赋值后才可以调用；函数表达式后面可以直接跟<code>()</code>调用，函数声明不可以。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\">foo() <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\">bar() <span class=\"comment\">// Uncaught TypeError: bar is not a function</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行函数（IIFE）\"><a href=\"#立即执行函数（IIFE）\" class=\"headerlink\" title=\"立即执行函数（IIFE）\"></a>立即执行函数（IIFE）</h3><p>虽然函数作用域可以将内部变量隐藏起来，但是由于必须声明一个具名函数，这个变量名会污染外部作用域，而且必须显式的通过方法名调用才可以执行。</p>\n<p>幸好我们只需在函数外面加一对圆括号就可以解决这些问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>加上圆括号就把函数声明变成了函数表达式，后面再接一对圆括号表示立即执行这个函数。这种方式定义的函数就是立即执行函数。</p>\n<p>区分函数声明和表达式最简单的方法是看<code>function</code>关键字出现在声明中的位置。如果<code>function</code>是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p>\n<p><code>(function foo(){ .. })</code>作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。其实立即执行函数模仿了块级作用域的效果。</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>虽然函数作用域可以隐藏内部变量，但函数并不是唯一的作用域单元，变量的声明应该距离使用的地方越近越好，有些变量我们只希望在部分代码块<code>{..}</code>中才可以使用，而声明为全局变量也许会带来一些不必要的后果。好在ES6为我们带来了<code>let</code>和<code>const</code>关键字，这让我们可以创建块级作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>这样，通过<code>let</code>声明的变量就只在所在代码块内有效，而不会泄漏到全局，也不会提升到块的顶部。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>文章开始，先用一道我曾经栽过跟头的面试题来引出今天的主题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scopeA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">    scopeB()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scopeB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">scopeA()</span><br></pre></td></tr></table></figure>\n<p>想想看这段代码的输出结果是1还是2？为什么？</p>\n<h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值并且能在之后对这个值进行访问或修改。而作用域就是一套规则，用于确定在何处以及如何查找变量。</p>\n<h3 id=\"ES5作用域\"><a href=\"#ES5作用域\" class=\"headerlink\" title=\"ES5作用域\"></a>ES5作用域</h3><p>ES5中，作用域分为全局作用域以及函数作用域。函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，在函数外部无法访问，由此变量也就分成了全局变量和局部变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">2</span> </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">foo();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，a就是全局变量，可以被任意访问，而b是只属于函数foo的内部变量，所以在外部访问会报错。</p>\n<p>而由于JavaScript没有块级作用域，因此在<code>for</code>、<code>if</code>等代码块中声明的变量也属于全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。当在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。作用域链是函数被创建的作用域中对象的集合，它保证了对执行环境中有权访问的所有变量和函数的有序访问。</p>\n<p>回到文章开头提到的那段代码，其运行结果是<code>1</code>。</p>\n<p>虽然函数<code>scopeB</code>是在<code>scopeA</code>中调用的，但是函数运行在它们被定义的作用域里，而不是它们被执行的作用域里，因此当<code>scopeB</code>内部找不到变量a时，再向外查找就是查询全局作用域，此时变量a的值就是1。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>来看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>为什么a的打印结果是<code>undefined</code>？在JavaScript中，函数及变量的声明都将被提升到函数的最顶部。因此上面的代码等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>a打印时只声明未赋值，因此结果是<code>undefined</code>。</p>\n<h3 id=\"函数声明和函数表达式\"><a href=\"#函数声明和函数表达式\" class=\"headerlink\" title=\"函数声明和函数表达式\"></a>函数声明和函数表达式</h3><p>定义函数的方式有两种，一种是函数声明，另一种是函数表达式。函数声明会将函数提升到最前面，成为全局函数，并且一定要声明指定函数名，而函数表达式可以不用声明函数名用作匿名函数，但是要在赋值后才可以调用；函数表达式后面可以直接跟<code>()</code>调用，函数声明不可以。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\">foo() <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\">bar() <span class=\"comment\">// Uncaught TypeError: bar is not a function</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行函数（IIFE）\"><a href=\"#立即执行函数（IIFE）\" class=\"headerlink\" title=\"立即执行函数（IIFE）\"></a>立即执行函数（IIFE）</h3><p>虽然函数作用域可以将内部变量隐藏起来，但是由于必须声明一个具名函数，这个变量名会污染外部作用域，而且必须显式的通过方法名调用才可以执行。</p>\n<p>幸好我们只需在函数外面加一对圆括号就可以解决这些问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>加上圆括号就把函数声明变成了函数表达式，后面再接一对圆括号表示立即执行这个函数。这种方式定义的函数就是立即执行函数。</p>\n<p>区分函数声明和表达式最简单的方法是看<code>function</code>关键字出现在声明中的位置。如果<code>function</code>是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p>\n<p><code>(function foo(){ .. })</code>作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。其实立即执行函数模仿了块级作用域的效果。</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>虽然函数作用域可以隐藏内部变量，但函数并不是唯一的作用域单元，变量的声明应该距离使用的地方越近越好，有些变量我们只希望在部分代码块<code>{..}</code>中才可以使用，而声明为全局变量也许会带来一些不必要的后果。好在ES6为我们带来了<code>let</code>和<code>const</code>关键字，这让我们可以创建块级作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>这样，通过<code>let</code>声明的变量就只在所在代码块内有效，而不会泄漏到全局，也不会提升到块的顶部。</p>\n"},{"title":"浅谈正则","subtitle":"强大且高效的字符串模式","date":"2018-08-10T12:25:54.000Z","urlname":"regular-expression","toc":true,"_content":"\n作为一枚程序猿，无论是前端还是后端，对正则都不会陌生。正则表达式对于处理字符串、对字符串制定验证规则有着强大而高效的能力。\n\n### 什么是正则表达式？\n正则表达式是使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。它可以针对特定要求完成我们对字符串的处理要求，在程序世界里使用广泛。特别是在表单输入验证的环节，正则表达式起到了举重若轻的作用。例如我们想要验证用户是否输入了一组6位数字就可以使用这样的规则：\n``` javascript\n/^[0-9]{6}$/\n```\n这个例子只是简单让你知道正则表达式可以做什么，我们接下来从基础开始说起。\n\n### 正则表达式对象及修饰符\n正则表达式对象有两种定义方式\n1、构造函数定义\n通过`new RegExp(pattern, attributes)`的方式构造，如：\n``` javascript\nvar reg = new RegExp(\"abc\",\"g\")\n```\n其中pattern为表示表达式内容,上面的例子表示匹配abc.\nattributes表示：\n>g 全局匹配\ni 不区分大小写\nm 多行匹配\n\n2、文本定义\n`/pattern/attributes`,如：\n``` javascript\nvar reg = /abc/g;\n```\n等价于第一种构造函数方式\n\n### 元字符 \n\n| 字符          | 描述   |\n| --------     | -----  |\n| \\ | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，`'n'`匹配字符`n`。`'\\n'`匹配一个换行符。序列`'\\\\'`匹配 `\\`，而`'\\('`则匹配`(` |\n| + | 匹配一次或多次 |\n| * | 匹配0次、1次或多次   |\n| ? | 匹配0次或1次  |\n| . | 匹配除换行符之外的任何字符    |\n| {n} | n为非负整数，匹配n次    |\n| {n,} | 至少匹配n次    |\n| {n,m} | 匹配n~m次    |\n| ^ | 匹配字符串开始，值得注意的是它还有另外一个含义。当在一组方括号里使用`^`时，它表示`非`或`排除`的意思，常常用来剔除某个字符    |\n| $ | 匹配字符串结束    |\n| x&#124;y       | 匹配x或y    |\n| [xyz] | 匹配xyz中的任一个字符    |\n| [^xyx] | 匹配除xyz的任一个字符    |\n| \\b | 匹配一个单词边界，也就是指单词和空格间的位置。例如，`\"er\\b\"`可以匹配`\"never\"`中的`er`，但不能匹配`\"verb\"`中的`er`    |\n| \\d | 匹配一个数字，相当于[0-9]    |\n| \\D | 匹配非数字字符，相当于[^0-9]    |\n| \\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]    |\n| \\S | 匹配任何非空白字符。等价于[^\\f\\n\\r\\t\\v]    |\n| \\w | 匹配字母、数字、下划线。等价于[A-Za-z0-9_]    |\n| \\W | 匹配非字母、数字、下划线。等价于[^A-Za-z0-9_]    |\n\n### 非贪婪模式\n`*`和`+`限定符都是贪婪的，他们会尽可能的多匹配字符，在其后面加上`?`便可以实现最小匹配。\n如对于字符串starstarstar，`s.\\*r`匹配的是starstarstar，而`s.\\*?r`匹配的是star\n\n### 正则相关方法\n#### test()\n`test()`是正则表达式方法，用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回`true`，否则返回`false`。\n``` javascript\n// reg为正则规则，str为待测试字符串\nreg.test(str)\n```\n#### exec()\n`exec()`是正则表达式方法，用于检索字符串中的正则表达式的匹配，该函数返回一个数组，存放匹配的结果。如果未找到匹配，则返回值为`null`。但若有匹配的情况下，`exec()`返回的数组长度永远为1。`exec()`方法受参数`g`影响,如果不指定`g`那么它永远返回第一个匹配值，如果指定了`g`那么下一次调用时它将从上一次结束的位置继续查找,下面这个例子可以很清楚的向你解释这一点：\n``` javascript\nvar str = \"star1star2star3\"; \nvar reg = new RegExp(\"star.\", \"g\"); \nconsole.log(reg.exec(str)[0]); // star1\nconsole.log(reg.exec(str)[0]); // star2\n```\n#### match()\n以下方法皆为字符串方法。\n`match()`有点类似于`exec()`的作用，只不过当指定了g时，`match()`方法一次性返回所有匹配结果。\n``` javascript\nvar str = \"star1star2star3\"; \nvar reg = new RegExp(\"star.\", \"g\"); \nconsole.log(str.exec(reg)); // [\"star1\",\"star2\",\"star3\"]\n```\n#### search()\n`search()`方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置，若无结果则返回`-1`\n#### split()\n`split()`根据正则规则分割字符串返回数组\n#### replace()\n`replace()`方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n$1,...$9: 正则表达式中有几个`()`，就会传递几个参数，$1~$9分别代表本次匹配中每个`()`提取的结果，最多9个\n例如：\n``` javascript\nmobile.replace(/^(\\d{3})\\d{4}(\\d{4})$/, \"$1****$2\")\n```\n这是一个手机号加密的正则\n\n### 常用正则\n``` javascript\n// 手机号码\n/^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]{8}$/\n// 固定电话\n/^(400|800)([0-9]{7})|(0\\d{2,3}(-?)\\d{7,8})$/\n```\n\n\n### 可视化在线校验工具\n[https://www.debuggex.com/](https://www.debuggex.com/)\n很棒的在线工具，不仅可以帮你运算出结果，还可以让你结合图形一环一环的捋清验证的过程，方便你进行修改调试\n![reg](https://s1.ax1x.com/2018/10/15/iaMHVe.png)","source":"_posts/浅谈正则.md","raw":"---\ntitle: 浅谈正则\nsubtitle: 强大且高效的字符串模式\ndate: 2018-08-10 20:25:54\nurlname: regular-expression\ncategories: [\"技术\"]\ntags: [\"JS\"]\ntoc: true\n---\n\n作为一枚程序猿，无论是前端还是后端，对正则都不会陌生。正则表达式对于处理字符串、对字符串制定验证规则有着强大而高效的能力。\n\n### 什么是正则表达式？\n正则表达式是使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。它可以针对特定要求完成我们对字符串的处理要求，在程序世界里使用广泛。特别是在表单输入验证的环节，正则表达式起到了举重若轻的作用。例如我们想要验证用户是否输入了一组6位数字就可以使用这样的规则：\n``` javascript\n/^[0-9]{6}$/\n```\n这个例子只是简单让你知道正则表达式可以做什么，我们接下来从基础开始说起。\n\n### 正则表达式对象及修饰符\n正则表达式对象有两种定义方式\n1、构造函数定义\n通过`new RegExp(pattern, attributes)`的方式构造，如：\n``` javascript\nvar reg = new RegExp(\"abc\",\"g\")\n```\n其中pattern为表示表达式内容,上面的例子表示匹配abc.\nattributes表示：\n>g 全局匹配\ni 不区分大小写\nm 多行匹配\n\n2、文本定义\n`/pattern/attributes`,如：\n``` javascript\nvar reg = /abc/g;\n```\n等价于第一种构造函数方式\n\n### 元字符 \n\n| 字符          | 描述   |\n| --------     | -----  |\n| \\ | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，`'n'`匹配字符`n`。`'\\n'`匹配一个换行符。序列`'\\\\'`匹配 `\\`，而`'\\('`则匹配`(` |\n| + | 匹配一次或多次 |\n| * | 匹配0次、1次或多次   |\n| ? | 匹配0次或1次  |\n| . | 匹配除换行符之外的任何字符    |\n| {n} | n为非负整数，匹配n次    |\n| {n,} | 至少匹配n次    |\n| {n,m} | 匹配n~m次    |\n| ^ | 匹配字符串开始，值得注意的是它还有另外一个含义。当在一组方括号里使用`^`时，它表示`非`或`排除`的意思，常常用来剔除某个字符    |\n| $ | 匹配字符串结束    |\n| x&#124;y       | 匹配x或y    |\n| [xyz] | 匹配xyz中的任一个字符    |\n| [^xyx] | 匹配除xyz的任一个字符    |\n| \\b | 匹配一个单词边界，也就是指单词和空格间的位置。例如，`\"er\\b\"`可以匹配`\"never\"`中的`er`，但不能匹配`\"verb\"`中的`er`    |\n| \\d | 匹配一个数字，相当于[0-9]    |\n| \\D | 匹配非数字字符，相当于[^0-9]    |\n| \\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]    |\n| \\S | 匹配任何非空白字符。等价于[^\\f\\n\\r\\t\\v]    |\n| \\w | 匹配字母、数字、下划线。等价于[A-Za-z0-9_]    |\n| \\W | 匹配非字母、数字、下划线。等价于[^A-Za-z0-9_]    |\n\n### 非贪婪模式\n`*`和`+`限定符都是贪婪的，他们会尽可能的多匹配字符，在其后面加上`?`便可以实现最小匹配。\n如对于字符串starstarstar，`s.\\*r`匹配的是starstarstar，而`s.\\*?r`匹配的是star\n\n### 正则相关方法\n#### test()\n`test()`是正则表达式方法，用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回`true`，否则返回`false`。\n``` javascript\n// reg为正则规则，str为待测试字符串\nreg.test(str)\n```\n#### exec()\n`exec()`是正则表达式方法，用于检索字符串中的正则表达式的匹配，该函数返回一个数组，存放匹配的结果。如果未找到匹配，则返回值为`null`。但若有匹配的情况下，`exec()`返回的数组长度永远为1。`exec()`方法受参数`g`影响,如果不指定`g`那么它永远返回第一个匹配值，如果指定了`g`那么下一次调用时它将从上一次结束的位置继续查找,下面这个例子可以很清楚的向你解释这一点：\n``` javascript\nvar str = \"star1star2star3\"; \nvar reg = new RegExp(\"star.\", \"g\"); \nconsole.log(reg.exec(str)[0]); // star1\nconsole.log(reg.exec(str)[0]); // star2\n```\n#### match()\n以下方法皆为字符串方法。\n`match()`有点类似于`exec()`的作用，只不过当指定了g时，`match()`方法一次性返回所有匹配结果。\n``` javascript\nvar str = \"star1star2star3\"; \nvar reg = new RegExp(\"star.\", \"g\"); \nconsole.log(str.exec(reg)); // [\"star1\",\"star2\",\"star3\"]\n```\n#### search()\n`search()`方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置，若无结果则返回`-1`\n#### split()\n`split()`根据正则规则分割字符串返回数组\n#### replace()\n`replace()`方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n$1,...$9: 正则表达式中有几个`()`，就会传递几个参数，$1~$9分别代表本次匹配中每个`()`提取的结果，最多9个\n例如：\n``` javascript\nmobile.replace(/^(\\d{3})\\d{4}(\\d{4})$/, \"$1****$2\")\n```\n这是一个手机号加密的正则\n\n### 常用正则\n``` javascript\n// 手机号码\n/^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]{8}$/\n// 固定电话\n/^(400|800)([0-9]{7})|(0\\d{2,3}(-?)\\d{7,8})$/\n```\n\n\n### 可视化在线校验工具\n[https://www.debuggex.com/](https://www.debuggex.com/)\n很棒的在线工具，不仅可以帮你运算出结果，还可以让你结合图形一环一环的捋清验证的过程，方便你进行修改调试\n![reg](https://s1.ax1x.com/2018/10/15/iaMHVe.png)","slug":"浅谈正则","published":1,"updated":"2018-11-16T15:30:15.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06th000hxl69eja3nlwk","content":"<p>作为一枚程序猿，无论是前端还是后端，对正则都不会陌生。正则表达式对于处理字符串、对字符串制定验证规则有着强大而高效的能力。</p>\n<h3 id=\"什么是正则表达式？\"><a href=\"#什么是正则表达式？\" class=\"headerlink\" title=\"什么是正则表达式？\"></a>什么是正则表达式？</h3><p>正则表达式是使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。它可以针对特定要求完成我们对字符串的处理要求，在程序世界里使用广泛。特别是在表单输入验证的环节，正则表达式起到了举重若轻的作用。例如我们想要验证用户是否输入了一组6位数字就可以使用这样的规则：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">6</span>&#125;$/</span><br></pre></td></tr></table></figure></p>\n<p>这个例子只是简单让你知道正则表达式可以做什么，我们接下来从基础开始说起。</p>\n<h3 id=\"正则表达式对象及修饰符\"><a href=\"#正则表达式对象及修饰符\" class=\"headerlink\" title=\"正则表达式对象及修饰符\"></a>正则表达式对象及修饰符</h3><p>正则表达式对象有两种定义方式<br>1、构造函数定义<br>通过<code>new RegExp(pattern, attributes)</code>的方式构造，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"abc\"</span>,<span class=\"string\">\"g\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>其中pattern为表示表达式内容,上面的例子表示匹配abc.<br>attributes表示：</p>\n<blockquote>\n<p>g 全局匹配<br>i 不区分大小写<br>m 多行匹配</p>\n</blockquote>\n<p>2、文本定义<br><code>/pattern/attributes</code>,如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/g</span>;</span><br></pre></td></tr></table></figure></p>\n<p>等价于第一种构造函数方式</p>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\</td>\n<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，<code>&#39;n&#39;</code>匹配字符<code>n</code>。<code>&#39;\\n&#39;</code>匹配一个换行符。序列<code>&#39;\\\\&#39;</code>匹配 <code>\\</code>，而<code>&#39;\\(&#39;</code>则匹配<code>(</code></td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配一次或多次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配0次、1次或多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配0次或1次</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除换行符之外的任何字符</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n为非负整数，匹配n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>至少匹配n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配n~m次</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串开始，值得注意的是它还有另外一个含义。当在一组方括号里使用<code>^</code>时，它表示<code>非</code>或<code>排除</code>的意思，常常用来剔除某个字符</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串结束</td>\n</tr>\n<tr>\n<td>x&#124;y</td>\n<td>匹配x或y</td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>匹配xyz中的任一个字符</td>\n</tr>\n<tr>\n<td>[^xyx]</td>\n<td>匹配除xyz的任一个字符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>&quot;er\\b&quot;</code>可以匹配<code>&quot;never&quot;</code>中的<code>er</code>，但不能匹配<code>&quot;verb&quot;</code>中的<code>er</code></td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字，相当于[0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配非数字字符，相当于[^0-9]</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于[^\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母、数字、下划线。等价于[A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配非字母、数字、下划线。等价于[^A-Za-z0-9_]</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"非贪婪模式\"></a>非贪婪模式</h3><p><code>*</code>和<code>+</code>限定符都是贪婪的，他们会尽可能的多匹配字符，在其后面加上<code>?</code>便可以实现最小匹配。<br>如对于字符串starstarstar，<code>s.\\*r</code>匹配的是starstarstar，而<code>s.\\*?r</code>匹配的是star</p>\n<h3 id=\"正则相关方法\"><a href=\"#正则相关方法\" class=\"headerlink\" title=\"正则相关方法\"></a>正则相关方法</h3><h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><p><code>test()</code>是正则表达式方法，用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回<code>true</code>，否则返回<code>false</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reg为正则规则，str为待测试字符串</span></span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h4><p><code>exec()</code>是正则表达式方法，用于检索字符串中的正则表达式的匹配，该函数返回一个数组，存放匹配的结果。如果未找到匹配，则返回值为<code>null</code>。但若有匹配的情况下，<code>exec()</code>返回的数组长度永远为1。<code>exec()</code>方法受参数<code>g</code>影响,如果不指定<code>g</code>那么它永远返回第一个匹配值，如果指定了<code>g</code>那么下一次调用时它将从上一次结束的位置继续查找,下面这个例子可以很清楚的向你解释这一点：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"star1star2star3\"</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"star.\"</span>, <span class=\"string\">\"g\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.exec(str)[<span class=\"number\">0</span>]); <span class=\"comment\">// star1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.exec(str)[<span class=\"number\">0</span>]); <span class=\"comment\">// star2</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><p>以下方法皆为字符串方法。<br><code>match()</code>有点类似于<code>exec()</code>的作用，只不过当指定了g时，<code>match()</code>方法一次性返回所有匹配结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"star1star2star3\"</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"star.\"</span>, <span class=\"string\">\"g\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.exec(reg)); <span class=\"comment\">// [\"star1\",\"star2\",\"star3\"]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><p><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置，若无结果则返回<code>-1</code></p>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><p><code>split()</code>根据正则规则分割字符串返回数组</p>\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><p><code>replace()</code>方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br>$1,…$9: 正则表达式中有几个<code>()</code>，就会传递几个参数，$1~$9分别代表本次匹配中每个<code>()</code>提取的结果，最多9个<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mobile.replace(<span class=\"regexp\">/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/</span>, <span class=\"string\">\"$1****$2\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这是一个手机号加密的正则</p>\n<h3 id=\"常用正则\"><a href=\"#常用正则\" class=\"headerlink\" title=\"常用正则\"></a>常用正则</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手机号码</span></span><br><span class=\"line\">/^<span class=\"number\">1</span>([<span class=\"number\">358</span>][<span class=\"number\">0</span><span class=\"number\">-9</span>]|<span class=\"number\">4</span>[<span class=\"number\">579</span>]|<span class=\"number\">66</span>|<span class=\"number\">7</span>[<span class=\"number\">0135678</span>]|<span class=\"number\">9</span>[<span class=\"number\">89</span>])[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">8</span>&#125;$/</span><br><span class=\"line\"><span class=\"comment\">// 固定电话</span></span><br><span class=\"line\">/^(<span class=\"number\">400</span>|<span class=\"number\">800</span>)([<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">7</span>&#125;)|(<span class=\"number\">0</span>\\d&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;(-?)\\d&#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;)$/</span><br></pre></td></tr></table></figure>\n<h3 id=\"可视化在线校验工具\"><a href=\"#可视化在线校验工具\" class=\"headerlink\" title=\"可视化在线校验工具\"></a>可视化在线校验工具</h3><p><a href=\"https://www.debuggex.com/\" target=\"_blank\" rel=\"noopener\">https://www.debuggex.com/</a><br>很棒的在线工具，不仅可以帮你运算出结果，还可以让你结合图形一环一环的捋清验证的过程，方便你进行修改调试<br><img src=\"https://s1.ax1x.com/2018/10/15/iaMHVe.png\" alt=\"reg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为一枚程序猿，无论是前端还是后端，对正则都不会陌生。正则表达式对于处理字符串、对字符串制定验证规则有着强大而高效的能力。</p>\n<h3 id=\"什么是正则表达式？\"><a href=\"#什么是正则表达式？\" class=\"headerlink\" title=\"什么是正则表达式？\"></a>什么是正则表达式？</h3><p>正则表达式是使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。它可以针对特定要求完成我们对字符串的处理要求，在程序世界里使用广泛。特别是在表单输入验证的环节，正则表达式起到了举重若轻的作用。例如我们想要验证用户是否输入了一组6位数字就可以使用这样的规则：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">6</span>&#125;$/</span><br></pre></td></tr></table></figure></p>\n<p>这个例子只是简单让你知道正则表达式可以做什么，我们接下来从基础开始说起。</p>\n<h3 id=\"正则表达式对象及修饰符\"><a href=\"#正则表达式对象及修饰符\" class=\"headerlink\" title=\"正则表达式对象及修饰符\"></a>正则表达式对象及修饰符</h3><p>正则表达式对象有两种定义方式<br>1、构造函数定义<br>通过<code>new RegExp(pattern, attributes)</code>的方式构造，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"abc\"</span>,<span class=\"string\">\"g\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>其中pattern为表示表达式内容,上面的例子表示匹配abc.<br>attributes表示：</p>\n<blockquote>\n<p>g 全局匹配<br>i 不区分大小写<br>m 多行匹配</p>\n</blockquote>\n<p>2、文本定义<br><code>/pattern/attributes</code>,如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/g</span>;</span><br></pre></td></tr></table></figure></p>\n<p>等价于第一种构造函数方式</p>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\</td>\n<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，<code>&#39;n&#39;</code>匹配字符<code>n</code>。<code>&#39;\\n&#39;</code>匹配一个换行符。序列<code>&#39;\\\\&#39;</code>匹配 <code>\\</code>，而<code>&#39;\\(&#39;</code>则匹配<code>(</code></td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配一次或多次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配0次、1次或多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配0次或1次</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除换行符之外的任何字符</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n为非负整数，匹配n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>至少匹配n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配n~m次</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串开始，值得注意的是它还有另外一个含义。当在一组方括号里使用<code>^</code>时，它表示<code>非</code>或<code>排除</code>的意思，常常用来剔除某个字符</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串结束</td>\n</tr>\n<tr>\n<td>x&#124;y</td>\n<td>匹配x或y</td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>匹配xyz中的任一个字符</td>\n</tr>\n<tr>\n<td>[^xyx]</td>\n<td>匹配除xyz的任一个字符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>&quot;er\\b&quot;</code>可以匹配<code>&quot;never&quot;</code>中的<code>er</code>，但不能匹配<code>&quot;verb&quot;</code>中的<code>er</code></td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字，相当于[0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配非数字字符，相当于[^0-9]</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于[^\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母、数字、下划线。等价于[A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配非字母、数字、下划线。等价于[^A-Za-z0-9_]</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"非贪婪模式\"></a>非贪婪模式</h3><p><code>*</code>和<code>+</code>限定符都是贪婪的，他们会尽可能的多匹配字符，在其后面加上<code>?</code>便可以实现最小匹配。<br>如对于字符串starstarstar，<code>s.\\*r</code>匹配的是starstarstar，而<code>s.\\*?r</code>匹配的是star</p>\n<h3 id=\"正则相关方法\"><a href=\"#正则相关方法\" class=\"headerlink\" title=\"正则相关方法\"></a>正则相关方法</h3><h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><p><code>test()</code>是正则表达式方法，用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回<code>true</code>，否则返回<code>false</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reg为正则规则，str为待测试字符串</span></span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h4><p><code>exec()</code>是正则表达式方法，用于检索字符串中的正则表达式的匹配，该函数返回一个数组，存放匹配的结果。如果未找到匹配，则返回值为<code>null</code>。但若有匹配的情况下，<code>exec()</code>返回的数组长度永远为1。<code>exec()</code>方法受参数<code>g</code>影响,如果不指定<code>g</code>那么它永远返回第一个匹配值，如果指定了<code>g</code>那么下一次调用时它将从上一次结束的位置继续查找,下面这个例子可以很清楚的向你解释这一点：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"star1star2star3\"</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"star.\"</span>, <span class=\"string\">\"g\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.exec(str)[<span class=\"number\">0</span>]); <span class=\"comment\">// star1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.exec(str)[<span class=\"number\">0</span>]); <span class=\"comment\">// star2</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><p>以下方法皆为字符串方法。<br><code>match()</code>有点类似于<code>exec()</code>的作用，只不过当指定了g时，<code>match()</code>方法一次性返回所有匹配结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"star1star2star3\"</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"star.\"</span>, <span class=\"string\">\"g\"</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.exec(reg)); <span class=\"comment\">// [\"star1\",\"star2\",\"star3\"]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><p><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置，若无结果则返回<code>-1</code></p>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><p><code>split()</code>根据正则规则分割字符串返回数组</p>\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><p><code>replace()</code>方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br>$1,…$9: 正则表达式中有几个<code>()</code>，就会传递几个参数，$1~$9分别代表本次匹配中每个<code>()</code>提取的结果，最多9个<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mobile.replace(<span class=\"regexp\">/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/</span>, <span class=\"string\">\"$1****$2\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这是一个手机号加密的正则</p>\n<h3 id=\"常用正则\"><a href=\"#常用正则\" class=\"headerlink\" title=\"常用正则\"></a>常用正则</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手机号码</span></span><br><span class=\"line\">/^<span class=\"number\">1</span>([<span class=\"number\">358</span>][<span class=\"number\">0</span><span class=\"number\">-9</span>]|<span class=\"number\">4</span>[<span class=\"number\">579</span>]|<span class=\"number\">66</span>|<span class=\"number\">7</span>[<span class=\"number\">0135678</span>]|<span class=\"number\">9</span>[<span class=\"number\">89</span>])[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">8</span>&#125;$/</span><br><span class=\"line\"><span class=\"comment\">// 固定电话</span></span><br><span class=\"line\">/^(<span class=\"number\">400</span>|<span class=\"number\">800</span>)([<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">7</span>&#125;)|(<span class=\"number\">0</span>\\d&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;(-?)\\d&#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;)$/</span><br></pre></td></tr></table></figure>\n<h3 id=\"可视化在线校验工具\"><a href=\"#可视化在线校验工具\" class=\"headerlink\" title=\"可视化在线校验工具\"></a>可视化在线校验工具</h3><p><a href=\"https://www.debuggex.com/\" target=\"_blank\" rel=\"noopener\">https://www.debuggex.com/</a><br>很棒的在线工具，不仅可以帮你运算出结果，还可以让你结合图形一环一环的捋清验证的过程，方便你进行修改调试<br><img src=\"https://s1.ax1x.com/2018/10/15/iaMHVe.png\" alt=\"reg\"></p>\n"},{"title":"VUE使用小结——踩坑篇","date":"2018-07-27T12:00:17.000Z","urlname":"vue-damn-problems","toc":true,"_content":"\n相信不少朋友在一开始上手做VUE的项目前都没有仔细完整的阅读几遍文档及API，往往都是在项目的过程中有针对性的查阅，也因此踩了不少大坑小坑自己挖的坑。实际上初始阶段我们遇到的很多问题都可以轻易地在文档中找到答案。我也踩过不少类似的坑，这些坑在未来也可能会继续增加，我们不怕犯错误，只是不能总是犯相同的错误，也要思考为什么没有避免这些错误。改正过后把这些踩坑经历总结记录于此，也是给自己一点提醒。\n\n### 组件只能有一个根元素\n\n当我们兴致勃勃的建立好一个新的VUE项目并运行起来的时候，可能却并没有看到预期酷炫的页面，相反展现出来的是编译失败的错误提示:\n`Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.`\n\n那么很可能你组件中html的结构是类似于这样的：\n``` html\n<template>\n  <h3>{{ title }}</h3>\n  <div v-html=\"content\"></div>\n</template>\n```\n\n这就违背了vue中组件只能有一个根元素的原则，解决的方法也很简单，只要用一个父元素将这些内容包裹在一起就好了。\n``` html\n<template>\n  <div>\n    <h3>{{ title }}</h3>\n    <div v-html=\"content\"></div>\n  </div> \n</template>\n```\n\n### 修改数组视图无法更新\n\n我们都知道vue的特性之一是响应式，也就是当我们去修改vue实例中的数据时，视图也会及时更新。可当我们乐此不疲的沉醉于这个特性带给我们的便捷时却也惊奇的发现当我们修改了数组类型的变量时，视图无论如何也不发生改变，我们怀疑式地去通过vue-devtool工具查看变量的值，甚至丧心病狂的一遍遍打印变量的值都发现：没有错啊，数组确确实实已经发生了改变，可为什么视图没有进行更新呢？\n\n我们到文档中去找找答案。\n>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n当你修改数组的长度时，例如：vm.items.length = newLength\n\n这是官方文档中关于数组更新监测的注意事项，也就是说之所以视图没有更新，是我们直接通过索引来改变了数组中的某一项值或者直接通过修改length改变数组的长度，vue不能检测到这种情况下的变动。\n\n当你试图修改数据的某一个值时,正确的做法是通过Vue的`set`方法或者通过调用`splice()`变异方法触发试图更新：\n``` vue\nvm.$set(vm.items, indexOfItem, newValue)\n//或\nvm.items.splice(indexOfItem, 1, newValue)\n```\n\n而改变数组长度同样使用`splice()`方法：\n``` vue\nvm.items.splice(newLength)\n```\n\n掌握了这一条我们再也不会被视图更新的问题困扰了，是不是很棒呢！\n\n### 双向数据绑定失效\n\n常规来讲当我们在input上使用了`v-model`指令后，输入框的值会与数据进行同步，可当我们给`v-model`添加了`lazy`修饰符后，同步的条件便转为了`change`事件，所以当我们并不希望数据延迟同步的时候，切记不要使用`lazy`修饰符。\n\n### eventbus组件通信事件重复触发\n\n在使用了eventbus来处理组件通信的页面上，如果我们多切换几次路由再回来会发现监听事件触发了多次，这是什么原因呢？\n\n原来，由eventbus方式注册的事件是全局的，并且不会随着组件的销毁而自动注销，因此当我们反复进入这个组件时也就会多次注册这个相同的监听事件。为了验证，我们在这个组件里打印一下这个eventbus实例，看一看它里面是怎么样的：\n\n``` javascript\nmounted() {\n    // Bus为vue实例\n    console.log(Bus)\n    Bus.$on('freshDefault', (e) => {\n        this.getData()\n    })\n}\n```\n\n![console](https://app.yinxiang.com/shard/s51/res/8512e244-1fd7-4a9f-859e-fc04dc7ebbf0/TIM%E6%88%AA%E5%9B%BE20181012163545.png)\n\n进出几次这个页面后，我们看到`Bus`这个实例对象里已经有了4个`freshDefault`事件，这也就造成了事件的重复触发。\n\n如何避免这种情况出现，我们只要在组件销毁时移除这个事件监听器就可以了：\n\n``` javascript\nbeforeDestroy() { // 或destroyed\n    Bus.$off('freshDefault')\n}\n```\n\n这样就能保证相同的事件监听只会有一个注册。\n\n插一句，当路由A切换到路由B时，他们之间的过程是`B beforeCreate`=>`B created`=>`A beforeDestroy`=>`A destroyed`=>`B mounted`。牢记这个生命周期，它会对你产生帮助。\n\n（未完待续...)","source":"_posts/VUE使用小结——踩坑篇.md","raw":"---\ntitle: VUE使用小结——踩坑篇\ndate: 2018-07-27 20:00:17\nurlname:  vue-damn-problems\ncategories: [\"技术\"]\ntags: [\"前端\", \"vue\"]\ntoc: true\n---\n\n相信不少朋友在一开始上手做VUE的项目前都没有仔细完整的阅读几遍文档及API，往往都是在项目的过程中有针对性的查阅，也因此踩了不少大坑小坑自己挖的坑。实际上初始阶段我们遇到的很多问题都可以轻易地在文档中找到答案。我也踩过不少类似的坑，这些坑在未来也可能会继续增加，我们不怕犯错误，只是不能总是犯相同的错误，也要思考为什么没有避免这些错误。改正过后把这些踩坑经历总结记录于此，也是给自己一点提醒。\n\n### 组件只能有一个根元素\n\n当我们兴致勃勃的建立好一个新的VUE项目并运行起来的时候，可能却并没有看到预期酷炫的页面，相反展现出来的是编译失败的错误提示:\n`Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.`\n\n那么很可能你组件中html的结构是类似于这样的：\n``` html\n<template>\n  <h3>{{ title }}</h3>\n  <div v-html=\"content\"></div>\n</template>\n```\n\n这就违背了vue中组件只能有一个根元素的原则，解决的方法也很简单，只要用一个父元素将这些内容包裹在一起就好了。\n``` html\n<template>\n  <div>\n    <h3>{{ title }}</h3>\n    <div v-html=\"content\"></div>\n  </div> \n</template>\n```\n\n### 修改数组视图无法更新\n\n我们都知道vue的特性之一是响应式，也就是当我们去修改vue实例中的数据时，视图也会及时更新。可当我们乐此不疲的沉醉于这个特性带给我们的便捷时却也惊奇的发现当我们修改了数组类型的变量时，视图无论如何也不发生改变，我们怀疑式地去通过vue-devtool工具查看变量的值，甚至丧心病狂的一遍遍打印变量的值都发现：没有错啊，数组确确实实已经发生了改变，可为什么视图没有进行更新呢？\n\n我们到文档中去找找答案。\n>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n当你修改数组的长度时，例如：vm.items.length = newLength\n\n这是官方文档中关于数组更新监测的注意事项，也就是说之所以视图没有更新，是我们直接通过索引来改变了数组中的某一项值或者直接通过修改length改变数组的长度，vue不能检测到这种情况下的变动。\n\n当你试图修改数据的某一个值时,正确的做法是通过Vue的`set`方法或者通过调用`splice()`变异方法触发试图更新：\n``` vue\nvm.$set(vm.items, indexOfItem, newValue)\n//或\nvm.items.splice(indexOfItem, 1, newValue)\n```\n\n而改变数组长度同样使用`splice()`方法：\n``` vue\nvm.items.splice(newLength)\n```\n\n掌握了这一条我们再也不会被视图更新的问题困扰了，是不是很棒呢！\n\n### 双向数据绑定失效\n\n常规来讲当我们在input上使用了`v-model`指令后，输入框的值会与数据进行同步，可当我们给`v-model`添加了`lazy`修饰符后，同步的条件便转为了`change`事件，所以当我们并不希望数据延迟同步的时候，切记不要使用`lazy`修饰符。\n\n### eventbus组件通信事件重复触发\n\n在使用了eventbus来处理组件通信的页面上，如果我们多切换几次路由再回来会发现监听事件触发了多次，这是什么原因呢？\n\n原来，由eventbus方式注册的事件是全局的，并且不会随着组件的销毁而自动注销，因此当我们反复进入这个组件时也就会多次注册这个相同的监听事件。为了验证，我们在这个组件里打印一下这个eventbus实例，看一看它里面是怎么样的：\n\n``` javascript\nmounted() {\n    // Bus为vue实例\n    console.log(Bus)\n    Bus.$on('freshDefault', (e) => {\n        this.getData()\n    })\n}\n```\n\n![console](https://app.yinxiang.com/shard/s51/res/8512e244-1fd7-4a9f-859e-fc04dc7ebbf0/TIM%E6%88%AA%E5%9B%BE20181012163545.png)\n\n进出几次这个页面后，我们看到`Bus`这个实例对象里已经有了4个`freshDefault`事件，这也就造成了事件的重复触发。\n\n如何避免这种情况出现，我们只要在组件销毁时移除这个事件监听器就可以了：\n\n``` javascript\nbeforeDestroy() { // 或destroyed\n    Bus.$off('freshDefault')\n}\n```\n\n这样就能保证相同的事件监听只会有一个注册。\n\n插一句，当路由A切换到路由B时，他们之间的过程是`B beforeCreate`=>`B created`=>`A beforeDestroy`=>`A destroyed`=>`B mounted`。牢记这个生命周期，它会对你产生帮助。\n\n（未完待续...)","slug":"VUE使用小结——踩坑篇","published":1,"updated":"2018-11-16T15:30:15.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06tl000mxl69k4x6zs8p","content":"<p>相信不少朋友在一开始上手做VUE的项目前都没有仔细完整的阅读几遍文档及API，往往都是在项目的过程中有针对性的查阅，也因此踩了不少大坑小坑自己挖的坑。实际上初始阶段我们遇到的很多问题都可以轻易地在文档中找到答案。我也踩过不少类似的坑，这些坑在未来也可能会继续增加，我们不怕犯错误，只是不能总是犯相同的错误，也要思考为什么没有避免这些错误。改正过后把这些踩坑经历总结记录于此，也是给自己一点提醒。</p>\n<h3 id=\"组件只能有一个根元素\"><a href=\"#组件只能有一个根元素\" class=\"headerlink\" title=\"组件只能有一个根元素\"></a>组件只能有一个根元素</h3><p>当我们兴致勃勃的建立好一个新的VUE项目并运行起来的时候，可能却并没有看到预期酷炫的页面，相反展现出来的是编译失败的错误提示:<br><code>Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.</code></p>\n<p>那么很可能你组件中html的结构是类似于这样的：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这就违背了vue中组件只能有一个根元素的原则，解决的方法也很简单，只要用一个父元素将这些内容包裹在一起就好了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改数组视图无法更新\"><a href=\"#修改数组视图无法更新\" class=\"headerlink\" title=\"修改数组视图无法更新\"></a>修改数组视图无法更新</h3><p>我们都知道vue的特性之一是响应式，也就是当我们去修改vue实例中的数据时，视图也会及时更新。可当我们乐此不疲的沉醉于这个特性带给我们的便捷时却也惊奇的发现当我们修改了数组类型的变量时，视图无论如何也不发生改变，我们怀疑式地去通过vue-devtool工具查看变量的值，甚至丧心病狂的一遍遍打印变量的值都发现：没有错啊，数组确确实实已经发生了改变，可为什么视图没有进行更新呢？</p>\n<p>我们到文档中去找找答案。</p>\n<blockquote>\n<p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<br>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p>\n</blockquote>\n<p>这是官方文档中关于数组更新监测的注意事项，也就是说之所以视图没有更新，是我们直接通过索引来改变了数组中的某一项值或者直接通过修改length改变数组的长度，vue不能检测到这种情况下的变动。</p>\n<p>当你试图修改数据的某一个值时,正确的做法是通过Vue的<code>set</code>方法或者通过调用<code>splice()</code>变异方法触发试图更新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class=\"line\">//或</span><br><span class=\"line\">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure></p>\n<p>而改变数组长度同样使用<code>splice()</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure></p>\n<p>掌握了这一条我们再也不会被视图更新的问题困扰了，是不是很棒呢！</p>\n<h3 id=\"双向数据绑定失效\"><a href=\"#双向数据绑定失效\" class=\"headerlink\" title=\"双向数据绑定失效\"></a>双向数据绑定失效</h3><p>常规来讲当我们在input上使用了<code>v-model</code>指令后，输入框的值会与数据进行同步，可当我们给<code>v-model</code>添加了<code>lazy</code>修饰符后，同步的条件便转为了<code>change</code>事件，所以当我们并不希望数据延迟同步的时候，切记不要使用<code>lazy</code>修饰符。</p>\n<h3 id=\"eventbus组件通信事件重复触发\"><a href=\"#eventbus组件通信事件重复触发\" class=\"headerlink\" title=\"eventbus组件通信事件重复触发\"></a>eventbus组件通信事件重复触发</h3><p>在使用了eventbus来处理组件通信的页面上，如果我们多切换几次路由再回来会发现监听事件触发了多次，这是什么原因呢？</p>\n<p>原来，由eventbus方式注册的事件是全局的，并且不会随着组件的销毁而自动注销，因此当我们反复进入这个组件时也就会多次注册这个相同的监听事件。为了验证，我们在这个组件里打印一下这个eventbus实例，看一看它里面是怎么样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Bus为vue实例</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(Bus)</span><br><span class=\"line\">    Bus.$on(<span class=\"string\">'freshDefault'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.getData()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://app.yinxiang.com/shard/s51/res/8512e244-1fd7-4a9f-859e-fc04dc7ebbf0/TIM%E6%88%AA%E5%9B%BE20181012163545.png\" alt=\"console\"></p>\n<p>进出几次这个页面后，我们看到<code>Bus</code>这个实例对象里已经有了4个<code>freshDefault</code>事件，这也就造成了事件的重复触发。</p>\n<p>如何避免这种情况出现，我们只要在组件销毁时移除这个事件监听器就可以了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeDestroy() &#123; <span class=\"comment\">// 或destroyed</span></span><br><span class=\"line\">    Bus.$off(<span class=\"string\">'freshDefault'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就能保证相同的事件监听只会有一个注册。</p>\n<p>插一句，当路由A切换到路由B时，他们之间的过程是<code>B beforeCreate</code>=&gt;<code>B created</code>=&gt;<code>A beforeDestroy</code>=&gt;<code>A destroyed</code>=&gt;<code>B mounted</code>。牢记这个生命周期，它会对你产生帮助。</p>\n<p>（未完待续…)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信不少朋友在一开始上手做VUE的项目前都没有仔细完整的阅读几遍文档及API，往往都是在项目的过程中有针对性的查阅，也因此踩了不少大坑小坑自己挖的坑。实际上初始阶段我们遇到的很多问题都可以轻易地在文档中找到答案。我也踩过不少类似的坑，这些坑在未来也可能会继续增加，我们不怕犯错误，只是不能总是犯相同的错误，也要思考为什么没有避免这些错误。改正过后把这些踩坑经历总结记录于此，也是给自己一点提醒。</p>\n<h3 id=\"组件只能有一个根元素\"><a href=\"#组件只能有一个根元素\" class=\"headerlink\" title=\"组件只能有一个根元素\"></a>组件只能有一个根元素</h3><p>当我们兴致勃勃的建立好一个新的VUE项目并运行起来的时候，可能却并没有看到预期酷炫的页面，相反展现出来的是编译失败的错误提示:<br><code>Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.</code></p>\n<p>那么很可能你组件中html的结构是类似于这样的：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这就违背了vue中组件只能有一个根元素的原则，解决的方法也很简单，只要用一个父元素将这些内容包裹在一起就好了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改数组视图无法更新\"><a href=\"#修改数组视图无法更新\" class=\"headerlink\" title=\"修改数组视图无法更新\"></a>修改数组视图无法更新</h3><p>我们都知道vue的特性之一是响应式，也就是当我们去修改vue实例中的数据时，视图也会及时更新。可当我们乐此不疲的沉醉于这个特性带给我们的便捷时却也惊奇的发现当我们修改了数组类型的变量时，视图无论如何也不发生改变，我们怀疑式地去通过vue-devtool工具查看变量的值，甚至丧心病狂的一遍遍打印变量的值都发现：没有错啊，数组确确实实已经发生了改变，可为什么视图没有进行更新呢？</p>\n<p>我们到文档中去找找答案。</p>\n<blockquote>\n<p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<br>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p>\n</blockquote>\n<p>这是官方文档中关于数组更新监测的注意事项，也就是说之所以视图没有更新，是我们直接通过索引来改变了数组中的某一项值或者直接通过修改length改变数组的长度，vue不能检测到这种情况下的变动。</p>\n<p>当你试图修改数据的某一个值时,正确的做法是通过Vue的<code>set</code>方法或者通过调用<code>splice()</code>变异方法触发试图更新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class=\"line\">//或</span><br><span class=\"line\">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure></p>\n<p>而改变数组长度同样使用<code>splice()</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure></p>\n<p>掌握了这一条我们再也不会被视图更新的问题困扰了，是不是很棒呢！</p>\n<h3 id=\"双向数据绑定失效\"><a href=\"#双向数据绑定失效\" class=\"headerlink\" title=\"双向数据绑定失效\"></a>双向数据绑定失效</h3><p>常规来讲当我们在input上使用了<code>v-model</code>指令后，输入框的值会与数据进行同步，可当我们给<code>v-model</code>添加了<code>lazy</code>修饰符后，同步的条件便转为了<code>change</code>事件，所以当我们并不希望数据延迟同步的时候，切记不要使用<code>lazy</code>修饰符。</p>\n<h3 id=\"eventbus组件通信事件重复触发\"><a href=\"#eventbus组件通信事件重复触发\" class=\"headerlink\" title=\"eventbus组件通信事件重复触发\"></a>eventbus组件通信事件重复触发</h3><p>在使用了eventbus来处理组件通信的页面上，如果我们多切换几次路由再回来会发现监听事件触发了多次，这是什么原因呢？</p>\n<p>原来，由eventbus方式注册的事件是全局的，并且不会随着组件的销毁而自动注销，因此当我们反复进入这个组件时也就会多次注册这个相同的监听事件。为了验证，我们在这个组件里打印一下这个eventbus实例，看一看它里面是怎么样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Bus为vue实例</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(Bus)</span><br><span class=\"line\">    Bus.$on(<span class=\"string\">'freshDefault'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.getData()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://app.yinxiang.com/shard/s51/res/8512e244-1fd7-4a9f-859e-fc04dc7ebbf0/TIM%E6%88%AA%E5%9B%BE20181012163545.png\" alt=\"console\"></p>\n<p>进出几次这个页面后，我们看到<code>Bus</code>这个实例对象里已经有了4个<code>freshDefault</code>事件，这也就造成了事件的重复触发。</p>\n<p>如何避免这种情况出现，我们只要在组件销毁时移除这个事件监听器就可以了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeDestroy() &#123; <span class=\"comment\">// 或destroyed</span></span><br><span class=\"line\">    Bus.$off(<span class=\"string\">'freshDefault'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就能保证相同的事件监听只会有一个注册。</p>\n<p>插一句，当路由A切换到路由B时，他们之间的过程是<code>B beforeCreate</code>=&gt;<code>B created</code>=&gt;<code>A beforeDestroy</code>=&gt;<code>A destroyed</code>=&gt;<code>B mounted</code>。牢记这个生命周期，它会对你产生帮助。</p>\n<p>（未完待续…)</p>\n"},{"title":"二进制流图片转base64或blob地址","date":"2018-08-23T12:28:30.000Z","urlname":"arraybuffer-to-base64orblob","_content":"\n前不久做了一个在前端展示小程序二维码的需求，怎料后台给出的接口并没有返回图片url地址，而是直接以二进制流的形式返回了一张图片。\n\n### base64编码\n\n我们知道img标签的src属性通常接收的值是一个路径地址，既然没有路径那我们就考虑另外一种方法，即base64编码数据显示图片。\n\n来分析一下我们要做到把二进制流转换成base64编码都需要做哪些事情：\n\n一般情况下后台返回的响应数据类型是json,现在我们需要通过`responseType:arraybuffer`指定二进制流对应的响应类型`arraybuffer`。\n\n`ArrayBuffer`本质上是类型化数组，它作为内存区域，可以存放多种类型的数据。但`ArrayBuffer`不能直接操作，而是要通过类型数组对象或`DataView`对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。这些类型数组对象我们称为“视图”。有以下类型：\n>Int8Array：8位有符号整数，长度1个字节。\n>Uint8Array：8位无符号整数，长度1个字节。\n>Int16Array：16位有符号整数，长度2个字节。\n>Uint16Array：16位无符号整数，长度2个字节。\n>Int32Array：32位有符号整数，长度4个字节。\n>Uint32Array：32位无符号整数，长度4个字节。\n>Float32Array：32位浮点数，长度4个字节。\n>Float64Array：64位浮点数，长度8个字节。\n\n``` javascript\n// 创建一个指向后台返回的二进制流的Uint8视图\nnew Uint8Array(response.data)\n```\n这里我们在二进制流上建立一个Uint8的视图来对接收到的二进制流进行操作，将其转化为字符串。这就到了`String.fromCharCode()`方法登场的时间了。\n\n`fromCharCode()`可接受一个指定的`Unicode`值，然后返回一个字符串。而其实上面得到的视图是一组字节数组，和一般的数组基本无异。之前有看到别人在处理视图转成字符串用了`reduce()`方法：\n\n``` javascript\nnew Uint8Array(response.data).reduce((data, byte) => data + String.fromCharCode(byte), '')\n```\n利用了`reduce()`方法累加的作用将视图中的值一个一个的转成字符串然后拼接起来。`reduce() `方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n`array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`\n\n| 参数          | 描述   |\n| --------     | -----  |\n| total        | 必需。初始值, 或者计算结束后的返回值。 |\n| currentValue | 必需。当前元素 |\n| currentIndex | 可选。当前元素的索引   |\n| arr          | 可选。当前元素所属的数组对象  |\n| initialValue | 可选。传递给函数的初始值    |\n\n但其实`fromCharCode()`可以同时接受多个`Unicode`值，利用ES6的`...`扩展运算符可以将上面获得的类型化数组作为参数序列一次性将它们转化为字符串\n``` javascript\nString.fromCharCode(...new Uint8Array(response.data))\n```\n这样是不是优雅多了，现在我们已经得到了由初始的二进制流转化成的字符串，最后只要通过`btoa()`这个方法将字符串转化为base64编码的字符串再拼接在`data:image/jpeg;base64,`后面就可以放入src属性中使用了。\n\n最终的完整处理方式如下：\n``` javascript\nlet imgUrl = 'data:image/jpeg;base64,' + btoa(String.fromCharCode(...new Uint8Array(response.data)))\n```\n### blob对象\n\n转来转去我们总算是如愿的得到了我们想要的结果，但是在隐约中仿佛想起见过`blob:***`这样的图片地址，研究了一下不禁大拍脑门，之前的实现过程真的是绕了好大的弯，其实只要简简单单的两个语句就可以轻松实现这个需求：\n``` javascript\nvar blob = new Blob([response.data], {type: \"image/jpeg\"});\nvar imUrl = URL.createObjectURL(blob);\n```\nBlob对象表示一个不可变、原始数据的类文件对象,是一个可以存储二进制文件的容器。\n``` javascript\nvar blob = new Blob( array, options );\n```\n>* array是一个由ArrayBuffer,ArrayBufferView,Blob,DOMString等对象构成的Array，或者其他类似对象的混合体，它将会被放进Blob\n>* options提供了一个type属性，代表了将会被放入到blob中的数组内容的MIME类型，默认为`\"\"`\n\n后台给我们返回的数据刚好是`ArrayBuffer`,不用任何操作直接放进`Blob`对象，并指定图片`MIME`类型，我们就创建了一个存放这张图片的`Blob`对象，再通过`URL.createObjectURL()`方法创建一个指向`Blob`对象的URL，就可以直接拿来用了。\n\n### 结语\n\n这一次的探究找寻到的两种解决方案虽然难易程度相差比较大，但是过程中学习到的知识点还是很多的。可能如果先知道了第二种方法也就不会花时间去了解第一种方法的实现原理了。所以，相信过程吧，总不会是白忙活的。\n\n*部分内容参考自以下链接：*\n[https://www.cnblogs.com/copperhaze/p/6149041.html](https://www.cnblogs.com/copperhaze/p/6149041.html)\n[https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string](https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string)\n","source":"_posts/二进制流图片转base64或blob地址.md","raw":"---\ntitle: 二进制流图片转base64或blob地址\ndate: 2018-08-23 20:28:30\nurlname: arraybuffer-to-base64orblob\ncategories: [\"技术\"]\ntags: [\"JS\"]\n---\n\n前不久做了一个在前端展示小程序二维码的需求，怎料后台给出的接口并没有返回图片url地址，而是直接以二进制流的形式返回了一张图片。\n\n### base64编码\n\n我们知道img标签的src属性通常接收的值是一个路径地址，既然没有路径那我们就考虑另外一种方法，即base64编码数据显示图片。\n\n来分析一下我们要做到把二进制流转换成base64编码都需要做哪些事情：\n\n一般情况下后台返回的响应数据类型是json,现在我们需要通过`responseType:arraybuffer`指定二进制流对应的响应类型`arraybuffer`。\n\n`ArrayBuffer`本质上是类型化数组，它作为内存区域，可以存放多种类型的数据。但`ArrayBuffer`不能直接操作，而是要通过类型数组对象或`DataView`对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。这些类型数组对象我们称为“视图”。有以下类型：\n>Int8Array：8位有符号整数，长度1个字节。\n>Uint8Array：8位无符号整数，长度1个字节。\n>Int16Array：16位有符号整数，长度2个字节。\n>Uint16Array：16位无符号整数，长度2个字节。\n>Int32Array：32位有符号整数，长度4个字节。\n>Uint32Array：32位无符号整数，长度4个字节。\n>Float32Array：32位浮点数，长度4个字节。\n>Float64Array：64位浮点数，长度8个字节。\n\n``` javascript\n// 创建一个指向后台返回的二进制流的Uint8视图\nnew Uint8Array(response.data)\n```\n这里我们在二进制流上建立一个Uint8的视图来对接收到的二进制流进行操作，将其转化为字符串。这就到了`String.fromCharCode()`方法登场的时间了。\n\n`fromCharCode()`可接受一个指定的`Unicode`值，然后返回一个字符串。而其实上面得到的视图是一组字节数组，和一般的数组基本无异。之前有看到别人在处理视图转成字符串用了`reduce()`方法：\n\n``` javascript\nnew Uint8Array(response.data).reduce((data, byte) => data + String.fromCharCode(byte), '')\n```\n利用了`reduce()`方法累加的作用将视图中的值一个一个的转成字符串然后拼接起来。`reduce() `方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n`array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`\n\n| 参数          | 描述   |\n| --------     | -----  |\n| total        | 必需。初始值, 或者计算结束后的返回值。 |\n| currentValue | 必需。当前元素 |\n| currentIndex | 可选。当前元素的索引   |\n| arr          | 可选。当前元素所属的数组对象  |\n| initialValue | 可选。传递给函数的初始值    |\n\n但其实`fromCharCode()`可以同时接受多个`Unicode`值，利用ES6的`...`扩展运算符可以将上面获得的类型化数组作为参数序列一次性将它们转化为字符串\n``` javascript\nString.fromCharCode(...new Uint8Array(response.data))\n```\n这样是不是优雅多了，现在我们已经得到了由初始的二进制流转化成的字符串，最后只要通过`btoa()`这个方法将字符串转化为base64编码的字符串再拼接在`data:image/jpeg;base64,`后面就可以放入src属性中使用了。\n\n最终的完整处理方式如下：\n``` javascript\nlet imgUrl = 'data:image/jpeg;base64,' + btoa(String.fromCharCode(...new Uint8Array(response.data)))\n```\n### blob对象\n\n转来转去我们总算是如愿的得到了我们想要的结果，但是在隐约中仿佛想起见过`blob:***`这样的图片地址，研究了一下不禁大拍脑门，之前的实现过程真的是绕了好大的弯，其实只要简简单单的两个语句就可以轻松实现这个需求：\n``` javascript\nvar blob = new Blob([response.data], {type: \"image/jpeg\"});\nvar imUrl = URL.createObjectURL(blob);\n```\nBlob对象表示一个不可变、原始数据的类文件对象,是一个可以存储二进制文件的容器。\n``` javascript\nvar blob = new Blob( array, options );\n```\n>* array是一个由ArrayBuffer,ArrayBufferView,Blob,DOMString等对象构成的Array，或者其他类似对象的混合体，它将会被放进Blob\n>* options提供了一个type属性，代表了将会被放入到blob中的数组内容的MIME类型，默认为`\"\"`\n\n后台给我们返回的数据刚好是`ArrayBuffer`,不用任何操作直接放进`Blob`对象，并指定图片`MIME`类型，我们就创建了一个存放这张图片的`Blob`对象，再通过`URL.createObjectURL()`方法创建一个指向`Blob`对象的URL，就可以直接拿来用了。\n\n### 结语\n\n这一次的探究找寻到的两种解决方案虽然难易程度相差比较大，但是过程中学习到的知识点还是很多的。可能如果先知道了第二种方法也就不会花时间去了解第一种方法的实现原理了。所以，相信过程吧，总不会是白忙活的。\n\n*部分内容参考自以下链接：*\n[https://www.cnblogs.com/copperhaze/p/6149041.html](https://www.cnblogs.com/copperhaze/p/6149041.html)\n[https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string](https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string)\n","slug":"二进制流图片转base64或blob地址","published":1,"updated":"2018-11-16T15:30:15.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06tn000pxl69vvliey7r","content":"<p>前不久做了一个在前端展示小程序二维码的需求，怎料后台给出的接口并没有返回图片url地址，而是直接以二进制流的形式返回了一张图片。</p>\n<h3 id=\"base64编码\"><a href=\"#base64编码\" class=\"headerlink\" title=\"base64编码\"></a>base64编码</h3><p>我们知道img标签的src属性通常接收的值是一个路径地址，既然没有路径那我们就考虑另外一种方法，即base64编码数据显示图片。</p>\n<p>来分析一下我们要做到把二进制流转换成base64编码都需要做哪些事情：</p>\n<p>一般情况下后台返回的响应数据类型是json,现在我们需要通过<code>responseType:arraybuffer</code>指定二进制流对应的响应类型<code>arraybuffer</code>。</p>\n<p><code>ArrayBuffer</code>本质上是类型化数组，它作为内存区域，可以存放多种类型的数据。但<code>ArrayBuffer</code>不能直接操作，而是要通过类型数组对象或<code>DataView</code>对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。这些类型数组对象我们称为“视图”。有以下类型：</p>\n<blockquote>\n<p>Int8Array：8位有符号整数，长度1个字节。<br>Uint8Array：8位无符号整数，长度1个字节。<br>Int16Array：16位有符号整数，长度2个字节。<br>Uint16Array：16位无符号整数，长度2个字节。<br>Int32Array：32位有符号整数，长度4个字节。<br>Uint32Array：32位无符号整数，长度4个字节。<br>Float32Array：32位浮点数，长度4个字节。<br>Float64Array：64位浮点数，长度8个字节。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个指向后台返回的二进制流的Uint8视图</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(response.data)</span><br></pre></td></tr></table></figure>\n<p>这里我们在二进制流上建立一个Uint8的视图来对接收到的二进制流进行操作，将其转化为字符串。这就到了<code>String.fromCharCode()</code>方法登场的时间了。</p>\n<p><code>fromCharCode()</code>可接受一个指定的<code>Unicode</code>值，然后返回一个字符串。而其实上面得到的视图是一组字节数组，和一般的数组基本无异。之前有看到别人在处理视图转成字符串用了<code>reduce()</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(response.data).reduce(<span class=\"function\">(<span class=\"params\">data, byte</span>) =&gt;</span> data + <span class=\"built_in\">String</span>.fromCharCode(byte), <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>利用了<code>reduce()</code>方法累加的作用将视图中的值一个一个的转成字符串然后拼接起来。<code>reduce()</code>方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>total</td>\n<td>必需。初始值, 或者计算结束后的返回值。</td>\n</tr>\n<tr>\n<td>currentValue</td>\n<td>必需。当前元素</td>\n</tr>\n<tr>\n<td>currentIndex</td>\n<td>可选。当前元素的索引</td>\n</tr>\n<tr>\n<td>arr</td>\n<td>可选。当前元素所属的数组对象</td>\n</tr>\n<tr>\n<td>initialValue</td>\n<td>可选。传递给函数的初始值</td>\n</tr>\n</tbody>\n</table>\n<p>但其实<code>fromCharCode()</code>可以同时接受多个<code>Unicode</code>值，利用ES6的<code>...</code>扩展运算符可以将上面获得的类型化数组作为参数序列一次性将它们转化为字符串<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(...new <span class=\"built_in\">Uint8Array</span>(response.data))</span><br></pre></td></tr></table></figure></p>\n<p>这样是不是优雅多了，现在我们已经得到了由初始的二进制流转化成的字符串，最后只要通过<code>btoa()</code>这个方法将字符串转化为base64编码的字符串再拼接在<code>data:image/jpeg;base64,</code>后面就可以放入src属性中使用了。</p>\n<p>最终的完整处理方式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> imgUrl = <span class=\"string\">'data:image/jpeg;base64,'</span> + btoa(<span class=\"built_in\">String</span>.fromCharCode(...new <span class=\"built_in\">Uint8Array</span>(response.data)))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"blob对象\"><a href=\"#blob对象\" class=\"headerlink\" title=\"blob对象\"></a>blob对象</h3><p>转来转去我们总算是如愿的得到了我们想要的结果，但是在隐约中仿佛想起见过<code>blob:***</code>这样的图片地址，研究了一下不禁大拍脑门，之前的实现过程真的是绕了好大的弯，其实只要简简单单的两个语句就可以轻松实现这个需求：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([response.data], &#123;<span class=\"attr\">type</span>: <span class=\"string\">\"image/jpeg\"</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> imUrl = URL.createObjectURL(blob);</span><br></pre></td></tr></table></figure></p>\n<p>Blob对象表示一个不可变、原始数据的类文件对象,是一个可以存储二进制文件的容器。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob( array, options );</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ul>\n<li>array是一个由ArrayBuffer,ArrayBufferView,Blob,DOMString等对象构成的Array，或者其他类似对象的混合体，它将会被放进Blob</li>\n<li>options提供了一个type属性，代表了将会被放入到blob中的数组内容的MIME类型，默认为<code>&quot;&quot;</code></li>\n</ul>\n</blockquote>\n<p>后台给我们返回的数据刚好是<code>ArrayBuffer</code>,不用任何操作直接放进<code>Blob</code>对象，并指定图片<code>MIME</code>类型，我们就创建了一个存放这张图片的<code>Blob</code>对象，再通过<code>URL.createObjectURL()</code>方法创建一个指向<code>Blob</code>对象的URL，就可以直接拿来用了。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>这一次的探究找寻到的两种解决方案虽然难易程度相差比较大，但是过程中学习到的知识点还是很多的。可能如果先知道了第二种方法也就不会花时间去了解第一种方法的实现原理了。所以，相信过程吧，总不会是白忙活的。</p>\n<p><em>部分内容参考自以下链接：</em><br><a href=\"https://www.cnblogs.com/copperhaze/p/6149041.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/copperhaze/p/6149041.html</a><br><a href=\"https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前不久做了一个在前端展示小程序二维码的需求，怎料后台给出的接口并没有返回图片url地址，而是直接以二进制流的形式返回了一张图片。</p>\n<h3 id=\"base64编码\"><a href=\"#base64编码\" class=\"headerlink\" title=\"base64编码\"></a>base64编码</h3><p>我们知道img标签的src属性通常接收的值是一个路径地址，既然没有路径那我们就考虑另外一种方法，即base64编码数据显示图片。</p>\n<p>来分析一下我们要做到把二进制流转换成base64编码都需要做哪些事情：</p>\n<p>一般情况下后台返回的响应数据类型是json,现在我们需要通过<code>responseType:arraybuffer</code>指定二进制流对应的响应类型<code>arraybuffer</code>。</p>\n<p><code>ArrayBuffer</code>本质上是类型化数组，它作为内存区域，可以存放多种类型的数据。但<code>ArrayBuffer</code>不能直接操作，而是要通过类型数组对象或<code>DataView</code>对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。这些类型数组对象我们称为“视图”。有以下类型：</p>\n<blockquote>\n<p>Int8Array：8位有符号整数，长度1个字节。<br>Uint8Array：8位无符号整数，长度1个字节。<br>Int16Array：16位有符号整数，长度2个字节。<br>Uint16Array：16位无符号整数，长度2个字节。<br>Int32Array：32位有符号整数，长度4个字节。<br>Uint32Array：32位无符号整数，长度4个字节。<br>Float32Array：32位浮点数，长度4个字节。<br>Float64Array：64位浮点数，长度8个字节。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个指向后台返回的二进制流的Uint8视图</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(response.data)</span><br></pre></td></tr></table></figure>\n<p>这里我们在二进制流上建立一个Uint8的视图来对接收到的二进制流进行操作，将其转化为字符串。这就到了<code>String.fromCharCode()</code>方法登场的时间了。</p>\n<p><code>fromCharCode()</code>可接受一个指定的<code>Unicode</code>值，然后返回一个字符串。而其实上面得到的视图是一组字节数组，和一般的数组基本无异。之前有看到别人在处理视图转成字符串用了<code>reduce()</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(response.data).reduce(<span class=\"function\">(<span class=\"params\">data, byte</span>) =&gt;</span> data + <span class=\"built_in\">String</span>.fromCharCode(byte), <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>利用了<code>reduce()</code>方法累加的作用将视图中的值一个一个的转成字符串然后拼接起来。<code>reduce()</code>方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>total</td>\n<td>必需。初始值, 或者计算结束后的返回值。</td>\n</tr>\n<tr>\n<td>currentValue</td>\n<td>必需。当前元素</td>\n</tr>\n<tr>\n<td>currentIndex</td>\n<td>可选。当前元素的索引</td>\n</tr>\n<tr>\n<td>arr</td>\n<td>可选。当前元素所属的数组对象</td>\n</tr>\n<tr>\n<td>initialValue</td>\n<td>可选。传递给函数的初始值</td>\n</tr>\n</tbody>\n</table>\n<p>但其实<code>fromCharCode()</code>可以同时接受多个<code>Unicode</code>值，利用ES6的<code>...</code>扩展运算符可以将上面获得的类型化数组作为参数序列一次性将它们转化为字符串<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(...new <span class=\"built_in\">Uint8Array</span>(response.data))</span><br></pre></td></tr></table></figure></p>\n<p>这样是不是优雅多了，现在我们已经得到了由初始的二进制流转化成的字符串，最后只要通过<code>btoa()</code>这个方法将字符串转化为base64编码的字符串再拼接在<code>data:image/jpeg;base64,</code>后面就可以放入src属性中使用了。</p>\n<p>最终的完整处理方式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> imgUrl = <span class=\"string\">'data:image/jpeg;base64,'</span> + btoa(<span class=\"built_in\">String</span>.fromCharCode(...new <span class=\"built_in\">Uint8Array</span>(response.data)))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"blob对象\"><a href=\"#blob对象\" class=\"headerlink\" title=\"blob对象\"></a>blob对象</h3><p>转来转去我们总算是如愿的得到了我们想要的结果，但是在隐约中仿佛想起见过<code>blob:***</code>这样的图片地址，研究了一下不禁大拍脑门，之前的实现过程真的是绕了好大的弯，其实只要简简单单的两个语句就可以轻松实现这个需求：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([response.data], &#123;<span class=\"attr\">type</span>: <span class=\"string\">\"image/jpeg\"</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> imUrl = URL.createObjectURL(blob);</span><br></pre></td></tr></table></figure></p>\n<p>Blob对象表示一个不可变、原始数据的类文件对象,是一个可以存储二进制文件的容器。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob( array, options );</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ul>\n<li>array是一个由ArrayBuffer,ArrayBufferView,Blob,DOMString等对象构成的Array，或者其他类似对象的混合体，它将会被放进Blob</li>\n<li>options提供了一个type属性，代表了将会被放入到blob中的数组内容的MIME类型，默认为<code>&quot;&quot;</code></li>\n</ul>\n</blockquote>\n<p>后台给我们返回的数据刚好是<code>ArrayBuffer</code>,不用任何操作直接放进<code>Blob</code>对象，并指定图片<code>MIME</code>类型，我们就创建了一个存放这张图片的<code>Blob</code>对象，再通过<code>URL.createObjectURL()</code>方法创建一个指向<code>Blob</code>对象的URL，就可以直接拿来用了。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>这一次的探究找寻到的两种解决方案虽然难易程度相差比较大，但是过程中学习到的知识点还是很多的。可能如果先知道了第二种方法也就不会花时间去了解第一种方法的实现原理了。所以，相信过程吧，总不会是白忙活的。</p>\n<p><em>部分内容参考自以下链接：</em><br><a href=\"https://www.cnblogs.com/copperhaze/p/6149041.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/copperhaze/p/6149041.html</a><br><a href=\"https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string</a></p>\n"},{"title":"解决MAC执行.sh文件报错","date":"2018-07-01T09:52:31.000Z","urlname":"mac-sh-wrong","_content":"\n### 问题出现\n\n4月初进入到了一家新公司，在使用公司下发的`.sh`的文件生成git秘钥时却发现用我自己的MAC打开输入几步操作后显示报错，几次尝试过后还是不行。无奈只好先使用公司的windows机先pull代码熟悉项目。\n\n### 探寻问题\n\n但是问题既然出现了就应该好好探究一番，更何况有的时候在家里需要对代码进行一些紧急的修改，不能拉取推送代码也着实不方便，经过一番查找很快便有了答案。\n\n### 水落石出\n\n原来，由于Linux和windows的文本格式不同，所以对于`.sh`需要先进行转换，可以先在终端通过\n``` bash\nvi text.sh\n```\n新建一个`.sh`文件，然后输入`i`进入编辑模式，将原来`.sh`中的命令复制进来`ESC`退出编辑，`:wq`保存\n这时候再运行新建的`.sh`文件，这个时候可能会报`permission denied`的错误，没关系只要再执行一下\n``` bash\nchmod 777 text.sh\n```\n修改权限就可以了，再运行就不会报错了。\n\n### 新的问题\n\n至此我已经可以成功执行`.sh`里的命令生成公钥了，但是clone项目的时候又报错了，没关系，仍然是权限的问题，再对秘钥文件执行一下\n``` bash\nchmod 777 或 chmod 600\n```\n就没问题了！\n\n希望本文能帮助到其他人\n","source":"_posts/解决MAC执行.sh文件报错.md","raw":"---\ntitle: 解决MAC执行.sh文件报错\ndate: 2018-07-01 17:52:31\nurlname: mac-sh-wrong\ncategories: [\"技术\"]\ntags: [\"操作系统\", \"MAC\"]\n---\n\n### 问题出现\n\n4月初进入到了一家新公司，在使用公司下发的`.sh`的文件生成git秘钥时却发现用我自己的MAC打开输入几步操作后显示报错，几次尝试过后还是不行。无奈只好先使用公司的windows机先pull代码熟悉项目。\n\n### 探寻问题\n\n但是问题既然出现了就应该好好探究一番，更何况有的时候在家里需要对代码进行一些紧急的修改，不能拉取推送代码也着实不方便，经过一番查找很快便有了答案。\n\n### 水落石出\n\n原来，由于Linux和windows的文本格式不同，所以对于`.sh`需要先进行转换，可以先在终端通过\n``` bash\nvi text.sh\n```\n新建一个`.sh`文件，然后输入`i`进入编辑模式，将原来`.sh`中的命令复制进来`ESC`退出编辑，`:wq`保存\n这时候再运行新建的`.sh`文件，这个时候可能会报`permission denied`的错误，没关系只要再执行一下\n``` bash\nchmod 777 text.sh\n```\n修改权限就可以了，再运行就不会报错了。\n\n### 新的问题\n\n至此我已经可以成功执行`.sh`里的命令生成公钥了，但是clone项目的时候又报错了，没关系，仍然是权限的问题，再对秘钥文件执行一下\n``` bash\nchmod 777 或 chmod 600\n```\n就没问题了！\n\n希望本文能帮助到其他人\n","slug":"解决MAC执行.sh文件报错","published":1,"updated":"2018-11-16T15:30:15.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06ts000uxl69ezx65t1e","content":"<h3 id=\"问题出现\"><a href=\"#问题出现\" class=\"headerlink\" title=\"问题出现\"></a>问题出现</h3><p>4月初进入到了一家新公司，在使用公司下发的<code>.sh</code>的文件生成git秘钥时却发现用我自己的MAC打开输入几步操作后显示报错，几次尝试过后还是不行。无奈只好先使用公司的windows机先pull代码熟悉项目。</p>\n<h3 id=\"探寻问题\"><a href=\"#探寻问题\" class=\"headerlink\" title=\"探寻问题\"></a>探寻问题</h3><p>但是问题既然出现了就应该好好探究一番，更何况有的时候在家里需要对代码进行一些紧急的修改，不能拉取推送代码也着实不方便，经过一番查找很快便有了答案。</p>\n<h3 id=\"水落石出\"><a href=\"#水落石出\" class=\"headerlink\" title=\"水落石出\"></a>水落石出</h3><p>原来，由于Linux和windows的文本格式不同，所以对于<code>.sh</code>需要先进行转换，可以先在终端通过<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi text.sh</span><br></pre></td></tr></table></figure></p>\n<p>新建一个<code>.sh</code>文件，然后输入<code>i</code>进入编辑模式，将原来<code>.sh</code>中的命令复制进来<code>ESC</code>退出编辑，<code>:wq</code>保存<br>这时候再运行新建的<code>.sh</code>文件，这个时候可能会报<code>permission denied</code>的错误，没关系只要再执行一下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 text.sh</span><br></pre></td></tr></table></figure></p>\n<p>修改权限就可以了，再运行就不会报错了。</p>\n<h3 id=\"新的问题\"><a href=\"#新的问题\" class=\"headerlink\" title=\"新的问题\"></a>新的问题</h3><p>至此我已经可以成功执行<code>.sh</code>里的命令生成公钥了，但是clone项目的时候又报错了，没关系，仍然是权限的问题，再对秘钥文件执行一下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 或 chmod 600</span><br></pre></td></tr></table></figure></p>\n<p>就没问题了！</p>\n<p>希望本文能帮助到其他人</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"问题出现\"><a href=\"#问题出现\" class=\"headerlink\" title=\"问题出现\"></a>问题出现</h3><p>4月初进入到了一家新公司，在使用公司下发的<code>.sh</code>的文件生成git秘钥时却发现用我自己的MAC打开输入几步操作后显示报错，几次尝试过后还是不行。无奈只好先使用公司的windows机先pull代码熟悉项目。</p>\n<h3 id=\"探寻问题\"><a href=\"#探寻问题\" class=\"headerlink\" title=\"探寻问题\"></a>探寻问题</h3><p>但是问题既然出现了就应该好好探究一番，更何况有的时候在家里需要对代码进行一些紧急的修改，不能拉取推送代码也着实不方便，经过一番查找很快便有了答案。</p>\n<h3 id=\"水落石出\"><a href=\"#水落石出\" class=\"headerlink\" title=\"水落石出\"></a>水落石出</h3><p>原来，由于Linux和windows的文本格式不同，所以对于<code>.sh</code>需要先进行转换，可以先在终端通过<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi text.sh</span><br></pre></td></tr></table></figure></p>\n<p>新建一个<code>.sh</code>文件，然后输入<code>i</code>进入编辑模式，将原来<code>.sh</code>中的命令复制进来<code>ESC</code>退出编辑，<code>:wq</code>保存<br>这时候再运行新建的<code>.sh</code>文件，这个时候可能会报<code>permission denied</code>的错误，没关系只要再执行一下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 text.sh</span><br></pre></td></tr></table></figure></p>\n<p>修改权限就可以了，再运行就不会报错了。</p>\n<h3 id=\"新的问题\"><a href=\"#新的问题\" class=\"headerlink\" title=\"新的问题\"></a>新的问题</h3><p>至此我已经可以成功执行<code>.sh</code>里的命令生成公钥了，但是clone项目的时候又报错了，没关系，仍然是权限的问题，再对秘钥文件执行一下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 或 chmod 600</span><br></pre></td></tr></table></figure></p>\n<p>就没问题了！</p>\n<p>希望本文能帮助到其他人</p>\n"},{"title":"解惑JavaScript中的this指向问题","subtitle":"this的绑定取决于函数的调用方式","date":"2018-11-01T13:10:25.000Z","urlname":"javascript-this-disabuse","toc":true,"_content":"\n### 消除错误认知\n\n首先，我们必须要消除的两个关于this的误解：\n\n> * 指向函数自身\n> * 指向函数作用域\n\n需要牢记的是，this在任何情况下都不指向函数的词法作用域，`this的绑定取决于函数的调用方式`。\n\n### 绑定规则\n\n既然明确了this的绑定和调用方式有关，我们就可以根据不同的情况来判断指向结果，我们可以认为这是一组绑定规则。\n\n#### 1、默认绑定\n\n这适用于最最普通的函数调用，没有其余规则掺杂，仅仅针对于独立函数。\n\n``` javascript\nfunction foo(){\n    console.log(this) //window\n}\nfoo()\n```\n\n可以看到，此时函数foo中的this指向的是window。这是因为默认绑定规则下，this指向全局。但这只是在非严格模式下，如果是在严格模式下，this会绑定到undefined。\n\n#### 2、隐式绑定\n\n当函数的调用位置有上下文对象（也就是通过对象方法调用）时，this指向这个上下文对象。\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nobj.foo() // 2\n```\n\n而当出现多级调用时，this绑定的是离它最近的一个上下文对象。\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj1 = {\n    a: 1,\n    foo: foo\n}\nvar obj2 = {\n    a: 2,\n    obj1: obj1\n}\nobj2.obj1.foo() // 1\n```\n\n注意该规则针对于对象方法调用，像下面这样实际还是默认绑定：\n\n``` javascript\nvar a = 1\nvar obj = {\n    a:2,\n    foo:function(){\n        var fn = function(){\n            console.log(this.a) // 1\n        }\n        fn() // fn没有对象调用，this绑定全局\n    }\n}\nobj.foo()\n```\n\n可是这种隐式绑定this会丢失绑定的对象，常见的两种情况是引用赋值和回调函数：\n\n（1）引用赋值\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nvar bar = obj.foo // 函数别名！\nvar a = 1\nobj.foo() // 2\nbar() // 1\n```\n\n这里看起来bar()和obj.foo()是一样的，但其实bar引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n\n（2）回调函数\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo\n    fn() // <-- 调用位置！\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nvar a = 1 // a 是全局对象的属性\ndoFoo( obj.foo ) // 1\n```\n\n看到了吧，传入回调函数的方法绑定的this也应用了默认绑定规则，这也解释了为什么`setTimeout`方法中回调函数的this会指向window，因为其运行在与所在函数完全分离的执行环境上。\n\n#### 3、显式绑定\n\n若要强制的调用不属于对象内部的方法，将this绑定到对象上面可以使用`call()`和`apply()`方法，这两个方法都可以实现改变this指向，它们接受的第一个参数都是要绑定this的对象。区别在于：`call()`从第二个参数开始接受传递给方法的参数，可以有多个，而`apply()`最多接受两个参数，第二个参数为一个数组，用来给方法传参。\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj = {\n    a:2\n}\nfoo.call( obj ) // 2\n```\n\n函数foo中的this被强制的绑定到了obj这个对象上。\n\n还可以使用`bind()`方法创建一个新的函数，`bind()`方法中指定一个参数作为this上下文。\n\n#### 4、new绑定\n\n最后一种绑定规则，如果在一个函数前面带上new来调用，那么将会创建一个新对象，同时函数中的this会绑定到这个新对象上。在 JavaScript 中，把这些使用new操作符时被调用的函数称为构造函数。\n\n``` javascript\nfunction foo(a) {\n    this.a = a\n    console.log(this)\n}\nvar bar = new foo(2) // foo {a: 2}\n```\n\n如此，foo中的this就被绑定到了bar上。\n\n### 优先级\n\n介绍了各种this绑定规则，那么当不同的调用规则混合使用时，我们就需要判断优先级，而new绑定高于显式绑定高于隐式绑定高于默认绑定。\n\n因此我们可以得出以下的判断方法：\n\n>1、由 new 调用？绑定到新创建的对象。\n2、由 call 或者 apply（或者 bind）调用？绑定到指定的对象。\n3、由上下文对象调用？绑定到那个上下文对象。\n4、默认：在严格模式下绑定到 undefined，否则绑定到全局对象。\n\n### 箭头函数中的this\n\n不同于前面介绍的四种绑定规则，箭头函数内部的this是词法作用域，由上下文确定，因此箭头函数中的this指向的是定义时的this，而不是执行时的this，并且箭头函数的绑定无法修改。\n\n``` javascript\nvar obj = {\n    a:1,\n    foo:function(){\n        setTimeout(()=>{\n            // this指向obj\n            console.log(this.a)\n        },1000)\n    }\n}\nvar a = 2\nobj.foo() // 1而不是2\n```\n\n``` javascript\nvar obj = {\n    a:1,\n    foo:()=>{\n        // this指向window\n        console.log(this.a)\n    }\n}\nvar a = 2\nobj.foo() // 2而不是1\n```\n\n上述两段代码都是使用了箭头函数，可为什么结果不尽相同？\n\n要记住，箭头函数中的this是根据定义时的上下文决定的，第一段代码中setTimeout中的箭头函数定义在foo中，而foo的上一级是obj，所以this指向obj。而第二段代码的箭头函数是定义在obj中，obj的上一级是全局，因此this指向全局。\n\n***\n\n到此我们就已经介绍了this的全部绑定情况，虽然例子举得简单，但是明确了判断规则后，相信你再不会被小小的this难住。\n\n*&#42;本文根据**《你不知道的JavaScript（上）》**第二部分第二章整理总结*\n\n","source":"_posts/解惑JavaScript中的this指向问题.md","raw":"---\ntitle: 解惑JavaScript中的this指向问题\nsubtitle: this的绑定取决于函数的调用方式\ndate: 2018-11-01 21:10:25\nurlname: javascript-this-disabuse\ncategories: [\"技术\"]\ntags: [\"JS\"]\ntoc: true\n---\n\n### 消除错误认知\n\n首先，我们必须要消除的两个关于this的误解：\n\n> * 指向函数自身\n> * 指向函数作用域\n\n需要牢记的是，this在任何情况下都不指向函数的词法作用域，`this的绑定取决于函数的调用方式`。\n\n### 绑定规则\n\n既然明确了this的绑定和调用方式有关，我们就可以根据不同的情况来判断指向结果，我们可以认为这是一组绑定规则。\n\n#### 1、默认绑定\n\n这适用于最最普通的函数调用，没有其余规则掺杂，仅仅针对于独立函数。\n\n``` javascript\nfunction foo(){\n    console.log(this) //window\n}\nfoo()\n```\n\n可以看到，此时函数foo中的this指向的是window。这是因为默认绑定规则下，this指向全局。但这只是在非严格模式下，如果是在严格模式下，this会绑定到undefined。\n\n#### 2、隐式绑定\n\n当函数的调用位置有上下文对象（也就是通过对象方法调用）时，this指向这个上下文对象。\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nobj.foo() // 2\n```\n\n而当出现多级调用时，this绑定的是离它最近的一个上下文对象。\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj1 = {\n    a: 1,\n    foo: foo\n}\nvar obj2 = {\n    a: 2,\n    obj1: obj1\n}\nobj2.obj1.foo() // 1\n```\n\n注意该规则针对于对象方法调用，像下面这样实际还是默认绑定：\n\n``` javascript\nvar a = 1\nvar obj = {\n    a:2,\n    foo:function(){\n        var fn = function(){\n            console.log(this.a) // 1\n        }\n        fn() // fn没有对象调用，this绑定全局\n    }\n}\nobj.foo()\n```\n\n可是这种隐式绑定this会丢失绑定的对象，常见的两种情况是引用赋值和回调函数：\n\n（1）引用赋值\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nvar bar = obj.foo // 函数别名！\nvar a = 1\nobj.foo() // 2\nbar() // 1\n```\n\n这里看起来bar()和obj.foo()是一样的，但其实bar引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n\n（2）回调函数\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo\n    fn() // <-- 调用位置！\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nvar a = 1 // a 是全局对象的属性\ndoFoo( obj.foo ) // 1\n```\n\n看到了吧，传入回调函数的方法绑定的this也应用了默认绑定规则，这也解释了为什么`setTimeout`方法中回调函数的this会指向window，因为其运行在与所在函数完全分离的执行环境上。\n\n#### 3、显式绑定\n\n若要强制的调用不属于对象内部的方法，将this绑定到对象上面可以使用`call()`和`apply()`方法，这两个方法都可以实现改变this指向，它们接受的第一个参数都是要绑定this的对象。区别在于：`call()`从第二个参数开始接受传递给方法的参数，可以有多个，而`apply()`最多接受两个参数，第二个参数为一个数组，用来给方法传参。\n\n``` javascript\nfunction foo() {\n    console.log( this.a )\n}\nvar obj = {\n    a:2\n}\nfoo.call( obj ) // 2\n```\n\n函数foo中的this被强制的绑定到了obj这个对象上。\n\n还可以使用`bind()`方法创建一个新的函数，`bind()`方法中指定一个参数作为this上下文。\n\n#### 4、new绑定\n\n最后一种绑定规则，如果在一个函数前面带上new来调用，那么将会创建一个新对象，同时函数中的this会绑定到这个新对象上。在 JavaScript 中，把这些使用new操作符时被调用的函数称为构造函数。\n\n``` javascript\nfunction foo(a) {\n    this.a = a\n    console.log(this)\n}\nvar bar = new foo(2) // foo {a: 2}\n```\n\n如此，foo中的this就被绑定到了bar上。\n\n### 优先级\n\n介绍了各种this绑定规则，那么当不同的调用规则混合使用时，我们就需要判断优先级，而new绑定高于显式绑定高于隐式绑定高于默认绑定。\n\n因此我们可以得出以下的判断方法：\n\n>1、由 new 调用？绑定到新创建的对象。\n2、由 call 或者 apply（或者 bind）调用？绑定到指定的对象。\n3、由上下文对象调用？绑定到那个上下文对象。\n4、默认：在严格模式下绑定到 undefined，否则绑定到全局对象。\n\n### 箭头函数中的this\n\n不同于前面介绍的四种绑定规则，箭头函数内部的this是词法作用域，由上下文确定，因此箭头函数中的this指向的是定义时的this，而不是执行时的this，并且箭头函数的绑定无法修改。\n\n``` javascript\nvar obj = {\n    a:1,\n    foo:function(){\n        setTimeout(()=>{\n            // this指向obj\n            console.log(this.a)\n        },1000)\n    }\n}\nvar a = 2\nobj.foo() // 1而不是2\n```\n\n``` javascript\nvar obj = {\n    a:1,\n    foo:()=>{\n        // this指向window\n        console.log(this.a)\n    }\n}\nvar a = 2\nobj.foo() // 2而不是1\n```\n\n上述两段代码都是使用了箭头函数，可为什么结果不尽相同？\n\n要记住，箭头函数中的this是根据定义时的上下文决定的，第一段代码中setTimeout中的箭头函数定义在foo中，而foo的上一级是obj，所以this指向obj。而第二段代码的箭头函数是定义在obj中，obj的上一级是全局，因此this指向全局。\n\n***\n\n到此我们就已经介绍了this的全部绑定情况，虽然例子举得简单，但是明确了判断规则后，相信你再不会被小小的this难住。\n\n*&#42;本文根据**《你不知道的JavaScript（上）》**第二部分第二章整理总结*\n\n","slug":"解惑JavaScript中的this指向问题","published":1,"updated":"2018-11-16T15:30:15.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06tv000xxl69qp1grvet","content":"<h3 id=\"消除错误认知\"><a href=\"#消除错误认知\" class=\"headerlink\" title=\"消除错误认知\"></a>消除错误认知</h3><p>首先，我们必须要消除的两个关于this的误解：</p>\n<blockquote>\n<ul>\n<li>指向函数自身</li>\n<li>指向函数作用域</li>\n</ul>\n</blockquote>\n<p>需要牢记的是，this在任何情况下都不指向函数的词法作用域，<code>this的绑定取决于函数的调用方式</code>。</p>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>既然明确了this的绑定和调用方式有关，我们就可以根据不同的情况来判断指向结果，我们可以认为这是一组绑定规则。</p>\n<h4 id=\"1、默认绑定\"><a href=\"#1、默认绑定\" class=\"headerlink\" title=\"1、默认绑定\"></a>1、默认绑定</h4><p>这适用于最最普通的函数调用，没有其余规则掺杂，仅仅针对于独立函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//window</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>可以看到，此时函数foo中的this指向的是window。这是因为默认绑定规则下，this指向全局。但这只是在非严格模式下，如果是在严格模式下，this会绑定到undefined。</p>\n<h4 id=\"2、隐式绑定\"><a href=\"#2、隐式绑定\" class=\"headerlink\" title=\"2、隐式绑定\"></a>2、隐式绑定</h4><p>当函数的调用位置有上下文对象（也就是通过对象方法调用）时，this指向这个上下文对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>而当出现多级调用时，this绑定的是离它最近的一个上下文对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj1: obj1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj2.obj1.foo() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>注意该规则针对于对象方法调用，像下面这样实际还是默认绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// 1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fn() <span class=\"comment\">// fn没有对象调用，this绑定全局</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo()</span><br></pre></td></tr></table></figure>\n<p>可是这种隐式绑定this会丢失绑定的对象，常见的两种情况是引用赋值和回调函数：</p>\n<p>（1）引用赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo <span class=\"comment\">// 函数别名！</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2</span></span><br><span class=\"line\">bar() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>这里看起来bar()和obj.foo()是一样的，但其实bar引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>\n<p>（2）回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fn 其实引用的是 foo</span></span><br><span class=\"line\">    fn() <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span> <span class=\"comment\">// a 是全局对象的属性</span></span><br><span class=\"line\">doFoo( obj.foo ) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>看到了吧，传入回调函数的方法绑定的this也应用了默认绑定规则，这也解释了为什么<code>setTimeout</code>方法中回调函数的this会指向window，因为其运行在与所在函数完全分离的执行环境上。</p>\n<h4 id=\"3、显式绑定\"><a href=\"#3、显式绑定\" class=\"headerlink\" title=\"3、显式绑定\"></a>3、显式绑定</h4><p>若要强制的调用不属于对象内部的方法，将this绑定到对象上面可以使用<code>call()</code>和<code>apply()</code>方法，这两个方法都可以实现改变this指向，它们接受的第一个参数都是要绑定this的对象。区别在于：<code>call()</code>从第二个参数开始接受传递给方法的参数，可以有多个，而<code>apply()</code>最多接受两个参数，第二个参数为一个数组，用来给方法传参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.call( obj ) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>函数foo中的this被强制的绑定到了obj这个对象上。</p>\n<p>还可以使用<code>bind()</code>方法创建一个新的函数，<code>bind()</code>方法中指定一个参数作为this上下文。</p>\n<h4 id=\"4、new绑定\"><a href=\"#4、new绑定\" class=\"headerlink\" title=\"4、new绑定\"></a>4、new绑定</h4><p>最后一种绑定规则，如果在一个函数前面带上new来调用，那么将会创建一个新对象，同时函数中的this会绑定到这个新对象上。在 JavaScript 中，把这些使用new操作符时被调用的函数称为构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>) <span class=\"comment\">// foo &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如此，foo中的this就被绑定到了bar上。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>介绍了各种this绑定规则，那么当不同的调用规则混合使用时，我们就需要判断优先级，而new绑定高于显式绑定高于隐式绑定高于默认绑定。</p>\n<p>因此我们可以得出以下的判断方法：</p>\n<blockquote>\n<p>1、由 new 调用？绑定到新创建的对象。<br>2、由 call 或者 apply（或者 bind）调用？绑定到指定的对象。<br>3、由上下文对象调用？绑定到那个上下文对象。<br>4、默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</p>\n</blockquote>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>不同于前面介绍的四种绑定规则，箭头函数内部的this是词法作用域，由上下文确定，因此箭头函数中的this指向的是定义时的this，而不是执行时的this，并且箭头函数的绑定无法修改。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// this指向obj</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 1而不是2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this指向window</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2而不是1</span></span><br></pre></td></tr></table></figure>\n<p>上述两段代码都是使用了箭头函数，可为什么结果不尽相同？</p>\n<p>要记住，箭头函数中的this是根据定义时的上下文决定的，第一段代码中setTimeout中的箭头函数定义在foo中，而foo的上一级是obj，所以this指向obj。而第二段代码的箭头函数是定义在obj中，obj的上一级是全局，因此this指向全局。</p>\n<hr>\n<p>到此我们就已经介绍了this的全部绑定情况，虽然例子举得简单，但是明确了判断规则后，相信你再不会被小小的this难住。</p>\n<p><em>&#42;本文根据<strong>《你不知道的JavaScript（上）》</strong>第二部分第二章整理总结</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"消除错误认知\"><a href=\"#消除错误认知\" class=\"headerlink\" title=\"消除错误认知\"></a>消除错误认知</h3><p>首先，我们必须要消除的两个关于this的误解：</p>\n<blockquote>\n<ul>\n<li>指向函数自身</li>\n<li>指向函数作用域</li>\n</ul>\n</blockquote>\n<p>需要牢记的是，this在任何情况下都不指向函数的词法作用域，<code>this的绑定取决于函数的调用方式</code>。</p>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>既然明确了this的绑定和调用方式有关，我们就可以根据不同的情况来判断指向结果，我们可以认为这是一组绑定规则。</p>\n<h4 id=\"1、默认绑定\"><a href=\"#1、默认绑定\" class=\"headerlink\" title=\"1、默认绑定\"></a>1、默认绑定</h4><p>这适用于最最普通的函数调用，没有其余规则掺杂，仅仅针对于独立函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//window</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>可以看到，此时函数foo中的this指向的是window。这是因为默认绑定规则下，this指向全局。但这只是在非严格模式下，如果是在严格模式下，this会绑定到undefined。</p>\n<h4 id=\"2、隐式绑定\"><a href=\"#2、隐式绑定\" class=\"headerlink\" title=\"2、隐式绑定\"></a>2、隐式绑定</h4><p>当函数的调用位置有上下文对象（也就是通过对象方法调用）时，this指向这个上下文对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>而当出现多级调用时，this绑定的是离它最近的一个上下文对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj1: obj1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj2.obj1.foo() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>注意该规则针对于对象方法调用，像下面这样实际还是默认绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// 1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fn() <span class=\"comment\">// fn没有对象调用，this绑定全局</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo()</span><br></pre></td></tr></table></figure>\n<p>可是这种隐式绑定this会丢失绑定的对象，常见的两种情况是引用赋值和回调函数：</p>\n<p>（1）引用赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo <span class=\"comment\">// 函数别名！</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2</span></span><br><span class=\"line\">bar() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>这里看起来bar()和obj.foo()是一样的，但其实bar引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>\n<p>（2）回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fn 其实引用的是 foo</span></span><br><span class=\"line\">    fn() <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span> <span class=\"comment\">// a 是全局对象的属性</span></span><br><span class=\"line\">doFoo( obj.foo ) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>看到了吧，传入回调函数的方法绑定的this也应用了默认绑定规则，这也解释了为什么<code>setTimeout</code>方法中回调函数的this会指向window，因为其运行在与所在函数完全分离的执行环境上。</p>\n<h4 id=\"3、显式绑定\"><a href=\"#3、显式绑定\" class=\"headerlink\" title=\"3、显式绑定\"></a>3、显式绑定</h4><p>若要强制的调用不属于对象内部的方法，将this绑定到对象上面可以使用<code>call()</code>和<code>apply()</code>方法，这两个方法都可以实现改变this指向，它们接受的第一个参数都是要绑定this的对象。区别在于：<code>call()</code>从第二个参数开始接受传递给方法的参数，可以有多个，而<code>apply()</code>最多接受两个参数，第二个参数为一个数组，用来给方法传参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.call( obj ) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>函数foo中的this被强制的绑定到了obj这个对象上。</p>\n<p>还可以使用<code>bind()</code>方法创建一个新的函数，<code>bind()</code>方法中指定一个参数作为this上下文。</p>\n<h4 id=\"4、new绑定\"><a href=\"#4、new绑定\" class=\"headerlink\" title=\"4、new绑定\"></a>4、new绑定</h4><p>最后一种绑定规则，如果在一个函数前面带上new来调用，那么将会创建一个新对象，同时函数中的this会绑定到这个新对象上。在 JavaScript 中，把这些使用new操作符时被调用的函数称为构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>) <span class=\"comment\">// foo &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如此，foo中的this就被绑定到了bar上。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>介绍了各种this绑定规则，那么当不同的调用规则混合使用时，我们就需要判断优先级，而new绑定高于显式绑定高于隐式绑定高于默认绑定。</p>\n<p>因此我们可以得出以下的判断方法：</p>\n<blockquote>\n<p>1、由 new 调用？绑定到新创建的对象。<br>2、由 call 或者 apply（或者 bind）调用？绑定到指定的对象。<br>3、由上下文对象调用？绑定到那个上下文对象。<br>4、默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</p>\n</blockquote>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>不同于前面介绍的四种绑定规则，箭头函数内部的this是词法作用域，由上下文确定，因此箭头函数中的this指向的是定义时的this，而不是执行时的this，并且箭头函数的绑定无法修改。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// this指向obj</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 1而不是2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this指向window</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2而不是1</span></span><br></pre></td></tr></table></figure>\n<p>上述两段代码都是使用了箭头函数，可为什么结果不尽相同？</p>\n<p>要记住，箭头函数中的this是根据定义时的上下文决定的，第一段代码中setTimeout中的箭头函数定义在foo中，而foo的上一级是obj，所以this指向obj。而第二段代码的箭头函数是定义在obj中，obj的上一级是全局，因此this指向全局。</p>\n<hr>\n<p>到此我们就已经介绍了this的全部绑定情况，虽然例子举得简单，但是明确了判断规则后，相信你再不会被小小的this难住。</p>\n<p><em>&#42;本文根据<strong>《你不知道的JavaScript（上）》</strong>第二部分第二章整理总结</em></p>\n"},{"title":"达拉斯弧线","subtitle":"MFFL--MAVS FAN FOR LIFE","date":"2018-10-06T10:44:08.000Z","urlname":"MFFL","cover":"https://s1.ax1x.com/2018/10/15/iaMBvV.jpg","_content":"\n当得知小牛队将参加2018年的NBA中国赛时，我立马发消息给张楚，约定开票时一定要相互提醒。当你喜欢的球星无比低调而所在的球队又不那么热门时，你才会明白这样面对面接触的机会是多么难得，毕竟德克·诺维茨基上次来到中国还是08年北京奥运会，而那早已是10年前的事情了。这个2米13的史上最伟大的大个子投手整个职业生涯都沉浸在自己的篮球事业中，不接代言，不会满世界飞来飞去参加各种商业活动，所以这一次的官方中国赛几乎是所有中国小牛球迷、德克球迷在家门口看到他的唯一机会，尤其是在他刚刚度过40岁生日，下个赛季很有可能是他的最后一年的时候。\n\n我是从初中才开始关注篮球的，05年看的第一场NBA比赛就是小牛队，央视的解说一整场都在说诺维茨基如何如何，虽然我那时根本没能把名字和人对上号，但诺维茨基这个名字已经深深的印在了我的脑海里。第一年比赛关注的不多，就连总决赛2-0领先热火被翻盘痛失总冠军也是后知后觉，但当06~07赛季小牛队势不可挡的以67胜15负的成绩一举拿下联盟第一和队史最佳战绩时，我的心已经和德克和他带领的小牛队紧紧地关联在了一起。然而收官前几战时任主帅小将军约翰逊保守雪藏主力的做法也为后面被黑八埋下了伏笔，输给勇士队更是放他们挤掉黄金双枪带领的掘金获得了季后赛的最后一个席位。可勇士主教练老尼尔森太了解小牛队了，金州匪帮凶猛的进攻、主将的低迷、德克被限制住，小牛根本找不到予以回击的办法，杰克逊的三分、戴维斯的扣篮、埃利斯的突破无情地撕扯着小牛的防线。当第六场的终场哨声响起，甲骨文球场上空洒满丝带，勇士球员肆意地拥抱庆祝时，我第一次体会到心碎的感觉。常规赛第一的战绩，那么无敌的小牛队居然就这么倒在了第一轮，而赢得了联盟当年认可的德克也只能在首轮之后的发布会上领取自己的常规赛MVP奖杯，尴尬的让人心疼。\n\n黑八之后，管理层将先发控卫哈里斯交易到篮网换来基德，彼时的基德已经34岁了，虽然组织更加稳健，但哈里斯年轻有速度，刚刚被球队培养起来，这笔交易说实在的并不觉得赚。开赛之后，哈里斯完全释放自己，数据暴涨，带领球队连连胜利，篮网主场球迷更是举起牌子上书：感谢库班。那个时候看的真是很气，觉得库班这个交易不应该进行，这么好的球员就给别人了。小牛这边也确实没有因为引入了基德就有所突破，后面三年接连输给黄蜂掘金马刺，球队最多进入第二轮，西部半决赛对掘金德克更是受到场外女友诈骗案的影响无心恋战。\n\n那几年身为小牛球迷真的很煎熬，球队虽然年年进入季后赛但都难有作为，突破首轮几近成为奢望，德克软蛋的称号似乎也难以摆脱，媒体也惯性的看衰小牛，国内体坛周报的各种专栏分析都是阴阳怪气的嘲讽，没有人把小牛当成一支真正的强队。三年之中，主教练变成了卡莱尔，球员也几经变更，但无论怎样，心中的支持从来都不会改变，因为我们相信总有一天达拉斯人会重回往日的辉煌。\n\n直到10~11赛季小牛队通过上赛季的几笔交易和休赛期的运作囤积了足够的阵容深度，卡隆巴特勒、马里昂、泰森钱德勒的到来让小牛球迷又看到了争冠的希望，特别是钱德勒更是被称作是夺冠的最后一块拼图，媒体甚至有小牛的替补可以赢过森林狼队首发的说法。虽然赛季初首发小前锋卡隆巴特勒因伤赛季报销折损了一定的战力，德克缺阵的几场败仗也一度让人对球队的实力打上了问号，但随后球队重整旗鼓后不仅数次打出10+的连胜并且当赛季终结了黄蜂、马刺和热火的10+连胜，成为连胜终结者，后半段认领了被裁掉的佩贾和布鲁尔也进一步巩固了球队阵容，那段时间作为牛蜜真的可以很骄傲的跟同学谈论小牛的战绩。常规赛结束小牛胜场数并列两连冠的湖人以西部第三的位置首轮对上开拓者，虽然成绩处于上半区，但是由于此前连续几年早早出局让各路专家都认定开拓者将赢下这轮系列赛，其实对于我们来讲早就习惯了各路专家的看衰，毕竟这种论调见得太多了。开打后小牛轻松地连赢两场，系列赛似乎没有悬念，开拓者回到主场拿下了第三战。系列赛继续进行，第四场小牛一度领先18分，但是提早松懈的毛病再一次发生，末节罗伊带领开拓者完成了大逆转将总比分扳成2-2。难道我们又要倒在首轮？难道历史将再一次重复？我不愿相信，但也着实有些慌。球队也同样承受着被翻盘的压力和媒体的口诛笔伐，凝重的气氛笼罩着全队，倘若下一场再输那么局势将会完全逆转。好在48小时后，我们看到了小牛不容有失的、坚定的态度，一球一球的稳扎稳打拿下比赛，第六场也没有给开拓者机会，4-2拿下首轮。\n\n第二轮等待着小牛队的是两连冠势要夺取三连冠的湖人，内外线均衡的湖人队外有科比费舍尔内线有三塔加索尔、拜纳姆、奥多姆。豪华的内线配置放眼全联盟也难有敌手，然而我们的三高诺维茨基、钱德勒和海伍德却好似专门为了针对湖人。话虽这么说，对上这样的冠军球队，小牛有多大的几率获胜连我们自己也没有把握，专家甚至认为湖人将不失一场地轻松晋级下一轮。第一场湖人也确实拿出了冠军的实力，科比频频得分，比分一直压着小牛，也就是从这一场开始小牛展现了他们不服输不轻言放弃的韧性，直到终场前一分多钟的时间湖人队还领先着比分，可接下来的几个回合小牛抓住了湖人的几个失误一举将比分反超，出人意料的拿下了第一场比赛。乘胜追击的小牛又在湖人主场拿下了第二场，这个时候人们终于意识到湖人危险了，但仍然嘴硬湖人会获得最终的胜利。被逼入绝境的湖人来到我们的主场决心摆脱颓势夺回主场优势，开场之后强悍的进攻、凶猛的防守、甚至是拜纳姆抢断德克快攻扣篮似乎让他们找回了一丝冠军的感觉，仿佛又燃起了生的希望。可站在他们对面的是基德、马里昂、特里、钱德勒、诺维茨基啊，这群老头等了太多年了，如果错过今年谁还知道他们还有没有机会染指总冠军，为了冠军，把投失的球投进去，该拿的篮板收下来，一个回合一个回合打，逼迫对方失误，在美航中心山呼海啸的助威声中，小牛逆转取得3-0的领先。我们做到了！面对质疑、面对落后的局面，我们咬着牙坚持了下来，没有球队可以0-3落后翻盘，两冠的湖人也不行，接下来我们要做的就是：SWEEP LA！\n\n第四场发生了什么我想我会永远铭记吧，当特里一记又一记的三分射入篮筐中，做出经典的喷气机动作从科比身边飞过，当巴里亚的突破逼得拜纳姆恼羞成怒将其肘翻在地，湖人队已经溃不成军。全场比赛投进20记三分，特里和佩贾三分球合计16投15中，狂胜36分，粉碎了湖人的王朝梦，我们以所有人都想不到的方式横扫卫冕冠军挺进西决。整个系列赛，诺维茨基打爆了加索尔，一个又一个无解的投篮打失了加索尔的信心，德克的状态已然进入最佳，还有人可以防得住他吗？这个问题只能留给下一个对手了。\n\n西决的对手是积攒了大量天赋的青年军雷霆队，经过了上一轮无与伦比的表现，雷霆队知道他们面临的最大的麻烦就是如何防守德克。布鲁克斯教练轮番使用伊巴卡科里森塞弗洛沙等各个位置的球员尝试防守德克，坚决不给他直接投篮的机会即便赔上犯规，结果就是德克只用了15次出手命中12个，罚球24罚24中打破记录，全场砍下48分带走比赛。赛后各路媒体纷纷送上对德克的各种赞誉，张卫平指导也在解说时不停地重复送德克上罚球线就等于送分，可以说那场比赛德克真的打服了很多路人球迷。可能够进入西决雷霆必定也没那么好欺负，年轻有天赋的雷霆三少也给小牛制造了不少麻烦，5场系列赛小牛有两场一度落后十几分，但达拉斯的老将们屡屡展现出了他们对比赛把控能力以及不抛弃不放弃的决心。第四场最后时刻基德晃飞维斯特布鲁克斯命中三分将分差抹平进入加时拿下比赛就是整轮系列赛的一个缩影，小牛用经验和沉稳击败了这支稍显稚嫩的青年军时隔5年再一次进入总决赛。德克在这一轮继续教伊巴卡做人，背身单打，后转身溜底线扣篮，正面封到眼睛上的投篮，万花筒般的进攻方式人挡杀人，佛挡杀佛，场均轰下32分。\n\n连续将湖人、雷霆斩落马下并没有让人们相信小牛可以有机会在总决赛上笑到最后，因为即将和他们碰面的是东海岸刚刚组建了三巨头的迈阿密热火。5年前正是这支球队击碎了小牛的冠军梦，正如特里说的不管当年那些人还在不在，始终是这支球队拿走了我们的冠军，这一次我们要把它夺回来。一路走来，每一轮系列赛小牛都是被专家预测会出局的球队，我们一次次的用结果狠狠地打了他们的脸，可是“**史上最无悬念总决赛**”、“**热火最多5场内赢得总冠军**”这样的标题还是登上了各大报刊杂志。作为班里唯一的小牛球迷在听到同学一场未打时就宣布热火会是总冠军的言论也只能默默在心里说：那咱们走着瞧。\n\n11年，我上高二，周末之外获取比赛结果的方式就是通过带手机的同学。第一场小牛丝毫招架不住热火的进攻，双方实力确实存在一定的差距，客场输球多少也在意料之中，但雪上加霜的是这场比赛德克撕裂了他的手指肌肉，作为球队的当家球星，这个伤病影响太大了。第一场已经输了，如果德克的投篮受到影响，那后面的比赛真的就毫无胜算了。所以当我从同学那里获知第二场德克绝杀了热火时，我真的既激动又有点不敢相信，中午赶紧回到家里看体坛快讯，想知道这到底是个什么样的绝杀。过程我们都知道了，德克先是在钱德勒纹丝不动的掩护下命中三分反超比分，热火的查尔莫斯随后三分扳平，最后一攻德克过掉波什左手上篮打进，韦德压哨骑马射箭不中，诺维茨基准绝杀！！！而在此之前小牛一度落后15分，场边詹姆斯和韦德已经提前为这场比赛开始庆祝，可比赛最终结果是我们赢了，毫无疑问这是一场足以载入史册的经典翻盘战役，这颗绝杀球也成为了诺维茨基生涯最高光的时刻。带着1-1的总比分回到主场，第三战我们仍然有机会赢得比赛，但是波什底角的致命投篮以及德克最后的绝杀不中还是让热火重新夺回了主场优势。1-2落后，央视的解说反复强调总决赛7场4胜制以来从来没有球队在1-2落后的情况下逆转，可我想这算是什么魔咒啊，比赛还有四场只落后一场，湖人半决赛被我们打成3-0都有人觉得还能翻盘，到这就要输了，还不是因为我们是小牛，都觉得我们是软柿子，我们偏偏要证明给他们看，什么定律魔咒最后都是给人打破的。\n\n第四战卡莱尔在阵容上做出调整，巴里亚被提上首发，他灵活而又有节奏的突破搅得热火禁区翻江倒海，这一改变最终让小牛连下三局一举夺得总冠军。第四场德克带着流感封盖波什的扣篮、第五场特里迎着詹姆斯命中超远压哨三分锁定胜局、第六场德克提前走出球员通道······一幕幕场景在脑海里旋转慢放，5年之后，我们终于拿到了早就应该属于我们的冠军奖杯，**We are the Champions** 。摘掉了软蛋的帽子，诺维茨基一冠封神，季后赛无解的表现赢得了所有人的尊重，也顺理成章的捧起FMVP奖杯。\n\n那个夏天是所有达拉斯球迷的蜜月期，那个夏天也是上天给一直留守达拉斯的德克最好的奖励，一次次的失败没有让我们失去对这支球队的热爱，也没有让德克选择转投他门，冠军对于这座城市实至名归。\n\n我们希望保持这套阵容赢得更多的冠军，但库班似乎和我们的想法不一样，他希望球队可以在夏天吸引大牌自由球星如霍华德、德隆加盟所以不愿和合同到期的老将续约，于是拳王远走纽约，巴里亚去了森林狼，卡隆巴特勒去了快船，佩贾退役，夺冠阵容瞬间解散，休赛期没有大牌球星加盟更是让小牛迅速退出争冠行列。揭幕战惨败热火，季后赛首轮被雷霆横扫，从世界上最好的篮球队到被横扫的卫冕冠军仅仅过了一年。\n\n12、13年前后，印象中是在新浪的文字直播间里随手和两个牛蜜留了联系方式，没想到其中一个我们竟一直保持联络到现在，就是开头提到的张楚。开始的时候我们只是聊比赛，预测每场比赛谁会赢，分析季后赛局势，幻想如何补强阵容，渐渐熟悉之后，话题也就不局限篮球了，没事就闲聊两句。大学的那段时光，我们经常约好晚上上线打一会NBA online，毫无疑问地，我们都是使用小牛队。14年我去广州旅游，而张楚刚好在那里工作，两个人隔着网络聊了那么久总算是有个机会可以真正的见个面，我当时穿了一件小牛的T恤，我们一块去了中山大学打野球，看完小蛮腰还错过了地铁，最后狼狈地样子真的是难忘。三年中我们只见过那一面，直到去年我结婚的时候给他发了张请柬，没想到他毫不犹豫地就答应了我会来，为此还特地跟老板请了几天假，心里特别感激。回想起来，两个相隔那么遥远，生活上完全没有交集的人因为一支球队一个球星就在现实生活里结成了深厚的友谊，这种感觉挺不可思议的。\n\n那几年小牛年年计划钓大鱼，却年年执行B计划，小修小补，球队又陷入了虽为季后赛常客却早早出局的轮回，甚至13年由于德克因伤缺席了大量比赛球队21世纪首次没能进入季后赛。德克一再为了球队建设而降薪，但球队整体实力却鲜有提升。14~15赛季，小牛换回了当年的冠军中锋钱德勒，搭配上蒙塔埃利斯、帕森斯、赖特、阿米奴、理查德杰弗森、费尔顿、哈里斯等一众各具特色的球员小牛一度打出了联盟最高的进攻效率，流畅的进攻加上足够的板凳深度让我觉得我们又一次拥有了冲击冠军的实力。可赛季中的一笔交易却打破了这个体系，小牛送出了队内进攻效率最高的替补赖特、3D克劳德和尼尔森换来了东部全明星控卫隆多，交易过后阵容的磨合加上隆多和卡莱尔的沟通问题，小牛再也打不出原有天花乱坠的进攻，赛季结束后球队便和隆多分道扬镳。也许在当时那真是一个不容错过的交易机会，但我还是惋惜如果没有这笔交易凭借那年水银泻地般的进攻小牛究竟可以走到什么地步。\n\n几年的光阴消耗过去，诺维茨基的年龄已经不能允许球队继续围绕他来打造争冠阵容了，我也明白球队确实很难迅速崛起，看球的心态也就更加放松，只想好好享受德克打球的日子，看看老大爷在场上多进几个球，总得分榜上努力多超几个，保持健康多打几年就好。很难说清楚自己为什么会坚持追随这样一支起起伏伏的球队十几年，就像德克能在商业化的联盟中效力同一支球队20个赛季之久一样令人称奇，人们都喜欢赢球，都喜欢实力强的球队，球员可以得到更高的关注和利益，球迷可以长久的享受赢球的快感，但或许就是因为我们加入时的初心吧，蓝色的血液一经融入便再也无法分离，生也好，死也好，永远便是达拉斯人了。\n\n看着德克在生涯的暮年仍然可以用自己的经验不停取分甚至在某些夜晚扛起球队的进攻，看着他背身晃过科比低手上篮，看着他连续晃飞格林稳稳命中中投，看着他用滚烫的手感将自己带进三万分俱乐部，看着他一点一点地爬到历史总得分榜第六位，我忽然有些害怕德克就这样投着投着突然有一天不在球场上了而我还没有看过他。我想计划去达拉斯，想亲眼看一看德克，趁着他还没退役。\n\n![tickets](https://s1.ax1x.com/2018/10/15/iaQKZF.jpg)\n\n可能是上天抬爱我们这个稀缺的群体吧，居然给了我们一个可以不用跨越大洋不用办理各种签证在家门口就能看到那支追随了十几年的球队的机会，这是多么幸福的事啊。毫不犹豫的买票、订酒店、买纪念品，只等他们的到来，只为可以近距离的看一眼德克。\n\n两个月的日夜期盼终于等到了他们启程飞往中国，连续几天看到各个球迷群里提前蹲守在机场酒店的牛蜜分享德克的亲笔签名和合照心里别提有多羡慕多难受了，恨不得自己也马上飞过去要一张签名，特别是在得知德克因伤无法上场时，酒店蹲守可能是和他最好的接触机会了。可家里女儿还小，老婆自己带孩子每天辛苦的很，我没有办法把他们放在家里自己早早的跑去上海，就只能在家里不停的刷手机看牛蜜们捕捉球队和德克的现场实况，同时祈祷自己赛前赶得上酒店的最后一次蹲守机会。\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaM259.jpg)\n\n赛前当所有球员都已经登上大巴车好一会儿之后，德克才终于踱着步子出现在门口，跟前几天一样耐心地一个一个给球迷签球衣，可隔着五六排距离的我实在没有办法把球衣递上去，只能尽量踮起脚看一看。\n\n虽然已经知道德克无法上场，但我还是期盼看到他在赛前热身的时候投投篮，比起没有签到球衣，看不到德克在场上会更让我觉得遗憾。可老大爷不仅最晚进入球场，甚至连球都没摸一下。即使没有办法在场上帮助球队，德克也永远是这支球队的魂，比赛开始之后的每一个暂停德克都是第一个站起来和队友击掌并不时和他们进行交流，而坐在他背后的我也只有趁这时候才可以从正面好好的看一看他，从前只能从电视转播和视频中看到的人，此时终于可以真真切切的被我凝视，我第一次希望比赛的暂停时间可以再长一些。球场上，代表球队未来的DSJ和东契奇尽情的展现着他们的运动天赋和大局观，可我的目光仍然没办法完全聚焦在他们身上，毕竟让我选择来到这个场馆的是那个坐在场下的男人。看着他在场边悄悄的拿起一片口香糖塞进嘴里，看着他暂停时来回踱步，看着他接过大郅赠送的吉他开心的拨弄，就在这些碎片化的间隙中，蜂鸣声响起，目送德克缓步走出球员通道，属于我的朝圣之旅也结束了。\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMybF.jpg)\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMsDU.jpg)\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMgUJ.jpg)\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMf81.jpg)\n\n不知不觉这辆德国战车已经开了20年了，载着我们的青春与无数的回忆，下个赛季无论你是司机还是坐在副驾驶，我只希望能多看你投出几道最美弧线。谢谢你，德克，谢谢你这么久了依然站在球场上，谢谢你带给我们的感动，谢谢你让我相信忠诚，谢谢你给达拉斯这座城市的荣耀。这还远不是终点，属于你和达拉斯的故事将永远继续下去!\n\n**Let's go Mavs!**\n\n![MFFL](https://s1.ax1x.com/2018/10/15/iaMq5d.jpg)","source":"_posts/达拉斯弧线.md","raw":"---\ntitle: 达拉斯弧线\nsubtitle: MFFL--MAVS FAN FOR LIFE\ndate: 2018-10-06 18:44:08\nurlname: MFFL\ncover: \"https://s1.ax1x.com/2018/10/15/iaMBvV.jpg\"\ncategories: [\"生活\"]\ntags: [\"生活\"]\n---\n\n当得知小牛队将参加2018年的NBA中国赛时，我立马发消息给张楚，约定开票时一定要相互提醒。当你喜欢的球星无比低调而所在的球队又不那么热门时，你才会明白这样面对面接触的机会是多么难得，毕竟德克·诺维茨基上次来到中国还是08年北京奥运会，而那早已是10年前的事情了。这个2米13的史上最伟大的大个子投手整个职业生涯都沉浸在自己的篮球事业中，不接代言，不会满世界飞来飞去参加各种商业活动，所以这一次的官方中国赛几乎是所有中国小牛球迷、德克球迷在家门口看到他的唯一机会，尤其是在他刚刚度过40岁生日，下个赛季很有可能是他的最后一年的时候。\n\n我是从初中才开始关注篮球的，05年看的第一场NBA比赛就是小牛队，央视的解说一整场都在说诺维茨基如何如何，虽然我那时根本没能把名字和人对上号，但诺维茨基这个名字已经深深的印在了我的脑海里。第一年比赛关注的不多，就连总决赛2-0领先热火被翻盘痛失总冠军也是后知后觉，但当06~07赛季小牛队势不可挡的以67胜15负的成绩一举拿下联盟第一和队史最佳战绩时，我的心已经和德克和他带领的小牛队紧紧地关联在了一起。然而收官前几战时任主帅小将军约翰逊保守雪藏主力的做法也为后面被黑八埋下了伏笔，输给勇士队更是放他们挤掉黄金双枪带领的掘金获得了季后赛的最后一个席位。可勇士主教练老尼尔森太了解小牛队了，金州匪帮凶猛的进攻、主将的低迷、德克被限制住，小牛根本找不到予以回击的办法，杰克逊的三分、戴维斯的扣篮、埃利斯的突破无情地撕扯着小牛的防线。当第六场的终场哨声响起，甲骨文球场上空洒满丝带，勇士球员肆意地拥抱庆祝时，我第一次体会到心碎的感觉。常规赛第一的战绩，那么无敌的小牛队居然就这么倒在了第一轮，而赢得了联盟当年认可的德克也只能在首轮之后的发布会上领取自己的常规赛MVP奖杯，尴尬的让人心疼。\n\n黑八之后，管理层将先发控卫哈里斯交易到篮网换来基德，彼时的基德已经34岁了，虽然组织更加稳健，但哈里斯年轻有速度，刚刚被球队培养起来，这笔交易说实在的并不觉得赚。开赛之后，哈里斯完全释放自己，数据暴涨，带领球队连连胜利，篮网主场球迷更是举起牌子上书：感谢库班。那个时候看的真是很气，觉得库班这个交易不应该进行，这么好的球员就给别人了。小牛这边也确实没有因为引入了基德就有所突破，后面三年接连输给黄蜂掘金马刺，球队最多进入第二轮，西部半决赛对掘金德克更是受到场外女友诈骗案的影响无心恋战。\n\n那几年身为小牛球迷真的很煎熬，球队虽然年年进入季后赛但都难有作为，突破首轮几近成为奢望，德克软蛋的称号似乎也难以摆脱，媒体也惯性的看衰小牛，国内体坛周报的各种专栏分析都是阴阳怪气的嘲讽，没有人把小牛当成一支真正的强队。三年之中，主教练变成了卡莱尔，球员也几经变更，但无论怎样，心中的支持从来都不会改变，因为我们相信总有一天达拉斯人会重回往日的辉煌。\n\n直到10~11赛季小牛队通过上赛季的几笔交易和休赛期的运作囤积了足够的阵容深度，卡隆巴特勒、马里昂、泰森钱德勒的到来让小牛球迷又看到了争冠的希望，特别是钱德勒更是被称作是夺冠的最后一块拼图，媒体甚至有小牛的替补可以赢过森林狼队首发的说法。虽然赛季初首发小前锋卡隆巴特勒因伤赛季报销折损了一定的战力，德克缺阵的几场败仗也一度让人对球队的实力打上了问号，但随后球队重整旗鼓后不仅数次打出10+的连胜并且当赛季终结了黄蜂、马刺和热火的10+连胜，成为连胜终结者，后半段认领了被裁掉的佩贾和布鲁尔也进一步巩固了球队阵容，那段时间作为牛蜜真的可以很骄傲的跟同学谈论小牛的战绩。常规赛结束小牛胜场数并列两连冠的湖人以西部第三的位置首轮对上开拓者，虽然成绩处于上半区，但是由于此前连续几年早早出局让各路专家都认定开拓者将赢下这轮系列赛，其实对于我们来讲早就习惯了各路专家的看衰，毕竟这种论调见得太多了。开打后小牛轻松地连赢两场，系列赛似乎没有悬念，开拓者回到主场拿下了第三战。系列赛继续进行，第四场小牛一度领先18分，但是提早松懈的毛病再一次发生，末节罗伊带领开拓者完成了大逆转将总比分扳成2-2。难道我们又要倒在首轮？难道历史将再一次重复？我不愿相信，但也着实有些慌。球队也同样承受着被翻盘的压力和媒体的口诛笔伐，凝重的气氛笼罩着全队，倘若下一场再输那么局势将会完全逆转。好在48小时后，我们看到了小牛不容有失的、坚定的态度，一球一球的稳扎稳打拿下比赛，第六场也没有给开拓者机会，4-2拿下首轮。\n\n第二轮等待着小牛队的是两连冠势要夺取三连冠的湖人，内外线均衡的湖人队外有科比费舍尔内线有三塔加索尔、拜纳姆、奥多姆。豪华的内线配置放眼全联盟也难有敌手，然而我们的三高诺维茨基、钱德勒和海伍德却好似专门为了针对湖人。话虽这么说，对上这样的冠军球队，小牛有多大的几率获胜连我们自己也没有把握，专家甚至认为湖人将不失一场地轻松晋级下一轮。第一场湖人也确实拿出了冠军的实力，科比频频得分，比分一直压着小牛，也就是从这一场开始小牛展现了他们不服输不轻言放弃的韧性，直到终场前一分多钟的时间湖人队还领先着比分，可接下来的几个回合小牛抓住了湖人的几个失误一举将比分反超，出人意料的拿下了第一场比赛。乘胜追击的小牛又在湖人主场拿下了第二场，这个时候人们终于意识到湖人危险了，但仍然嘴硬湖人会获得最终的胜利。被逼入绝境的湖人来到我们的主场决心摆脱颓势夺回主场优势，开场之后强悍的进攻、凶猛的防守、甚至是拜纳姆抢断德克快攻扣篮似乎让他们找回了一丝冠军的感觉，仿佛又燃起了生的希望。可站在他们对面的是基德、马里昂、特里、钱德勒、诺维茨基啊，这群老头等了太多年了，如果错过今年谁还知道他们还有没有机会染指总冠军，为了冠军，把投失的球投进去，该拿的篮板收下来，一个回合一个回合打，逼迫对方失误，在美航中心山呼海啸的助威声中，小牛逆转取得3-0的领先。我们做到了！面对质疑、面对落后的局面，我们咬着牙坚持了下来，没有球队可以0-3落后翻盘，两冠的湖人也不行，接下来我们要做的就是：SWEEP LA！\n\n第四场发生了什么我想我会永远铭记吧，当特里一记又一记的三分射入篮筐中，做出经典的喷气机动作从科比身边飞过，当巴里亚的突破逼得拜纳姆恼羞成怒将其肘翻在地，湖人队已经溃不成军。全场比赛投进20记三分，特里和佩贾三分球合计16投15中，狂胜36分，粉碎了湖人的王朝梦，我们以所有人都想不到的方式横扫卫冕冠军挺进西决。整个系列赛，诺维茨基打爆了加索尔，一个又一个无解的投篮打失了加索尔的信心，德克的状态已然进入最佳，还有人可以防得住他吗？这个问题只能留给下一个对手了。\n\n西决的对手是积攒了大量天赋的青年军雷霆队，经过了上一轮无与伦比的表现，雷霆队知道他们面临的最大的麻烦就是如何防守德克。布鲁克斯教练轮番使用伊巴卡科里森塞弗洛沙等各个位置的球员尝试防守德克，坚决不给他直接投篮的机会即便赔上犯规，结果就是德克只用了15次出手命中12个，罚球24罚24中打破记录，全场砍下48分带走比赛。赛后各路媒体纷纷送上对德克的各种赞誉，张卫平指导也在解说时不停地重复送德克上罚球线就等于送分，可以说那场比赛德克真的打服了很多路人球迷。可能够进入西决雷霆必定也没那么好欺负，年轻有天赋的雷霆三少也给小牛制造了不少麻烦，5场系列赛小牛有两场一度落后十几分，但达拉斯的老将们屡屡展现出了他们对比赛把控能力以及不抛弃不放弃的决心。第四场最后时刻基德晃飞维斯特布鲁克斯命中三分将分差抹平进入加时拿下比赛就是整轮系列赛的一个缩影，小牛用经验和沉稳击败了这支稍显稚嫩的青年军时隔5年再一次进入总决赛。德克在这一轮继续教伊巴卡做人，背身单打，后转身溜底线扣篮，正面封到眼睛上的投篮，万花筒般的进攻方式人挡杀人，佛挡杀佛，场均轰下32分。\n\n连续将湖人、雷霆斩落马下并没有让人们相信小牛可以有机会在总决赛上笑到最后，因为即将和他们碰面的是东海岸刚刚组建了三巨头的迈阿密热火。5年前正是这支球队击碎了小牛的冠军梦，正如特里说的不管当年那些人还在不在，始终是这支球队拿走了我们的冠军，这一次我们要把它夺回来。一路走来，每一轮系列赛小牛都是被专家预测会出局的球队，我们一次次的用结果狠狠地打了他们的脸，可是“**史上最无悬念总决赛**”、“**热火最多5场内赢得总冠军**”这样的标题还是登上了各大报刊杂志。作为班里唯一的小牛球迷在听到同学一场未打时就宣布热火会是总冠军的言论也只能默默在心里说：那咱们走着瞧。\n\n11年，我上高二，周末之外获取比赛结果的方式就是通过带手机的同学。第一场小牛丝毫招架不住热火的进攻，双方实力确实存在一定的差距，客场输球多少也在意料之中，但雪上加霜的是这场比赛德克撕裂了他的手指肌肉，作为球队的当家球星，这个伤病影响太大了。第一场已经输了，如果德克的投篮受到影响，那后面的比赛真的就毫无胜算了。所以当我从同学那里获知第二场德克绝杀了热火时，我真的既激动又有点不敢相信，中午赶紧回到家里看体坛快讯，想知道这到底是个什么样的绝杀。过程我们都知道了，德克先是在钱德勒纹丝不动的掩护下命中三分反超比分，热火的查尔莫斯随后三分扳平，最后一攻德克过掉波什左手上篮打进，韦德压哨骑马射箭不中，诺维茨基准绝杀！！！而在此之前小牛一度落后15分，场边詹姆斯和韦德已经提前为这场比赛开始庆祝，可比赛最终结果是我们赢了，毫无疑问这是一场足以载入史册的经典翻盘战役，这颗绝杀球也成为了诺维茨基生涯最高光的时刻。带着1-1的总比分回到主场，第三战我们仍然有机会赢得比赛，但是波什底角的致命投篮以及德克最后的绝杀不中还是让热火重新夺回了主场优势。1-2落后，央视的解说反复强调总决赛7场4胜制以来从来没有球队在1-2落后的情况下逆转，可我想这算是什么魔咒啊，比赛还有四场只落后一场，湖人半决赛被我们打成3-0都有人觉得还能翻盘，到这就要输了，还不是因为我们是小牛，都觉得我们是软柿子，我们偏偏要证明给他们看，什么定律魔咒最后都是给人打破的。\n\n第四战卡莱尔在阵容上做出调整，巴里亚被提上首发，他灵活而又有节奏的突破搅得热火禁区翻江倒海，这一改变最终让小牛连下三局一举夺得总冠军。第四场德克带着流感封盖波什的扣篮、第五场特里迎着詹姆斯命中超远压哨三分锁定胜局、第六场德克提前走出球员通道······一幕幕场景在脑海里旋转慢放，5年之后，我们终于拿到了早就应该属于我们的冠军奖杯，**We are the Champions** 。摘掉了软蛋的帽子，诺维茨基一冠封神，季后赛无解的表现赢得了所有人的尊重，也顺理成章的捧起FMVP奖杯。\n\n那个夏天是所有达拉斯球迷的蜜月期，那个夏天也是上天给一直留守达拉斯的德克最好的奖励，一次次的失败没有让我们失去对这支球队的热爱，也没有让德克选择转投他门，冠军对于这座城市实至名归。\n\n我们希望保持这套阵容赢得更多的冠军，但库班似乎和我们的想法不一样，他希望球队可以在夏天吸引大牌自由球星如霍华德、德隆加盟所以不愿和合同到期的老将续约，于是拳王远走纽约，巴里亚去了森林狼，卡隆巴特勒去了快船，佩贾退役，夺冠阵容瞬间解散，休赛期没有大牌球星加盟更是让小牛迅速退出争冠行列。揭幕战惨败热火，季后赛首轮被雷霆横扫，从世界上最好的篮球队到被横扫的卫冕冠军仅仅过了一年。\n\n12、13年前后，印象中是在新浪的文字直播间里随手和两个牛蜜留了联系方式，没想到其中一个我们竟一直保持联络到现在，就是开头提到的张楚。开始的时候我们只是聊比赛，预测每场比赛谁会赢，分析季后赛局势，幻想如何补强阵容，渐渐熟悉之后，话题也就不局限篮球了，没事就闲聊两句。大学的那段时光，我们经常约好晚上上线打一会NBA online，毫无疑问地，我们都是使用小牛队。14年我去广州旅游，而张楚刚好在那里工作，两个人隔着网络聊了那么久总算是有个机会可以真正的见个面，我当时穿了一件小牛的T恤，我们一块去了中山大学打野球，看完小蛮腰还错过了地铁，最后狼狈地样子真的是难忘。三年中我们只见过那一面，直到去年我结婚的时候给他发了张请柬，没想到他毫不犹豫地就答应了我会来，为此还特地跟老板请了几天假，心里特别感激。回想起来，两个相隔那么遥远，生活上完全没有交集的人因为一支球队一个球星就在现实生活里结成了深厚的友谊，这种感觉挺不可思议的。\n\n那几年小牛年年计划钓大鱼，却年年执行B计划，小修小补，球队又陷入了虽为季后赛常客却早早出局的轮回，甚至13年由于德克因伤缺席了大量比赛球队21世纪首次没能进入季后赛。德克一再为了球队建设而降薪，但球队整体实力却鲜有提升。14~15赛季，小牛换回了当年的冠军中锋钱德勒，搭配上蒙塔埃利斯、帕森斯、赖特、阿米奴、理查德杰弗森、费尔顿、哈里斯等一众各具特色的球员小牛一度打出了联盟最高的进攻效率，流畅的进攻加上足够的板凳深度让我觉得我们又一次拥有了冲击冠军的实力。可赛季中的一笔交易却打破了这个体系，小牛送出了队内进攻效率最高的替补赖特、3D克劳德和尼尔森换来了东部全明星控卫隆多，交易过后阵容的磨合加上隆多和卡莱尔的沟通问题，小牛再也打不出原有天花乱坠的进攻，赛季结束后球队便和隆多分道扬镳。也许在当时那真是一个不容错过的交易机会，但我还是惋惜如果没有这笔交易凭借那年水银泻地般的进攻小牛究竟可以走到什么地步。\n\n几年的光阴消耗过去，诺维茨基的年龄已经不能允许球队继续围绕他来打造争冠阵容了，我也明白球队确实很难迅速崛起，看球的心态也就更加放松，只想好好享受德克打球的日子，看看老大爷在场上多进几个球，总得分榜上努力多超几个，保持健康多打几年就好。很难说清楚自己为什么会坚持追随这样一支起起伏伏的球队十几年，就像德克能在商业化的联盟中效力同一支球队20个赛季之久一样令人称奇，人们都喜欢赢球，都喜欢实力强的球队，球员可以得到更高的关注和利益，球迷可以长久的享受赢球的快感，但或许就是因为我们加入时的初心吧，蓝色的血液一经融入便再也无法分离，生也好，死也好，永远便是达拉斯人了。\n\n看着德克在生涯的暮年仍然可以用自己的经验不停取分甚至在某些夜晚扛起球队的进攻，看着他背身晃过科比低手上篮，看着他连续晃飞格林稳稳命中中投，看着他用滚烫的手感将自己带进三万分俱乐部，看着他一点一点地爬到历史总得分榜第六位，我忽然有些害怕德克就这样投着投着突然有一天不在球场上了而我还没有看过他。我想计划去达拉斯，想亲眼看一看德克，趁着他还没退役。\n\n![tickets](https://s1.ax1x.com/2018/10/15/iaQKZF.jpg)\n\n可能是上天抬爱我们这个稀缺的群体吧，居然给了我们一个可以不用跨越大洋不用办理各种签证在家门口就能看到那支追随了十几年的球队的机会，这是多么幸福的事啊。毫不犹豫的买票、订酒店、买纪念品，只等他们的到来，只为可以近距离的看一眼德克。\n\n两个月的日夜期盼终于等到了他们启程飞往中国，连续几天看到各个球迷群里提前蹲守在机场酒店的牛蜜分享德克的亲笔签名和合照心里别提有多羡慕多难受了，恨不得自己也马上飞过去要一张签名，特别是在得知德克因伤无法上场时，酒店蹲守可能是和他最好的接触机会了。可家里女儿还小，老婆自己带孩子每天辛苦的很，我没有办法把他们放在家里自己早早的跑去上海，就只能在家里不停的刷手机看牛蜜们捕捉球队和德克的现场实况，同时祈祷自己赛前赶得上酒店的最后一次蹲守机会。\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaM259.jpg)\n\n赛前当所有球员都已经登上大巴车好一会儿之后，德克才终于踱着步子出现在门口，跟前几天一样耐心地一个一个给球迷签球衣，可隔着五六排距离的我实在没有办法把球衣递上去，只能尽量踮起脚看一看。\n\n虽然已经知道德克无法上场，但我还是期盼看到他在赛前热身的时候投投篮，比起没有签到球衣，看不到德克在场上会更让我觉得遗憾。可老大爷不仅最晚进入球场，甚至连球都没摸一下。即使没有办法在场上帮助球队，德克也永远是这支球队的魂，比赛开始之后的每一个暂停德克都是第一个站起来和队友击掌并不时和他们进行交流，而坐在他背后的我也只有趁这时候才可以从正面好好的看一看他，从前只能从电视转播和视频中看到的人，此时终于可以真真切切的被我凝视，我第一次希望比赛的暂停时间可以再长一些。球场上，代表球队未来的DSJ和东契奇尽情的展现着他们的运动天赋和大局观，可我的目光仍然没办法完全聚焦在他们身上，毕竟让我选择来到这个场馆的是那个坐在场下的男人。看着他在场边悄悄的拿起一片口香糖塞进嘴里，看着他暂停时来回踱步，看着他接过大郅赠送的吉他开心的拨弄，就在这些碎片化的间隙中，蜂鸣声响起，目送德克缓步走出球员通道，属于我的朝圣之旅也结束了。\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMybF.jpg)\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMsDU.jpg)\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMgUJ.jpg)\n\n![dirk](https://s1.ax1x.com/2018/10/15/iaMf81.jpg)\n\n不知不觉这辆德国战车已经开了20年了，载着我们的青春与无数的回忆，下个赛季无论你是司机还是坐在副驾驶，我只希望能多看你投出几道最美弧线。谢谢你，德克，谢谢你这么久了依然站在球场上，谢谢你带给我们的感动，谢谢你让我相信忠诚，谢谢你给达拉斯这座城市的荣耀。这还远不是终点，属于你和达拉斯的故事将永远继续下去!\n\n**Let's go Mavs!**\n\n![MFFL](https://s1.ax1x.com/2018/10/15/iaMq5d.jpg)","slug":"达拉斯弧线","published":1,"updated":"2018-11-16T15:30:15.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06u00011xl69fav7q13f","content":"<p>当得知小牛队将参加2018年的NBA中国赛时，我立马发消息给张楚，约定开票时一定要相互提醒。当你喜欢的球星无比低调而所在的球队又不那么热门时，你才会明白这样面对面接触的机会是多么难得，毕竟德克·诺维茨基上次来到中国还是08年北京奥运会，而那早已是10年前的事情了。这个2米13的史上最伟大的大个子投手整个职业生涯都沉浸在自己的篮球事业中，不接代言，不会满世界飞来飞去参加各种商业活动，所以这一次的官方中国赛几乎是所有中国小牛球迷、德克球迷在家门口看到他的唯一机会，尤其是在他刚刚度过40岁生日，下个赛季很有可能是他的最后一年的时候。</p>\n<p>我是从初中才开始关注篮球的，05年看的第一场NBA比赛就是小牛队，央视的解说一整场都在说诺维茨基如何如何，虽然我那时根本没能把名字和人对上号，但诺维茨基这个名字已经深深的印在了我的脑海里。第一年比赛关注的不多，就连总决赛2-0领先热火被翻盘痛失总冠军也是后知后觉，但当06~07赛季小牛队势不可挡的以67胜15负的成绩一举拿下联盟第一和队史最佳战绩时，我的心已经和德克和他带领的小牛队紧紧地关联在了一起。然而收官前几战时任主帅小将军约翰逊保守雪藏主力的做法也为后面被黑八埋下了伏笔，输给勇士队更是放他们挤掉黄金双枪带领的掘金获得了季后赛的最后一个席位。可勇士主教练老尼尔森太了解小牛队了，金州匪帮凶猛的进攻、主将的低迷、德克被限制住，小牛根本找不到予以回击的办法，杰克逊的三分、戴维斯的扣篮、埃利斯的突破无情地撕扯着小牛的防线。当第六场的终场哨声响起，甲骨文球场上空洒满丝带，勇士球员肆意地拥抱庆祝时，我第一次体会到心碎的感觉。常规赛第一的战绩，那么无敌的小牛队居然就这么倒在了第一轮，而赢得了联盟当年认可的德克也只能在首轮之后的发布会上领取自己的常规赛MVP奖杯，尴尬的让人心疼。</p>\n<p>黑八之后，管理层将先发控卫哈里斯交易到篮网换来基德，彼时的基德已经34岁了，虽然组织更加稳健，但哈里斯年轻有速度，刚刚被球队培养起来，这笔交易说实在的并不觉得赚。开赛之后，哈里斯完全释放自己，数据暴涨，带领球队连连胜利，篮网主场球迷更是举起牌子上书：感谢库班。那个时候看的真是很气，觉得库班这个交易不应该进行，这么好的球员就给别人了。小牛这边也确实没有因为引入了基德就有所突破，后面三年接连输给黄蜂掘金马刺，球队最多进入第二轮，西部半决赛对掘金德克更是受到场外女友诈骗案的影响无心恋战。</p>\n<p>那几年身为小牛球迷真的很煎熬，球队虽然年年进入季后赛但都难有作为，突破首轮几近成为奢望，德克软蛋的称号似乎也难以摆脱，媒体也惯性的看衰小牛，国内体坛周报的各种专栏分析都是阴阳怪气的嘲讽，没有人把小牛当成一支真正的强队。三年之中，主教练变成了卡莱尔，球员也几经变更，但无论怎样，心中的支持从来都不会改变，因为我们相信总有一天达拉斯人会重回往日的辉煌。</p>\n<p>直到10~11赛季小牛队通过上赛季的几笔交易和休赛期的运作囤积了足够的阵容深度，卡隆巴特勒、马里昂、泰森钱德勒的到来让小牛球迷又看到了争冠的希望，特别是钱德勒更是被称作是夺冠的最后一块拼图，媒体甚至有小牛的替补可以赢过森林狼队首发的说法。虽然赛季初首发小前锋卡隆巴特勒因伤赛季报销折损了一定的战力，德克缺阵的几场败仗也一度让人对球队的实力打上了问号，但随后球队重整旗鼓后不仅数次打出10+的连胜并且当赛季终结了黄蜂、马刺和热火的10+连胜，成为连胜终结者，后半段认领了被裁掉的佩贾和布鲁尔也进一步巩固了球队阵容，那段时间作为牛蜜真的可以很骄傲的跟同学谈论小牛的战绩。常规赛结束小牛胜场数并列两连冠的湖人以西部第三的位置首轮对上开拓者，虽然成绩处于上半区，但是由于此前连续几年早早出局让各路专家都认定开拓者将赢下这轮系列赛，其实对于我们来讲早就习惯了各路专家的看衰，毕竟这种论调见得太多了。开打后小牛轻松地连赢两场，系列赛似乎没有悬念，开拓者回到主场拿下了第三战。系列赛继续进行，第四场小牛一度领先18分，但是提早松懈的毛病再一次发生，末节罗伊带领开拓者完成了大逆转将总比分扳成2-2。难道我们又要倒在首轮？难道历史将再一次重复？我不愿相信，但也着实有些慌。球队也同样承受着被翻盘的压力和媒体的口诛笔伐，凝重的气氛笼罩着全队，倘若下一场再输那么局势将会完全逆转。好在48小时后，我们看到了小牛不容有失的、坚定的态度，一球一球的稳扎稳打拿下比赛，第六场也没有给开拓者机会，4-2拿下首轮。</p>\n<p>第二轮等待着小牛队的是两连冠势要夺取三连冠的湖人，内外线均衡的湖人队外有科比费舍尔内线有三塔加索尔、拜纳姆、奥多姆。豪华的内线配置放眼全联盟也难有敌手，然而我们的三高诺维茨基、钱德勒和海伍德却好似专门为了针对湖人。话虽这么说，对上这样的冠军球队，小牛有多大的几率获胜连我们自己也没有把握，专家甚至认为湖人将不失一场地轻松晋级下一轮。第一场湖人也确实拿出了冠军的实力，科比频频得分，比分一直压着小牛，也就是从这一场开始小牛展现了他们不服输不轻言放弃的韧性，直到终场前一分多钟的时间湖人队还领先着比分，可接下来的几个回合小牛抓住了湖人的几个失误一举将比分反超，出人意料的拿下了第一场比赛。乘胜追击的小牛又在湖人主场拿下了第二场，这个时候人们终于意识到湖人危险了，但仍然嘴硬湖人会获得最终的胜利。被逼入绝境的湖人来到我们的主场决心摆脱颓势夺回主场优势，开场之后强悍的进攻、凶猛的防守、甚至是拜纳姆抢断德克快攻扣篮似乎让他们找回了一丝冠军的感觉，仿佛又燃起了生的希望。可站在他们对面的是基德、马里昂、特里、钱德勒、诺维茨基啊，这群老头等了太多年了，如果错过今年谁还知道他们还有没有机会染指总冠军，为了冠军，把投失的球投进去，该拿的篮板收下来，一个回合一个回合打，逼迫对方失误，在美航中心山呼海啸的助威声中，小牛逆转取得3-0的领先。我们做到了！面对质疑、面对落后的局面，我们咬着牙坚持了下来，没有球队可以0-3落后翻盘，两冠的湖人也不行，接下来我们要做的就是：SWEEP LA！</p>\n<p>第四场发生了什么我想我会永远铭记吧，当特里一记又一记的三分射入篮筐中，做出经典的喷气机动作从科比身边飞过，当巴里亚的突破逼得拜纳姆恼羞成怒将其肘翻在地，湖人队已经溃不成军。全场比赛投进20记三分，特里和佩贾三分球合计16投15中，狂胜36分，粉碎了湖人的王朝梦，我们以所有人都想不到的方式横扫卫冕冠军挺进西决。整个系列赛，诺维茨基打爆了加索尔，一个又一个无解的投篮打失了加索尔的信心，德克的状态已然进入最佳，还有人可以防得住他吗？这个问题只能留给下一个对手了。</p>\n<p>西决的对手是积攒了大量天赋的青年军雷霆队，经过了上一轮无与伦比的表现，雷霆队知道他们面临的最大的麻烦就是如何防守德克。布鲁克斯教练轮番使用伊巴卡科里森塞弗洛沙等各个位置的球员尝试防守德克，坚决不给他直接投篮的机会即便赔上犯规，结果就是德克只用了15次出手命中12个，罚球24罚24中打破记录，全场砍下48分带走比赛。赛后各路媒体纷纷送上对德克的各种赞誉，张卫平指导也在解说时不停地重复送德克上罚球线就等于送分，可以说那场比赛德克真的打服了很多路人球迷。可能够进入西决雷霆必定也没那么好欺负，年轻有天赋的雷霆三少也给小牛制造了不少麻烦，5场系列赛小牛有两场一度落后十几分，但达拉斯的老将们屡屡展现出了他们对比赛把控能力以及不抛弃不放弃的决心。第四场最后时刻基德晃飞维斯特布鲁克斯命中三分将分差抹平进入加时拿下比赛就是整轮系列赛的一个缩影，小牛用经验和沉稳击败了这支稍显稚嫩的青年军时隔5年再一次进入总决赛。德克在这一轮继续教伊巴卡做人，背身单打，后转身溜底线扣篮，正面封到眼睛上的投篮，万花筒般的进攻方式人挡杀人，佛挡杀佛，场均轰下32分。</p>\n<p>连续将湖人、雷霆斩落马下并没有让人们相信小牛可以有机会在总决赛上笑到最后，因为即将和他们碰面的是东海岸刚刚组建了三巨头的迈阿密热火。5年前正是这支球队击碎了小牛的冠军梦，正如特里说的不管当年那些人还在不在，始终是这支球队拿走了我们的冠军，这一次我们要把它夺回来。一路走来，每一轮系列赛小牛都是被专家预测会出局的球队，我们一次次的用结果狠狠地打了他们的脸，可是“<strong>史上最无悬念总决赛</strong>”、“<strong>热火最多5场内赢得总冠军</strong>”这样的标题还是登上了各大报刊杂志。作为班里唯一的小牛球迷在听到同学一场未打时就宣布热火会是总冠军的言论也只能默默在心里说：那咱们走着瞧。</p>\n<p>11年，我上高二，周末之外获取比赛结果的方式就是通过带手机的同学。第一场小牛丝毫招架不住热火的进攻，双方实力确实存在一定的差距，客场输球多少也在意料之中，但雪上加霜的是这场比赛德克撕裂了他的手指肌肉，作为球队的当家球星，这个伤病影响太大了。第一场已经输了，如果德克的投篮受到影响，那后面的比赛真的就毫无胜算了。所以当我从同学那里获知第二场德克绝杀了热火时，我真的既激动又有点不敢相信，中午赶紧回到家里看体坛快讯，想知道这到底是个什么样的绝杀。过程我们都知道了，德克先是在钱德勒纹丝不动的掩护下命中三分反超比分，热火的查尔莫斯随后三分扳平，最后一攻德克过掉波什左手上篮打进，韦德压哨骑马射箭不中，诺维茨基准绝杀！！！而在此之前小牛一度落后15分，场边詹姆斯和韦德已经提前为这场比赛开始庆祝，可比赛最终结果是我们赢了，毫无疑问这是一场足以载入史册的经典翻盘战役，这颗绝杀球也成为了诺维茨基生涯最高光的时刻。带着1-1的总比分回到主场，第三战我们仍然有机会赢得比赛，但是波什底角的致命投篮以及德克最后的绝杀不中还是让热火重新夺回了主场优势。1-2落后，央视的解说反复强调总决赛7场4胜制以来从来没有球队在1-2落后的情况下逆转，可我想这算是什么魔咒啊，比赛还有四场只落后一场，湖人半决赛被我们打成3-0都有人觉得还能翻盘，到这就要输了，还不是因为我们是小牛，都觉得我们是软柿子，我们偏偏要证明给他们看，什么定律魔咒最后都是给人打破的。</p>\n<p>第四战卡莱尔在阵容上做出调整，巴里亚被提上首发，他灵活而又有节奏的突破搅得热火禁区翻江倒海，这一改变最终让小牛连下三局一举夺得总冠军。第四场德克带着流感封盖波什的扣篮、第五场特里迎着詹姆斯命中超远压哨三分锁定胜局、第六场德克提前走出球员通道······一幕幕场景在脑海里旋转慢放，5年之后，我们终于拿到了早就应该属于我们的冠军奖杯，<strong>We are the Champions</strong> 。摘掉了软蛋的帽子，诺维茨基一冠封神，季后赛无解的表现赢得了所有人的尊重，也顺理成章的捧起FMVP奖杯。</p>\n<p>那个夏天是所有达拉斯球迷的蜜月期，那个夏天也是上天给一直留守达拉斯的德克最好的奖励，一次次的失败没有让我们失去对这支球队的热爱，也没有让德克选择转投他门，冠军对于这座城市实至名归。</p>\n<p>我们希望保持这套阵容赢得更多的冠军，但库班似乎和我们的想法不一样，他希望球队可以在夏天吸引大牌自由球星如霍华德、德隆加盟所以不愿和合同到期的老将续约，于是拳王远走纽约，巴里亚去了森林狼，卡隆巴特勒去了快船，佩贾退役，夺冠阵容瞬间解散，休赛期没有大牌球星加盟更是让小牛迅速退出争冠行列。揭幕战惨败热火，季后赛首轮被雷霆横扫，从世界上最好的篮球队到被横扫的卫冕冠军仅仅过了一年。</p>\n<p>12、13年前后，印象中是在新浪的文字直播间里随手和两个牛蜜留了联系方式，没想到其中一个我们竟一直保持联络到现在，就是开头提到的张楚。开始的时候我们只是聊比赛，预测每场比赛谁会赢，分析季后赛局势，幻想如何补强阵容，渐渐熟悉之后，话题也就不局限篮球了，没事就闲聊两句。大学的那段时光，我们经常约好晚上上线打一会NBA online，毫无疑问地，我们都是使用小牛队。14年我去广州旅游，而张楚刚好在那里工作，两个人隔着网络聊了那么久总算是有个机会可以真正的见个面，我当时穿了一件小牛的T恤，我们一块去了中山大学打野球，看完小蛮腰还错过了地铁，最后狼狈地样子真的是难忘。三年中我们只见过那一面，直到去年我结婚的时候给他发了张请柬，没想到他毫不犹豫地就答应了我会来，为此还特地跟老板请了几天假，心里特别感激。回想起来，两个相隔那么遥远，生活上完全没有交集的人因为一支球队一个球星就在现实生活里结成了深厚的友谊，这种感觉挺不可思议的。</p>\n<p>那几年小牛年年计划钓大鱼，却年年执行B计划，小修小补，球队又陷入了虽为季后赛常客却早早出局的轮回，甚至13年由于德克因伤缺席了大量比赛球队21世纪首次没能进入季后赛。德克一再为了球队建设而降薪，但球队整体实力却鲜有提升。14~15赛季，小牛换回了当年的冠军中锋钱德勒，搭配上蒙塔埃利斯、帕森斯、赖特、阿米奴、理查德杰弗森、费尔顿、哈里斯等一众各具特色的球员小牛一度打出了联盟最高的进攻效率，流畅的进攻加上足够的板凳深度让我觉得我们又一次拥有了冲击冠军的实力。可赛季中的一笔交易却打破了这个体系，小牛送出了队内进攻效率最高的替补赖特、3D克劳德和尼尔森换来了东部全明星控卫隆多，交易过后阵容的磨合加上隆多和卡莱尔的沟通问题，小牛再也打不出原有天花乱坠的进攻，赛季结束后球队便和隆多分道扬镳。也许在当时那真是一个不容错过的交易机会，但我还是惋惜如果没有这笔交易凭借那年水银泻地般的进攻小牛究竟可以走到什么地步。</p>\n<p>几年的光阴消耗过去，诺维茨基的年龄已经不能允许球队继续围绕他来打造争冠阵容了，我也明白球队确实很难迅速崛起，看球的心态也就更加放松，只想好好享受德克打球的日子，看看老大爷在场上多进几个球，总得分榜上努力多超几个，保持健康多打几年就好。很难说清楚自己为什么会坚持追随这样一支起起伏伏的球队十几年，就像德克能在商业化的联盟中效力同一支球队20个赛季之久一样令人称奇，人们都喜欢赢球，都喜欢实力强的球队，球员可以得到更高的关注和利益，球迷可以长久的享受赢球的快感，但或许就是因为我们加入时的初心吧，蓝色的血液一经融入便再也无法分离，生也好，死也好，永远便是达拉斯人了。</p>\n<p>看着德克在生涯的暮年仍然可以用自己的经验不停取分甚至在某些夜晚扛起球队的进攻，看着他背身晃过科比低手上篮，看着他连续晃飞格林稳稳命中中投，看着他用滚烫的手感将自己带进三万分俱乐部，看着他一点一点地爬到历史总得分榜第六位，我忽然有些害怕德克就这样投着投着突然有一天不在球场上了而我还没有看过他。我想计划去达拉斯，想亲眼看一看德克，趁着他还没退役。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaQKZF.jpg\" alt=\"tickets\"></p>\n<p>可能是上天抬爱我们这个稀缺的群体吧，居然给了我们一个可以不用跨越大洋不用办理各种签证在家门口就能看到那支追随了十几年的球队的机会，这是多么幸福的事啊。毫不犹豫的买票、订酒店、买纪念品，只等他们的到来，只为可以近距离的看一眼德克。</p>\n<p>两个月的日夜期盼终于等到了他们启程飞往中国，连续几天看到各个球迷群里提前蹲守在机场酒店的牛蜜分享德克的亲笔签名和合照心里别提有多羡慕多难受了，恨不得自己也马上飞过去要一张签名，特别是在得知德克因伤无法上场时，酒店蹲守可能是和他最好的接触机会了。可家里女儿还小，老婆自己带孩子每天辛苦的很，我没有办法把他们放在家里自己早早的跑去上海，就只能在家里不停的刷手机看牛蜜们捕捉球队和德克的现场实况，同时祈祷自己赛前赶得上酒店的最后一次蹲守机会。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaM259.jpg\" alt=\"dirk\"></p>\n<p>赛前当所有球员都已经登上大巴车好一会儿之后，德克才终于踱着步子出现在门口，跟前几天一样耐心地一个一个给球迷签球衣，可隔着五六排距离的我实在没有办法把球衣递上去，只能尽量踮起脚看一看。</p>\n<p>虽然已经知道德克无法上场，但我还是期盼看到他在赛前热身的时候投投篮，比起没有签到球衣，看不到德克在场上会更让我觉得遗憾。可老大爷不仅最晚进入球场，甚至连球都没摸一下。即使没有办法在场上帮助球队，德克也永远是这支球队的魂，比赛开始之后的每一个暂停德克都是第一个站起来和队友击掌并不时和他们进行交流，而坐在他背后的我也只有趁这时候才可以从正面好好的看一看他，从前只能从电视转播和视频中看到的人，此时终于可以真真切切的被我凝视，我第一次希望比赛的暂停时间可以再长一些。球场上，代表球队未来的DSJ和东契奇尽情的展现着他们的运动天赋和大局观，可我的目光仍然没办法完全聚焦在他们身上，毕竟让我选择来到这个场馆的是那个坐在场下的男人。看着他在场边悄悄的拿起一片口香糖塞进嘴里，看着他暂停时来回踱步，看着他接过大郅赠送的吉他开心的拨弄，就在这些碎片化的间隙中，蜂鸣声响起，目送德克缓步走出球员通道，属于我的朝圣之旅也结束了。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMybF.jpg\" alt=\"dirk\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMsDU.jpg\" alt=\"dirk\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMgUJ.jpg\" alt=\"dirk\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMf81.jpg\" alt=\"dirk\"></p>\n<p>不知不觉这辆德国战车已经开了20年了，载着我们的青春与无数的回忆，下个赛季无论你是司机还是坐在副驾驶，我只希望能多看你投出几道最美弧线。谢谢你，德克，谢谢你这么久了依然站在球场上，谢谢你带给我们的感动，谢谢你让我相信忠诚，谢谢你给达拉斯这座城市的荣耀。这还远不是终点，属于你和达拉斯的故事将永远继续下去!</p>\n<p><strong>Let’s go Mavs!</strong></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMq5d.jpg\" alt=\"MFFL\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>当得知小牛队将参加2018年的NBA中国赛时，我立马发消息给张楚，约定开票时一定要相互提醒。当你喜欢的球星无比低调而所在的球队又不那么热门时，你才会明白这样面对面接触的机会是多么难得，毕竟德克·诺维茨基上次来到中国还是08年北京奥运会，而那早已是10年前的事情了。这个2米13的史上最伟大的大个子投手整个职业生涯都沉浸在自己的篮球事业中，不接代言，不会满世界飞来飞去参加各种商业活动，所以这一次的官方中国赛几乎是所有中国小牛球迷、德克球迷在家门口看到他的唯一机会，尤其是在他刚刚度过40岁生日，下个赛季很有可能是他的最后一年的时候。</p>\n<p>我是从初中才开始关注篮球的，05年看的第一场NBA比赛就是小牛队，央视的解说一整场都在说诺维茨基如何如何，虽然我那时根本没能把名字和人对上号，但诺维茨基这个名字已经深深的印在了我的脑海里。第一年比赛关注的不多，就连总决赛2-0领先热火被翻盘痛失总冠军也是后知后觉，但当06~07赛季小牛队势不可挡的以67胜15负的成绩一举拿下联盟第一和队史最佳战绩时，我的心已经和德克和他带领的小牛队紧紧地关联在了一起。然而收官前几战时任主帅小将军约翰逊保守雪藏主力的做法也为后面被黑八埋下了伏笔，输给勇士队更是放他们挤掉黄金双枪带领的掘金获得了季后赛的最后一个席位。可勇士主教练老尼尔森太了解小牛队了，金州匪帮凶猛的进攻、主将的低迷、德克被限制住，小牛根本找不到予以回击的办法，杰克逊的三分、戴维斯的扣篮、埃利斯的突破无情地撕扯着小牛的防线。当第六场的终场哨声响起，甲骨文球场上空洒满丝带，勇士球员肆意地拥抱庆祝时，我第一次体会到心碎的感觉。常规赛第一的战绩，那么无敌的小牛队居然就这么倒在了第一轮，而赢得了联盟当年认可的德克也只能在首轮之后的发布会上领取自己的常规赛MVP奖杯，尴尬的让人心疼。</p>\n<p>黑八之后，管理层将先发控卫哈里斯交易到篮网换来基德，彼时的基德已经34岁了，虽然组织更加稳健，但哈里斯年轻有速度，刚刚被球队培养起来，这笔交易说实在的并不觉得赚。开赛之后，哈里斯完全释放自己，数据暴涨，带领球队连连胜利，篮网主场球迷更是举起牌子上书：感谢库班。那个时候看的真是很气，觉得库班这个交易不应该进行，这么好的球员就给别人了。小牛这边也确实没有因为引入了基德就有所突破，后面三年接连输给黄蜂掘金马刺，球队最多进入第二轮，西部半决赛对掘金德克更是受到场外女友诈骗案的影响无心恋战。</p>\n<p>那几年身为小牛球迷真的很煎熬，球队虽然年年进入季后赛但都难有作为，突破首轮几近成为奢望，德克软蛋的称号似乎也难以摆脱，媒体也惯性的看衰小牛，国内体坛周报的各种专栏分析都是阴阳怪气的嘲讽，没有人把小牛当成一支真正的强队。三年之中，主教练变成了卡莱尔，球员也几经变更，但无论怎样，心中的支持从来都不会改变，因为我们相信总有一天达拉斯人会重回往日的辉煌。</p>\n<p>直到10~11赛季小牛队通过上赛季的几笔交易和休赛期的运作囤积了足够的阵容深度，卡隆巴特勒、马里昂、泰森钱德勒的到来让小牛球迷又看到了争冠的希望，特别是钱德勒更是被称作是夺冠的最后一块拼图，媒体甚至有小牛的替补可以赢过森林狼队首发的说法。虽然赛季初首发小前锋卡隆巴特勒因伤赛季报销折损了一定的战力，德克缺阵的几场败仗也一度让人对球队的实力打上了问号，但随后球队重整旗鼓后不仅数次打出10+的连胜并且当赛季终结了黄蜂、马刺和热火的10+连胜，成为连胜终结者，后半段认领了被裁掉的佩贾和布鲁尔也进一步巩固了球队阵容，那段时间作为牛蜜真的可以很骄傲的跟同学谈论小牛的战绩。常规赛结束小牛胜场数并列两连冠的湖人以西部第三的位置首轮对上开拓者，虽然成绩处于上半区，但是由于此前连续几年早早出局让各路专家都认定开拓者将赢下这轮系列赛，其实对于我们来讲早就习惯了各路专家的看衰，毕竟这种论调见得太多了。开打后小牛轻松地连赢两场，系列赛似乎没有悬念，开拓者回到主场拿下了第三战。系列赛继续进行，第四场小牛一度领先18分，但是提早松懈的毛病再一次发生，末节罗伊带领开拓者完成了大逆转将总比分扳成2-2。难道我们又要倒在首轮？难道历史将再一次重复？我不愿相信，但也着实有些慌。球队也同样承受着被翻盘的压力和媒体的口诛笔伐，凝重的气氛笼罩着全队，倘若下一场再输那么局势将会完全逆转。好在48小时后，我们看到了小牛不容有失的、坚定的态度，一球一球的稳扎稳打拿下比赛，第六场也没有给开拓者机会，4-2拿下首轮。</p>\n<p>第二轮等待着小牛队的是两连冠势要夺取三连冠的湖人，内外线均衡的湖人队外有科比费舍尔内线有三塔加索尔、拜纳姆、奥多姆。豪华的内线配置放眼全联盟也难有敌手，然而我们的三高诺维茨基、钱德勒和海伍德却好似专门为了针对湖人。话虽这么说，对上这样的冠军球队，小牛有多大的几率获胜连我们自己也没有把握，专家甚至认为湖人将不失一场地轻松晋级下一轮。第一场湖人也确实拿出了冠军的实力，科比频频得分，比分一直压着小牛，也就是从这一场开始小牛展现了他们不服输不轻言放弃的韧性，直到终场前一分多钟的时间湖人队还领先着比分，可接下来的几个回合小牛抓住了湖人的几个失误一举将比分反超，出人意料的拿下了第一场比赛。乘胜追击的小牛又在湖人主场拿下了第二场，这个时候人们终于意识到湖人危险了，但仍然嘴硬湖人会获得最终的胜利。被逼入绝境的湖人来到我们的主场决心摆脱颓势夺回主场优势，开场之后强悍的进攻、凶猛的防守、甚至是拜纳姆抢断德克快攻扣篮似乎让他们找回了一丝冠军的感觉，仿佛又燃起了生的希望。可站在他们对面的是基德、马里昂、特里、钱德勒、诺维茨基啊，这群老头等了太多年了，如果错过今年谁还知道他们还有没有机会染指总冠军，为了冠军，把投失的球投进去，该拿的篮板收下来，一个回合一个回合打，逼迫对方失误，在美航中心山呼海啸的助威声中，小牛逆转取得3-0的领先。我们做到了！面对质疑、面对落后的局面，我们咬着牙坚持了下来，没有球队可以0-3落后翻盘，两冠的湖人也不行，接下来我们要做的就是：SWEEP LA！</p>\n<p>第四场发生了什么我想我会永远铭记吧，当特里一记又一记的三分射入篮筐中，做出经典的喷气机动作从科比身边飞过，当巴里亚的突破逼得拜纳姆恼羞成怒将其肘翻在地，湖人队已经溃不成军。全场比赛投进20记三分，特里和佩贾三分球合计16投15中，狂胜36分，粉碎了湖人的王朝梦，我们以所有人都想不到的方式横扫卫冕冠军挺进西决。整个系列赛，诺维茨基打爆了加索尔，一个又一个无解的投篮打失了加索尔的信心，德克的状态已然进入最佳，还有人可以防得住他吗？这个问题只能留给下一个对手了。</p>\n<p>西决的对手是积攒了大量天赋的青年军雷霆队，经过了上一轮无与伦比的表现，雷霆队知道他们面临的最大的麻烦就是如何防守德克。布鲁克斯教练轮番使用伊巴卡科里森塞弗洛沙等各个位置的球员尝试防守德克，坚决不给他直接投篮的机会即便赔上犯规，结果就是德克只用了15次出手命中12个，罚球24罚24中打破记录，全场砍下48分带走比赛。赛后各路媒体纷纷送上对德克的各种赞誉，张卫平指导也在解说时不停地重复送德克上罚球线就等于送分，可以说那场比赛德克真的打服了很多路人球迷。可能够进入西决雷霆必定也没那么好欺负，年轻有天赋的雷霆三少也给小牛制造了不少麻烦，5场系列赛小牛有两场一度落后十几分，但达拉斯的老将们屡屡展现出了他们对比赛把控能力以及不抛弃不放弃的决心。第四场最后时刻基德晃飞维斯特布鲁克斯命中三分将分差抹平进入加时拿下比赛就是整轮系列赛的一个缩影，小牛用经验和沉稳击败了这支稍显稚嫩的青年军时隔5年再一次进入总决赛。德克在这一轮继续教伊巴卡做人，背身单打，后转身溜底线扣篮，正面封到眼睛上的投篮，万花筒般的进攻方式人挡杀人，佛挡杀佛，场均轰下32分。</p>\n<p>连续将湖人、雷霆斩落马下并没有让人们相信小牛可以有机会在总决赛上笑到最后，因为即将和他们碰面的是东海岸刚刚组建了三巨头的迈阿密热火。5年前正是这支球队击碎了小牛的冠军梦，正如特里说的不管当年那些人还在不在，始终是这支球队拿走了我们的冠军，这一次我们要把它夺回来。一路走来，每一轮系列赛小牛都是被专家预测会出局的球队，我们一次次的用结果狠狠地打了他们的脸，可是“<strong>史上最无悬念总决赛</strong>”、“<strong>热火最多5场内赢得总冠军</strong>”这样的标题还是登上了各大报刊杂志。作为班里唯一的小牛球迷在听到同学一场未打时就宣布热火会是总冠军的言论也只能默默在心里说：那咱们走着瞧。</p>\n<p>11年，我上高二，周末之外获取比赛结果的方式就是通过带手机的同学。第一场小牛丝毫招架不住热火的进攻，双方实力确实存在一定的差距，客场输球多少也在意料之中，但雪上加霜的是这场比赛德克撕裂了他的手指肌肉，作为球队的当家球星，这个伤病影响太大了。第一场已经输了，如果德克的投篮受到影响，那后面的比赛真的就毫无胜算了。所以当我从同学那里获知第二场德克绝杀了热火时，我真的既激动又有点不敢相信，中午赶紧回到家里看体坛快讯，想知道这到底是个什么样的绝杀。过程我们都知道了，德克先是在钱德勒纹丝不动的掩护下命中三分反超比分，热火的查尔莫斯随后三分扳平，最后一攻德克过掉波什左手上篮打进，韦德压哨骑马射箭不中，诺维茨基准绝杀！！！而在此之前小牛一度落后15分，场边詹姆斯和韦德已经提前为这场比赛开始庆祝，可比赛最终结果是我们赢了，毫无疑问这是一场足以载入史册的经典翻盘战役，这颗绝杀球也成为了诺维茨基生涯最高光的时刻。带着1-1的总比分回到主场，第三战我们仍然有机会赢得比赛，但是波什底角的致命投篮以及德克最后的绝杀不中还是让热火重新夺回了主场优势。1-2落后，央视的解说反复强调总决赛7场4胜制以来从来没有球队在1-2落后的情况下逆转，可我想这算是什么魔咒啊，比赛还有四场只落后一场，湖人半决赛被我们打成3-0都有人觉得还能翻盘，到这就要输了，还不是因为我们是小牛，都觉得我们是软柿子，我们偏偏要证明给他们看，什么定律魔咒最后都是给人打破的。</p>\n<p>第四战卡莱尔在阵容上做出调整，巴里亚被提上首发，他灵活而又有节奏的突破搅得热火禁区翻江倒海，这一改变最终让小牛连下三局一举夺得总冠军。第四场德克带着流感封盖波什的扣篮、第五场特里迎着詹姆斯命中超远压哨三分锁定胜局、第六场德克提前走出球员通道······一幕幕场景在脑海里旋转慢放，5年之后，我们终于拿到了早就应该属于我们的冠军奖杯，<strong>We are the Champions</strong> 。摘掉了软蛋的帽子，诺维茨基一冠封神，季后赛无解的表现赢得了所有人的尊重，也顺理成章的捧起FMVP奖杯。</p>\n<p>那个夏天是所有达拉斯球迷的蜜月期，那个夏天也是上天给一直留守达拉斯的德克最好的奖励，一次次的失败没有让我们失去对这支球队的热爱，也没有让德克选择转投他门，冠军对于这座城市实至名归。</p>\n<p>我们希望保持这套阵容赢得更多的冠军，但库班似乎和我们的想法不一样，他希望球队可以在夏天吸引大牌自由球星如霍华德、德隆加盟所以不愿和合同到期的老将续约，于是拳王远走纽约，巴里亚去了森林狼，卡隆巴特勒去了快船，佩贾退役，夺冠阵容瞬间解散，休赛期没有大牌球星加盟更是让小牛迅速退出争冠行列。揭幕战惨败热火，季后赛首轮被雷霆横扫，从世界上最好的篮球队到被横扫的卫冕冠军仅仅过了一年。</p>\n<p>12、13年前后，印象中是在新浪的文字直播间里随手和两个牛蜜留了联系方式，没想到其中一个我们竟一直保持联络到现在，就是开头提到的张楚。开始的时候我们只是聊比赛，预测每场比赛谁会赢，分析季后赛局势，幻想如何补强阵容，渐渐熟悉之后，话题也就不局限篮球了，没事就闲聊两句。大学的那段时光，我们经常约好晚上上线打一会NBA online，毫无疑问地，我们都是使用小牛队。14年我去广州旅游，而张楚刚好在那里工作，两个人隔着网络聊了那么久总算是有个机会可以真正的见个面，我当时穿了一件小牛的T恤，我们一块去了中山大学打野球，看完小蛮腰还错过了地铁，最后狼狈地样子真的是难忘。三年中我们只见过那一面，直到去年我结婚的时候给他发了张请柬，没想到他毫不犹豫地就答应了我会来，为此还特地跟老板请了几天假，心里特别感激。回想起来，两个相隔那么遥远，生活上完全没有交集的人因为一支球队一个球星就在现实生活里结成了深厚的友谊，这种感觉挺不可思议的。</p>\n<p>那几年小牛年年计划钓大鱼，却年年执行B计划，小修小补，球队又陷入了虽为季后赛常客却早早出局的轮回，甚至13年由于德克因伤缺席了大量比赛球队21世纪首次没能进入季后赛。德克一再为了球队建设而降薪，但球队整体实力却鲜有提升。14~15赛季，小牛换回了当年的冠军中锋钱德勒，搭配上蒙塔埃利斯、帕森斯、赖特、阿米奴、理查德杰弗森、费尔顿、哈里斯等一众各具特色的球员小牛一度打出了联盟最高的进攻效率，流畅的进攻加上足够的板凳深度让我觉得我们又一次拥有了冲击冠军的实力。可赛季中的一笔交易却打破了这个体系，小牛送出了队内进攻效率最高的替补赖特、3D克劳德和尼尔森换来了东部全明星控卫隆多，交易过后阵容的磨合加上隆多和卡莱尔的沟通问题，小牛再也打不出原有天花乱坠的进攻，赛季结束后球队便和隆多分道扬镳。也许在当时那真是一个不容错过的交易机会，但我还是惋惜如果没有这笔交易凭借那年水银泻地般的进攻小牛究竟可以走到什么地步。</p>\n<p>几年的光阴消耗过去，诺维茨基的年龄已经不能允许球队继续围绕他来打造争冠阵容了，我也明白球队确实很难迅速崛起，看球的心态也就更加放松，只想好好享受德克打球的日子，看看老大爷在场上多进几个球，总得分榜上努力多超几个，保持健康多打几年就好。很难说清楚自己为什么会坚持追随这样一支起起伏伏的球队十几年，就像德克能在商业化的联盟中效力同一支球队20个赛季之久一样令人称奇，人们都喜欢赢球，都喜欢实力强的球队，球员可以得到更高的关注和利益，球迷可以长久的享受赢球的快感，但或许就是因为我们加入时的初心吧，蓝色的血液一经融入便再也无法分离，生也好，死也好，永远便是达拉斯人了。</p>\n<p>看着德克在生涯的暮年仍然可以用自己的经验不停取分甚至在某些夜晚扛起球队的进攻，看着他背身晃过科比低手上篮，看着他连续晃飞格林稳稳命中中投，看着他用滚烫的手感将自己带进三万分俱乐部，看着他一点一点地爬到历史总得分榜第六位，我忽然有些害怕德克就这样投着投着突然有一天不在球场上了而我还没有看过他。我想计划去达拉斯，想亲眼看一看德克，趁着他还没退役。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaQKZF.jpg\" alt=\"tickets\"></p>\n<p>可能是上天抬爱我们这个稀缺的群体吧，居然给了我们一个可以不用跨越大洋不用办理各种签证在家门口就能看到那支追随了十几年的球队的机会，这是多么幸福的事啊。毫不犹豫的买票、订酒店、买纪念品，只等他们的到来，只为可以近距离的看一眼德克。</p>\n<p>两个月的日夜期盼终于等到了他们启程飞往中国，连续几天看到各个球迷群里提前蹲守在机场酒店的牛蜜分享德克的亲笔签名和合照心里别提有多羡慕多难受了，恨不得自己也马上飞过去要一张签名，特别是在得知德克因伤无法上场时，酒店蹲守可能是和他最好的接触机会了。可家里女儿还小，老婆自己带孩子每天辛苦的很，我没有办法把他们放在家里自己早早的跑去上海，就只能在家里不停的刷手机看牛蜜们捕捉球队和德克的现场实况，同时祈祷自己赛前赶得上酒店的最后一次蹲守机会。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaM259.jpg\" alt=\"dirk\"></p>\n<p>赛前当所有球员都已经登上大巴车好一会儿之后，德克才终于踱着步子出现在门口，跟前几天一样耐心地一个一个给球迷签球衣，可隔着五六排距离的我实在没有办法把球衣递上去，只能尽量踮起脚看一看。</p>\n<p>虽然已经知道德克无法上场，但我还是期盼看到他在赛前热身的时候投投篮，比起没有签到球衣，看不到德克在场上会更让我觉得遗憾。可老大爷不仅最晚进入球场，甚至连球都没摸一下。即使没有办法在场上帮助球队，德克也永远是这支球队的魂，比赛开始之后的每一个暂停德克都是第一个站起来和队友击掌并不时和他们进行交流，而坐在他背后的我也只有趁这时候才可以从正面好好的看一看他，从前只能从电视转播和视频中看到的人，此时终于可以真真切切的被我凝视，我第一次希望比赛的暂停时间可以再长一些。球场上，代表球队未来的DSJ和东契奇尽情的展现着他们的运动天赋和大局观，可我的目光仍然没办法完全聚焦在他们身上，毕竟让我选择来到这个场馆的是那个坐在场下的男人。看着他在场边悄悄的拿起一片口香糖塞进嘴里，看着他暂停时来回踱步，看着他接过大郅赠送的吉他开心的拨弄，就在这些碎片化的间隙中，蜂鸣声响起，目送德克缓步走出球员通道，属于我的朝圣之旅也结束了。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMybF.jpg\" alt=\"dirk\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMsDU.jpg\" alt=\"dirk\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMgUJ.jpg\" alt=\"dirk\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMf81.jpg\" alt=\"dirk\"></p>\n<p>不知不觉这辆德国战车已经开了20年了，载着我们的青春与无数的回忆，下个赛季无论你是司机还是坐在副驾驶，我只希望能多看你投出几道最美弧线。谢谢你，德克，谢谢你这么久了依然站在球场上，谢谢你带给我们的感动，谢谢你让我相信忠诚，谢谢你给达拉斯这座城市的荣耀。这还远不是终点，属于你和达拉斯的故事将永远继续下去!</p>\n<p><strong>Let’s go Mavs!</strong></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMq5d.jpg\" alt=\"MFFL\"></p>\n"},{"title":"生命中那些不期而遇","date":"2016-10-08T12:42:23.000Z","urlname":"meet-beautiful","_content":"没有期待已久的毕业旅行，也没有了漫长的暑假。就在匆忙间便完成了从学生到上班族的身份转变。不再能够说走就走，不再拥有那么多的假日，可是世界还是得走啊，我这么爱玩的人，太久不旅行是要憋坏的。\n\n青岛，一个我几年前就想去的地方，却一直拖到了这个时候才决定去。即使适逢十一黄金周，即使中途各种原因最后只剩我一个人前往，尤其在经历了去年一个人在霞浦旅途中的孤独和落寞之后让我有些害怕再次一个人踏上路途，可这些仍然无法阻拦我内心对大海的向往。\n\n老实讲，即使是已经坐在了开往青岛的高铁上，我也没想过这竟是如此让我难忘的一次旅行。\n\n![station](https://s1.ax1x.com/2018/10/15/iaMbUH.jpg)\n\n到达青岛之前程铭和我说当天的阳光有点足，可当我踏出车站的时候感受到的是无比舒适的海风，车站旁边便是海滩，栈桥上已经挤了很多人。不得不说青岛的旅游巴士还是很方便的，有很多选择可以到达想去的目的地。\n\n![park](https://s1.ax1x.com/2018/10/15/iaMoDO.jpg)\n\n先到达了提前订好的酒店，然后趁着天色还早，先一个人找些近一点的景点转一转。出门前向酒店前台打听了一下去各个景区的路线，前台一连串快速熟练地介绍让我有一种听相声演员报菜名的感觉。\n\n酒店对面就是紧邻海边的鲁迅公园，只需要走五分钟就能到海边，这里没有细沙，只有大量尖锐巨大的礁石，岸边风浪很大，待久了还真是有点快被冻感冒了。而海水，之前也有去过一些海滩，大连的星海公园，秦皇岛的金沙滩，还有霞浦的大京等等，但海水都有不同程度的浑浊，可青岛的海水真的是清澈的碧绿啊，和碧蓝的天空相映衬，美得一塌糊涂。\n\n翻过了几块相连的礁石，找了一块靠近海边又不会被海浪打到的地方坐了下来，打开手机里的后摇歌单随机播放，就那么看着此起彼伏的海浪，遥望辽阔的天空，耳中down down down继而不断up的旋律颇为符合此情此景，我想如果天气足够晴朗并且手机电量足够我能坐在这里呆一天。\n\n![sea](https://s1.ax1x.com/2018/10/15/iaMOPA.jpg)\n\n第二站是八大关，离鲁迅公园不是很远，但可能和来之前的预想不太一样吧，就是以八条著名的关隘命名的街道和一些建筑组成的，简单转了一圈觉得有些索然无味，也可能是没有同伴的弊端再次在这个时候体现了吧。顺路去第二海水浴场看了一会后天色也不早了，坐车回家。\n\n这一次在青岛要停留两个晚上，一个人四处瞎转难免太无聊，所以选择的是酒店的青旅房型，这样可以认识不同地方来玩的人，有了上次在丽江青旅的体验，表示还挺喜欢这样的旅行方式的。\n\n回到房间已经有一个人在了，是个在安徽上学的学生，都是喜欢旅行的人话题也自然而然地围绕这方面进行，这时候肚子也饿了，两个人出去找了一家小店点了几个菜喝了点酒，回来之后发现两个韩国妹子也回来了，之前这小哥就和我说过，至于为什么会有女生，因为这个房间是男女混住啊哈哈，因为想着一群糙汉子结伴出去玩多没意思啊，但真没报太大期望会有妹子住进来。过了一会陆续有两个南航的学生，一个在天津上学的福建三明小哥和一个也是从杭州过来的姐姐住进房间，几个人相互介绍闲扯了几句之后，我拉了一个微信群把几个人加进来，第一晚也没太敢和两个韩国妹子说话，就简单打了声招呼，大家也或多或少经历了旅途的劳累，简单收拾便各自睡去。\n\n因为提前看了天气预报第二天有雨，不太适合去海边玩，而另外几个人也有原本安排好的游玩计划，我自己也没有太明确的安排就和两个南航小学弟一起去爬崂山，天知道我当时怎么会下这个决定，下雨不适合去海边，难道就适合爬山了吗？Too young too naive啊！事实证明这个决定果然是脑子抽了才会做，到了山顶啥也没看到不说，被雨淋得浑身湿透。\n\n在我们狼狈不堪的爬山的时候，朱莉赟已经和两个韩国美女结伴去逛了啤酒博物馆和天幕城，我们在群里相约晚上一起吃饭。喜欢玩的人通常对吃也都很感兴趣，我们那天选了口味相对大众一点的火锅，玩乐的气氛下大家都聊得很开心，韩国妹子是在北京的留学生，所以交流也不成问题。来青岛自然啤酒是不能缺少的，韩国人果然能喝酒啊，而且一定要喝凉的，这样才够爽。吃够了大家觉得还不尽兴就去开了个KTV，路上又买了几罐啤酒，丁允自己的酒喝完了又把我们的酒也都喝了，快结束的时候又想找个气氛更浓一点的酒吧，我们只好劝她已经比较晚了，还是去海边逛一逛吧。\n\n黑夜笼罩下的青岛是那么地安静，即使在这十一长假里，夜里十点多街道上就已经鲜有人迹了，一路上除了我们说话的声音就只有拖鞋摩擦地面的声音，整齐而又清晰。褪去了白日的喧嚣，夜晚的栈桥上不见了拥挤的人潮，只有三三两两的游人乘着海风在桥上散步，惬意又自在。\n\n![our](https://s1.ax1x.com/2018/10/15/iaMIKK.jpg)\n\n雨后的海滩有些潮湿，也比平时更加细腻和柔软，光着脚走在海边，感受不时漫过脚面的海浪，带着一点冰凉，如果我在这样的城市生活，能偶尔在结束了一天的辛劳后来这里走一走，那该多好啊。\n\n出来旅行通常都是睡得晚起得早，因为想多看一些风景，因为不想浪费这难得的空闲。金沙滩，据说是青岛最好的海滩，这是我们第三天的目的地。早上几个女生都不愿意起，最后被我们硬拉了起来，但还是比原定出发的时间晚了一个小时左右，常曦前一天走得太累就没和我们一起去。到黄岛要差不多一个半小时的车程，途中经过胶州湾跨海隧道，全长7.8公里，只能感慨人类征服自然的能力真的很强大。\n\n这一天的天气很晴朗，阳光充足但并不热，海滩很大很长，沙子很细，甩掉鞋子飞奔到海岸线，我们在沙滩上写写画画，留下了一地青春。架起三脚架，拿起自拍杆，保存住我们的映像。虽然不同国家，却又有相似的属于曾经童年的游戏，围坐在沙堆旁，好似我们又回到了孩童时期，此时可以只沉浸在玩乐中。\n\n![words](https://s1.ax1x.com/2018/10/15/iaMX8I.jpg)\n\n![moment](https://s1.ax1x.com/2018/10/15/iaM4v6.jpg)\n\n路上总有相遇，人生总有惊喜，这一次是你们，下一次又会遇到谁和谁，又会发生怎样的故事，谁也不知道，谁也无法预料，但我知道他们一定在这里或者那里等着我，等着我说，你好，我叫XXX，我来自...","source":"_posts/生命中那些不期而遇.md","raw":"---\ntitle: 生命中那些不期而遇\ndate: 2016-10-08 20:42:23\nurlname: meet-beautiful\ncategories: [\"生活\"]\ntags: [\"生活\"]\n---\n没有期待已久的毕业旅行，也没有了漫长的暑假。就在匆忙间便完成了从学生到上班族的身份转变。不再能够说走就走，不再拥有那么多的假日，可是世界还是得走啊，我这么爱玩的人，太久不旅行是要憋坏的。\n\n青岛，一个我几年前就想去的地方，却一直拖到了这个时候才决定去。即使适逢十一黄金周，即使中途各种原因最后只剩我一个人前往，尤其在经历了去年一个人在霞浦旅途中的孤独和落寞之后让我有些害怕再次一个人踏上路途，可这些仍然无法阻拦我内心对大海的向往。\n\n老实讲，即使是已经坐在了开往青岛的高铁上，我也没想过这竟是如此让我难忘的一次旅行。\n\n![station](https://s1.ax1x.com/2018/10/15/iaMbUH.jpg)\n\n到达青岛之前程铭和我说当天的阳光有点足，可当我踏出车站的时候感受到的是无比舒适的海风，车站旁边便是海滩，栈桥上已经挤了很多人。不得不说青岛的旅游巴士还是很方便的，有很多选择可以到达想去的目的地。\n\n![park](https://s1.ax1x.com/2018/10/15/iaMoDO.jpg)\n\n先到达了提前订好的酒店，然后趁着天色还早，先一个人找些近一点的景点转一转。出门前向酒店前台打听了一下去各个景区的路线，前台一连串快速熟练地介绍让我有一种听相声演员报菜名的感觉。\n\n酒店对面就是紧邻海边的鲁迅公园，只需要走五分钟就能到海边，这里没有细沙，只有大量尖锐巨大的礁石，岸边风浪很大，待久了还真是有点快被冻感冒了。而海水，之前也有去过一些海滩，大连的星海公园，秦皇岛的金沙滩，还有霞浦的大京等等，但海水都有不同程度的浑浊，可青岛的海水真的是清澈的碧绿啊，和碧蓝的天空相映衬，美得一塌糊涂。\n\n翻过了几块相连的礁石，找了一块靠近海边又不会被海浪打到的地方坐了下来，打开手机里的后摇歌单随机播放，就那么看着此起彼伏的海浪，遥望辽阔的天空，耳中down down down继而不断up的旋律颇为符合此情此景，我想如果天气足够晴朗并且手机电量足够我能坐在这里呆一天。\n\n![sea](https://s1.ax1x.com/2018/10/15/iaMOPA.jpg)\n\n第二站是八大关，离鲁迅公园不是很远，但可能和来之前的预想不太一样吧，就是以八条著名的关隘命名的街道和一些建筑组成的，简单转了一圈觉得有些索然无味，也可能是没有同伴的弊端再次在这个时候体现了吧。顺路去第二海水浴场看了一会后天色也不早了，坐车回家。\n\n这一次在青岛要停留两个晚上，一个人四处瞎转难免太无聊，所以选择的是酒店的青旅房型，这样可以认识不同地方来玩的人，有了上次在丽江青旅的体验，表示还挺喜欢这样的旅行方式的。\n\n回到房间已经有一个人在了，是个在安徽上学的学生，都是喜欢旅行的人话题也自然而然地围绕这方面进行，这时候肚子也饿了，两个人出去找了一家小店点了几个菜喝了点酒，回来之后发现两个韩国妹子也回来了，之前这小哥就和我说过，至于为什么会有女生，因为这个房间是男女混住啊哈哈，因为想着一群糙汉子结伴出去玩多没意思啊，但真没报太大期望会有妹子住进来。过了一会陆续有两个南航的学生，一个在天津上学的福建三明小哥和一个也是从杭州过来的姐姐住进房间，几个人相互介绍闲扯了几句之后，我拉了一个微信群把几个人加进来，第一晚也没太敢和两个韩国妹子说话，就简单打了声招呼，大家也或多或少经历了旅途的劳累，简单收拾便各自睡去。\n\n因为提前看了天气预报第二天有雨，不太适合去海边玩，而另外几个人也有原本安排好的游玩计划，我自己也没有太明确的安排就和两个南航小学弟一起去爬崂山，天知道我当时怎么会下这个决定，下雨不适合去海边，难道就适合爬山了吗？Too young too naive啊！事实证明这个决定果然是脑子抽了才会做，到了山顶啥也没看到不说，被雨淋得浑身湿透。\n\n在我们狼狈不堪的爬山的时候，朱莉赟已经和两个韩国美女结伴去逛了啤酒博物馆和天幕城，我们在群里相约晚上一起吃饭。喜欢玩的人通常对吃也都很感兴趣，我们那天选了口味相对大众一点的火锅，玩乐的气氛下大家都聊得很开心，韩国妹子是在北京的留学生，所以交流也不成问题。来青岛自然啤酒是不能缺少的，韩国人果然能喝酒啊，而且一定要喝凉的，这样才够爽。吃够了大家觉得还不尽兴就去开了个KTV，路上又买了几罐啤酒，丁允自己的酒喝完了又把我们的酒也都喝了，快结束的时候又想找个气氛更浓一点的酒吧，我们只好劝她已经比较晚了，还是去海边逛一逛吧。\n\n黑夜笼罩下的青岛是那么地安静，即使在这十一长假里，夜里十点多街道上就已经鲜有人迹了，一路上除了我们说话的声音就只有拖鞋摩擦地面的声音，整齐而又清晰。褪去了白日的喧嚣，夜晚的栈桥上不见了拥挤的人潮，只有三三两两的游人乘着海风在桥上散步，惬意又自在。\n\n![our](https://s1.ax1x.com/2018/10/15/iaMIKK.jpg)\n\n雨后的海滩有些潮湿，也比平时更加细腻和柔软，光着脚走在海边，感受不时漫过脚面的海浪，带着一点冰凉，如果我在这样的城市生活，能偶尔在结束了一天的辛劳后来这里走一走，那该多好啊。\n\n出来旅行通常都是睡得晚起得早，因为想多看一些风景，因为不想浪费这难得的空闲。金沙滩，据说是青岛最好的海滩，这是我们第三天的目的地。早上几个女生都不愿意起，最后被我们硬拉了起来，但还是比原定出发的时间晚了一个小时左右，常曦前一天走得太累就没和我们一起去。到黄岛要差不多一个半小时的车程，途中经过胶州湾跨海隧道，全长7.8公里，只能感慨人类征服自然的能力真的很强大。\n\n这一天的天气很晴朗，阳光充足但并不热，海滩很大很长，沙子很细，甩掉鞋子飞奔到海岸线，我们在沙滩上写写画画，留下了一地青春。架起三脚架，拿起自拍杆，保存住我们的映像。虽然不同国家，却又有相似的属于曾经童年的游戏，围坐在沙堆旁，好似我们又回到了孩童时期，此时可以只沉浸在玩乐中。\n\n![words](https://s1.ax1x.com/2018/10/15/iaMX8I.jpg)\n\n![moment](https://s1.ax1x.com/2018/10/15/iaM4v6.jpg)\n\n路上总有相遇，人生总有惊喜，这一次是你们，下一次又会遇到谁和谁，又会发生怎样的故事，谁也不知道，谁也无法预料，但我知道他们一定在这里或者那里等着我，等着我说，你好，我叫XXX，我来自...","slug":"生命中那些不期而遇","published":1,"updated":"2018-11-16T15:30:15.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp5k06u40014xl694a05jj81","content":"<p>没有期待已久的毕业旅行，也没有了漫长的暑假。就在匆忙间便完成了从学生到上班族的身份转变。不再能够说走就走，不再拥有那么多的假日，可是世界还是得走啊，我这么爱玩的人，太久不旅行是要憋坏的。</p>\n<p>青岛，一个我几年前就想去的地方，却一直拖到了这个时候才决定去。即使适逢十一黄金周，即使中途各种原因最后只剩我一个人前往，尤其在经历了去年一个人在霞浦旅途中的孤独和落寞之后让我有些害怕再次一个人踏上路途，可这些仍然无法阻拦我内心对大海的向往。</p>\n<p>老实讲，即使是已经坐在了开往青岛的高铁上，我也没想过这竟是如此让我难忘的一次旅行。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMbUH.jpg\" alt=\"station\"></p>\n<p>到达青岛之前程铭和我说当天的阳光有点足，可当我踏出车站的时候感受到的是无比舒适的海风，车站旁边便是海滩，栈桥上已经挤了很多人。不得不说青岛的旅游巴士还是很方便的，有很多选择可以到达想去的目的地。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMoDO.jpg\" alt=\"park\"></p>\n<p>先到达了提前订好的酒店，然后趁着天色还早，先一个人找些近一点的景点转一转。出门前向酒店前台打听了一下去各个景区的路线，前台一连串快速熟练地介绍让我有一种听相声演员报菜名的感觉。</p>\n<p>酒店对面就是紧邻海边的鲁迅公园，只需要走五分钟就能到海边，这里没有细沙，只有大量尖锐巨大的礁石，岸边风浪很大，待久了还真是有点快被冻感冒了。而海水，之前也有去过一些海滩，大连的星海公园，秦皇岛的金沙滩，还有霞浦的大京等等，但海水都有不同程度的浑浊，可青岛的海水真的是清澈的碧绿啊，和碧蓝的天空相映衬，美得一塌糊涂。</p>\n<p>翻过了几块相连的礁石，找了一块靠近海边又不会被海浪打到的地方坐了下来，打开手机里的后摇歌单随机播放，就那么看着此起彼伏的海浪，遥望辽阔的天空，耳中down down down继而不断up的旋律颇为符合此情此景，我想如果天气足够晴朗并且手机电量足够我能坐在这里呆一天。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMOPA.jpg\" alt=\"sea\"></p>\n<p>第二站是八大关，离鲁迅公园不是很远，但可能和来之前的预想不太一样吧，就是以八条著名的关隘命名的街道和一些建筑组成的，简单转了一圈觉得有些索然无味，也可能是没有同伴的弊端再次在这个时候体现了吧。顺路去第二海水浴场看了一会后天色也不早了，坐车回家。</p>\n<p>这一次在青岛要停留两个晚上，一个人四处瞎转难免太无聊，所以选择的是酒店的青旅房型，这样可以认识不同地方来玩的人，有了上次在丽江青旅的体验，表示还挺喜欢这样的旅行方式的。</p>\n<p>回到房间已经有一个人在了，是个在安徽上学的学生，都是喜欢旅行的人话题也自然而然地围绕这方面进行，这时候肚子也饿了，两个人出去找了一家小店点了几个菜喝了点酒，回来之后发现两个韩国妹子也回来了，之前这小哥就和我说过，至于为什么会有女生，因为这个房间是男女混住啊哈哈，因为想着一群糙汉子结伴出去玩多没意思啊，但真没报太大期望会有妹子住进来。过了一会陆续有两个南航的学生，一个在天津上学的福建三明小哥和一个也是从杭州过来的姐姐住进房间，几个人相互介绍闲扯了几句之后，我拉了一个微信群把几个人加进来，第一晚也没太敢和两个韩国妹子说话，就简单打了声招呼，大家也或多或少经历了旅途的劳累，简单收拾便各自睡去。</p>\n<p>因为提前看了天气预报第二天有雨，不太适合去海边玩，而另外几个人也有原本安排好的游玩计划，我自己也没有太明确的安排就和两个南航小学弟一起去爬崂山，天知道我当时怎么会下这个决定，下雨不适合去海边，难道就适合爬山了吗？Too young too naive啊！事实证明这个决定果然是脑子抽了才会做，到了山顶啥也没看到不说，被雨淋得浑身湿透。</p>\n<p>在我们狼狈不堪的爬山的时候，朱莉赟已经和两个韩国美女结伴去逛了啤酒博物馆和天幕城，我们在群里相约晚上一起吃饭。喜欢玩的人通常对吃也都很感兴趣，我们那天选了口味相对大众一点的火锅，玩乐的气氛下大家都聊得很开心，韩国妹子是在北京的留学生，所以交流也不成问题。来青岛自然啤酒是不能缺少的，韩国人果然能喝酒啊，而且一定要喝凉的，这样才够爽。吃够了大家觉得还不尽兴就去开了个KTV，路上又买了几罐啤酒，丁允自己的酒喝完了又把我们的酒也都喝了，快结束的时候又想找个气氛更浓一点的酒吧，我们只好劝她已经比较晚了，还是去海边逛一逛吧。</p>\n<p>黑夜笼罩下的青岛是那么地安静，即使在这十一长假里，夜里十点多街道上就已经鲜有人迹了，一路上除了我们说话的声音就只有拖鞋摩擦地面的声音，整齐而又清晰。褪去了白日的喧嚣，夜晚的栈桥上不见了拥挤的人潮，只有三三两两的游人乘着海风在桥上散步，惬意又自在。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMIKK.jpg\" alt=\"our\"></p>\n<p>雨后的海滩有些潮湿，也比平时更加细腻和柔软，光着脚走在海边，感受不时漫过脚面的海浪，带着一点冰凉，如果我在这样的城市生活，能偶尔在结束了一天的辛劳后来这里走一走，那该多好啊。</p>\n<p>出来旅行通常都是睡得晚起得早，因为想多看一些风景，因为不想浪费这难得的空闲。金沙滩，据说是青岛最好的海滩，这是我们第三天的目的地。早上几个女生都不愿意起，最后被我们硬拉了起来，但还是比原定出发的时间晚了一个小时左右，常曦前一天走得太累就没和我们一起去。到黄岛要差不多一个半小时的车程，途中经过胶州湾跨海隧道，全长7.8公里，只能感慨人类征服自然的能力真的很强大。</p>\n<p>这一天的天气很晴朗，阳光充足但并不热，海滩很大很长，沙子很细，甩掉鞋子飞奔到海岸线，我们在沙滩上写写画画，留下了一地青春。架起三脚架，拿起自拍杆，保存住我们的映像。虽然不同国家，却又有相似的属于曾经童年的游戏，围坐在沙堆旁，好似我们又回到了孩童时期，此时可以只沉浸在玩乐中。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMX8I.jpg\" alt=\"words\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaM4v6.jpg\" alt=\"moment\"></p>\n<p>路上总有相遇，人生总有惊喜，这一次是你们，下一次又会遇到谁和谁，又会发生怎样的故事，谁也不知道，谁也无法预料，但我知道他们一定在这里或者那里等着我，等着我说，你好，我叫XXX，我来自…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>没有期待已久的毕业旅行，也没有了漫长的暑假。就在匆忙间便完成了从学生到上班族的身份转变。不再能够说走就走，不再拥有那么多的假日，可是世界还是得走啊，我这么爱玩的人，太久不旅行是要憋坏的。</p>\n<p>青岛，一个我几年前就想去的地方，却一直拖到了这个时候才决定去。即使适逢十一黄金周，即使中途各种原因最后只剩我一个人前往，尤其在经历了去年一个人在霞浦旅途中的孤独和落寞之后让我有些害怕再次一个人踏上路途，可这些仍然无法阻拦我内心对大海的向往。</p>\n<p>老实讲，即使是已经坐在了开往青岛的高铁上，我也没想过这竟是如此让我难忘的一次旅行。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMbUH.jpg\" alt=\"station\"></p>\n<p>到达青岛之前程铭和我说当天的阳光有点足，可当我踏出车站的时候感受到的是无比舒适的海风，车站旁边便是海滩，栈桥上已经挤了很多人。不得不说青岛的旅游巴士还是很方便的，有很多选择可以到达想去的目的地。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMoDO.jpg\" alt=\"park\"></p>\n<p>先到达了提前订好的酒店，然后趁着天色还早，先一个人找些近一点的景点转一转。出门前向酒店前台打听了一下去各个景区的路线，前台一连串快速熟练地介绍让我有一种听相声演员报菜名的感觉。</p>\n<p>酒店对面就是紧邻海边的鲁迅公园，只需要走五分钟就能到海边，这里没有细沙，只有大量尖锐巨大的礁石，岸边风浪很大，待久了还真是有点快被冻感冒了。而海水，之前也有去过一些海滩，大连的星海公园，秦皇岛的金沙滩，还有霞浦的大京等等，但海水都有不同程度的浑浊，可青岛的海水真的是清澈的碧绿啊，和碧蓝的天空相映衬，美得一塌糊涂。</p>\n<p>翻过了几块相连的礁石，找了一块靠近海边又不会被海浪打到的地方坐了下来，打开手机里的后摇歌单随机播放，就那么看着此起彼伏的海浪，遥望辽阔的天空，耳中down down down继而不断up的旋律颇为符合此情此景，我想如果天气足够晴朗并且手机电量足够我能坐在这里呆一天。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMOPA.jpg\" alt=\"sea\"></p>\n<p>第二站是八大关，离鲁迅公园不是很远，但可能和来之前的预想不太一样吧，就是以八条著名的关隘命名的街道和一些建筑组成的，简单转了一圈觉得有些索然无味，也可能是没有同伴的弊端再次在这个时候体现了吧。顺路去第二海水浴场看了一会后天色也不早了，坐车回家。</p>\n<p>这一次在青岛要停留两个晚上，一个人四处瞎转难免太无聊，所以选择的是酒店的青旅房型，这样可以认识不同地方来玩的人，有了上次在丽江青旅的体验，表示还挺喜欢这样的旅行方式的。</p>\n<p>回到房间已经有一个人在了，是个在安徽上学的学生，都是喜欢旅行的人话题也自然而然地围绕这方面进行，这时候肚子也饿了，两个人出去找了一家小店点了几个菜喝了点酒，回来之后发现两个韩国妹子也回来了，之前这小哥就和我说过，至于为什么会有女生，因为这个房间是男女混住啊哈哈，因为想着一群糙汉子结伴出去玩多没意思啊，但真没报太大期望会有妹子住进来。过了一会陆续有两个南航的学生，一个在天津上学的福建三明小哥和一个也是从杭州过来的姐姐住进房间，几个人相互介绍闲扯了几句之后，我拉了一个微信群把几个人加进来，第一晚也没太敢和两个韩国妹子说话，就简单打了声招呼，大家也或多或少经历了旅途的劳累，简单收拾便各自睡去。</p>\n<p>因为提前看了天气预报第二天有雨，不太适合去海边玩，而另外几个人也有原本安排好的游玩计划，我自己也没有太明确的安排就和两个南航小学弟一起去爬崂山，天知道我当时怎么会下这个决定，下雨不适合去海边，难道就适合爬山了吗？Too young too naive啊！事实证明这个决定果然是脑子抽了才会做，到了山顶啥也没看到不说，被雨淋得浑身湿透。</p>\n<p>在我们狼狈不堪的爬山的时候，朱莉赟已经和两个韩国美女结伴去逛了啤酒博物馆和天幕城，我们在群里相约晚上一起吃饭。喜欢玩的人通常对吃也都很感兴趣，我们那天选了口味相对大众一点的火锅，玩乐的气氛下大家都聊得很开心，韩国妹子是在北京的留学生，所以交流也不成问题。来青岛自然啤酒是不能缺少的，韩国人果然能喝酒啊，而且一定要喝凉的，这样才够爽。吃够了大家觉得还不尽兴就去开了个KTV，路上又买了几罐啤酒，丁允自己的酒喝完了又把我们的酒也都喝了，快结束的时候又想找个气氛更浓一点的酒吧，我们只好劝她已经比较晚了，还是去海边逛一逛吧。</p>\n<p>黑夜笼罩下的青岛是那么地安静，即使在这十一长假里，夜里十点多街道上就已经鲜有人迹了，一路上除了我们说话的声音就只有拖鞋摩擦地面的声音，整齐而又清晰。褪去了白日的喧嚣，夜晚的栈桥上不见了拥挤的人潮，只有三三两两的游人乘着海风在桥上散步，惬意又自在。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMIKK.jpg\" alt=\"our\"></p>\n<p>雨后的海滩有些潮湿，也比平时更加细腻和柔软，光着脚走在海边，感受不时漫过脚面的海浪，带着一点冰凉，如果我在这样的城市生活，能偶尔在结束了一天的辛劳后来这里走一走，那该多好啊。</p>\n<p>出来旅行通常都是睡得晚起得早，因为想多看一些风景，因为不想浪费这难得的空闲。金沙滩，据说是青岛最好的海滩，这是我们第三天的目的地。早上几个女生都不愿意起，最后被我们硬拉了起来，但还是比原定出发的时间晚了一个小时左右，常曦前一天走得太累就没和我们一起去。到黄岛要差不多一个半小时的车程，途中经过胶州湾跨海隧道，全长7.8公里，只能感慨人类征服自然的能力真的很强大。</p>\n<p>这一天的天气很晴朗，阳光充足但并不热，海滩很大很长，沙子很细，甩掉鞋子飞奔到海岸线，我们在沙滩上写写画画，留下了一地青春。架起三脚架，拿起自拍杆，保存住我们的映像。虽然不同国家，却又有相似的属于曾经童年的游戏，围坐在沙堆旁，好似我们又回到了孩童时期，此时可以只沉浸在玩乐中。</p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaMX8I.jpg\" alt=\"words\"></p>\n<p><img src=\"https://s1.ax1x.com/2018/10/15/iaM4v6.jpg\" alt=\"moment\"></p>\n<p>路上总有相遇，人生总有惊喜，这一次是你们，下一次又会遇到谁和谁，又会发生怎样的故事，谁也不知道，谁也无法预料，但我知道他们一定在这里或者那里等着我，等着我说，你好，我叫XXX，我来自…</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjp5k06sz0005xl69os6vr4nq","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06tc000bxl693x6peu7h"},{"post_id":"cjp5k06sf0000xl69l5xs4ghg","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06tg000fxl69rocjyuco"},{"post_id":"cjp5k06sn0001xl69yb03cbyy","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06tj000jxl69kklc3rft"},{"post_id":"cjp5k06ta000axl69rzbaomvc","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06tm000nxl69ehmqzj9j"},{"post_id":"cjp5k06td000exl696aqgaihc","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06tq000qxl69oa736ib8"},{"post_id":"cjp5k06sx0004xl69a49mz4vf","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06tu000vxl691bl6z38w"},{"post_id":"cjp5k06th000hxl69eja3nlwk","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06ty000yxl69yn0jgm8x"},{"post_id":"cjp5k06tl000mxl69k4x6zs8p","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06u20012xl69vsydalhu"},{"post_id":"cjp5k06t40006xl690cna9upc","category_id":"cjp5k06tj000ixl69nsu5ydjv","_id":"cjp5k06u60015xl69rmv2co93"},{"post_id":"cjp5k06tn000pxl69vvliey7r","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06u90018xl69lynree3s"},{"post_id":"cjp5k06ts000uxl69ezx65t1e","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06ua001axl69ugahjfjf"},{"post_id":"cjp5k06t80009xl69zcfiqpti","category_id":"cjp5k06tj000ixl69nsu5ydjv","_id":"cjp5k06ua001cxl691ojntjrr"},{"post_id":"cjp5k06tv000xxl69qp1grvet","category_id":"cjp5k06st0002xl69lilorf2r","_id":"cjp5k06ub001fxl69ux5z4kpe"},{"post_id":"cjp5k06u00011xl69fav7q13f","category_id":"cjp5k06tj000ixl69nsu5ydjv","_id":"cjp5k06ub001hxl6950att0d6"},{"post_id":"cjp5k06u40014xl694a05jj81","category_id":"cjp5k06tj000ixl69nsu5ydjv","_id":"cjp5k06ud001kxl69vs6g6ymv"}],"PostTag":[{"post_id":"cjp5k06sf0000xl69l5xs4ghg","tag_id":"cjp5k06sw0003xl69d00lw5g6","_id":"cjp5k06th000gxl69yakdhd8t"},{"post_id":"cjp5k06sf0000xl69l5xs4ghg","tag_id":"cjp5k06t60008xl69fpf2kici","_id":"cjp5k06tj000kxl69ftoux5sy"},{"post_id":"cjp5k06td000exl696aqgaihc","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06tn000oxl69dmgodx5e"},{"post_id":"cjp5k06sn0001xl69yb03cbyy","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06tq000rxl69byrpq7bb"},{"post_id":"cjp5k06th000hxl69eja3nlwk","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06tu000wxl692iqfs74z"},{"post_id":"cjp5k06tl000mxl69k4x6zs8p","tag_id":"cjp5k06sw0003xl69d00lw5g6","_id":"cjp5k06ty000zxl69rrul64on"},{"post_id":"cjp5k06tl000mxl69k4x6zs8p","tag_id":"cjp5k06t60008xl69fpf2kici","_id":"cjp5k06u30013xl6960imf61p"},{"post_id":"cjp5k06tn000pxl69vvliey7r","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06u60016xl69mp1hh30k"},{"post_id":"cjp5k06sx0004xl69a49mz4vf","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06ua0019xl69y29jsvgk"},{"post_id":"cjp5k06sx0004xl69a49mz4vf","tag_id":"cjp5k06ts000txl69qfak35i6","_id":"cjp5k06ua001bxl69cn12xgxm"},{"post_id":"cjp5k06tv000xxl69qp1grvet","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06ua001exl69tozavse4"},{"post_id":"cjp5k06sz0005xl69os6vr4nq","tag_id":"cjp5k06td000dxl6909216r9y","_id":"cjp5k06ub001gxl69k84n4631"},{"post_id":"cjp5k06t40006xl690cna9upc","tag_id":"cjp5k06u90017xl69fn77ktyw","_id":"cjp5k06ud001jxl69qvdjo3sw"},{"post_id":"cjp5k06t80009xl69zcfiqpti","tag_id":"cjp5k06u90017xl69fn77ktyw","_id":"cjp5k06ud001lxl698jbfc8dn"},{"post_id":"cjp5k06ta000axl69rzbaomvc","tag_id":"cjp5k06ub001ixl69bpl7w6om","_id":"cjp5k06ug001nxl69lu73xi20"},{"post_id":"cjp5k06ts000uxl69ezx65t1e","tag_id":"cjp5k06ug001mxl69mx3236kr","_id":"cjp5k06uh001qxl69ijge8aap"},{"post_id":"cjp5k06ts000uxl69ezx65t1e","tag_id":"cjp5k06uh001oxl69b9fbch2g","_id":"cjp5k06ui001rxl69unpl7ixp"},{"post_id":"cjp5k06u00011xl69fav7q13f","tag_id":"cjp5k06u90017xl69fn77ktyw","_id":"cjp5k06uj001txl695dxobis0"},{"post_id":"cjp5k06u40014xl694a05jj81","tag_id":"cjp5k06u90017xl69fn77ktyw","_id":"cjp5k06uk001uxl69z8q79ko6"}],"Tag":[{"name":"前端","_id":"cjp5k06sw0003xl69d00lw5g6"},{"name":"vue","_id":"cjp5k06t60008xl69fpf2kici"},{"name":"JS","_id":"cjp5k06td000dxl6909216r9y"},{"name":"ES6","_id":"cjp5k06ts000txl69qfak35i6"},{"name":"生活","_id":"cjp5k06u90017xl69fn77ktyw"},{"name":"小程序","_id":"cjp5k06ub001ixl69bpl7w6om"},{"name":"操作系统","_id":"cjp5k06ug001mxl69mx3236kr"},{"name":"MAC","_id":"cjp5k06uh001oxl69b9fbch2g"}]}}